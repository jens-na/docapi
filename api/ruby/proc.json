{
  "new": "Creates a new <code>Proc</code> object, bound to the current\ncontext. <code>Proc::new</code> may be called without a block only\nwithin a method with an attached block, in which case that block is\nconverted to the <code>Proc</code> object.\n\n   def proc_from\n     Proc.new\n   end\n   proc = proc_from { \"hello\" }\n   proc.call   #=> \"hello\"",
  "call": "Invokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide \"call\".\n\nFor procs created using <code>lambda</code> or <code>->()</code> an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using <code>Proc.new</code> or\n<code>Kernel.proc</code>, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso <code>Proc#yield</code>.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2) (ArgumentError)\n   \tfrom prog.rb:5:in `call'\n   \tfrom prog.rb:5:in `<main>'",
  "[]": "Invokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide \"call\".\n\nFor procs created using <code>lambda</code> or <code>->()</code> an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using <code>Proc.new</code> or\n<code>Kernel.proc</code>, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso <code>Proc#yield</code>.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2) (ArgumentError)\n   \tfrom prog.rb:5:in `call'\n   \tfrom prog.rb:5:in `<main>'",
  "===": "Invokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide \"call\".\n\nFor procs created using <code>lambda</code> or <code>->()</code> an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using <code>Proc.new</code> or\n<code>Kernel.proc</code>, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso <code>Proc#yield</code>.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2) (ArgumentError)\n   \tfrom prog.rb:5:in `call'\n   \tfrom prog.rb:5:in `<main>'",
  "yield": "Invokes the block, setting the block's parameters to the values in\n<i>params</i> using something close to method calling semantics.\nGenerates a warning if multiple values are passed to a proc that\nexpects just one (previously this silently converted the parameters\nto an array).  Note that prc.() invokes prc.call() with the parameters\ngiven.  It's a syntax sugar to hide \"call\".\n\nFor procs created using <code>lambda</code> or <code>->()</code> an error\nis generated if the wrong number of parameters are passed to a Proc with\nmultiple parameters.  For procs created using <code>Proc.new</code> or\n<code>Kernel.proc</code>, extra parameters are silently discarded.\n\nReturns the value of the last expression evaluated in the block. See\nalso <code>Proc#yield</code>.\n\n   a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}\n   a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]\n   a_proc[9, 1, 2, 3]        #=> [9, 18, 27]\n   a_proc = lambda {|a,b| a}\n   a_proc.call(1,2,3)\n\n<em>produces:</em>\n\n   prog.rb:4:in `block in <main>': wrong number of arguments (3 for 2) (ArgumentError)\n   \tfrom prog.rb:5:in `call'\n   \tfrom prog.rb:5:in `<main>'",
  "to_proc": "Part of the protocol for converting objects to <code>Proc</code>\nobjects. Instances of class <code>Proc</code> simply return\nthemselves.",
  "arity": "Returns the number of arguments that would not be ignored. If the block\nis declared to take no arguments, returns 0. If the block is known\nto take exactly n arguments, returns n. If the block has optional\narguments, return -n-1, where n is the number of mandatory\narguments. A <code>proc</code> with no argument declarations\nis the same a block declaring <code>||</code> as its arguments.\n\n   proc {}.arity          #=>  0\n   proc {||}.arity        #=>  0\n   proc {|a|}.arity       #=>  1\n   proc {|a,b|}.arity     #=>  2\n   proc {|a,b,c|}.arity   #=>  3\n   proc {|*a|}.arity      #=> -1\n   proc {|a,*b|}.arity    #=> -2\n   proc {|a,*b, c|}.arity #=> -3\n\n   proc   { |x = 0| }.arity       #=> 0\n   lambda { |a = 0| }.arity       #=> -1\n   proc   { |x=0, y| }.arity      #=> 1\n   lambda { |x=0, y| }.arity      #=> -2\n   proc   { |x=0, y=0| }.arity    #=> 0\n   lambda { |x=0, y=0| }.arity    #=> -1\n   proc   { |x, y=0| }.arity      #=> 1\n   lambda { |x, y=0| }.arity      #=> -2\n   proc   { |(x, y), z=0| }.arity #=> 1\n   lambda { |(x, y), z=0| }.arity #=> -2",
  "clone": ":nodoc:",
  "dup": ":nodoc:",
  "hash": "Returns a hash value corresponding to proc body.",
  "to_s": "Returns the unique identifier for this proc, along with\nan indication of where the proc was defined.",
  "inspect": "Returns the unique identifier for this proc, along with\nan indication of where the proc was defined.",
  "lambda?": "Returns +true+ for a Proc object for which argument handling is rigid.\nSuch procs are typically generated by +lambda+.\n\nA Proc object generated by +proc+ ignores extra arguments.\n\n  proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]\n\nIt provides +nil+ for missing arguments.\n\n  proc {|a,b| [a,b] }.call(1)        #=> [1,nil]\n\nIt expands a single array argument.\n\n  proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]\n\nA Proc object generated by +lambda+ doesn't have such tricks.\n\n  lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError\n  lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError\n  lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError\n\nProc#lambda? is a predicate for the tricks.\nIt returns +true+ if no tricks apply.\n\n  lambda {}.lambda?            #=> true\n  proc {}.lambda?              #=> false\n\nProc.new is the same as +proc+.\n\n  Proc.new {}.lambda?          #=> false\n\n+lambda+, +proc+ and Proc.new preserve the tricks of\na Proc object given by <code>&</code> argument.\n\n  lambda(&lambda {}).lambda?   #=> true\n  proc(&lambda {}).lambda?     #=> true\n  Proc.new(&lambda {}).lambda? #=> true\n\n  lambda(&proc {}).lambda?     #=> false\n  proc(&proc {}).lambda?       #=> false\n  Proc.new(&proc {}).lambda?   #=> false\n\nA Proc object generated by <code>&</code> argument has the tricks\n\n  def n(&b) b.lambda? end\n  n {}                         #=> false\n\nThe <code>&</code> argument preserves the tricks if a Proc object\nis given by <code>&</code> argument.\n\n  n(&lambda {})                #=> true\n  n(&proc {})                  #=> false\n  n(&Proc.new {})              #=> false\n\nA Proc object converted from a method has no tricks.\n\n  def m() end\n  method(:m).to_proc.lambda?   #=> true\n\n  n(&method(:m))               #=> true\n  n(&method(:m).to_proc)       #=> true\n\n+define_method+ is treated the same as method definition.\nThe defined method has no tricks.\n\n  class C\n    define_method(:d) {}\n  end\n  C.new.d(1,2)       #=> ArgumentError\n  C.new.method(:d).to_proc.lambda?   #=> true\n\n+define_method+ always defines a method without the tricks,\neven if a non-lambda Proc object is given.\nThis is the only exception for which the tricks are not preserved.\n\n  class C\n    define_method(:e, &proc {})\n  end\n  C.new.e(1,2)       #=> ArgumentError\n  C.new.method(:e).to_proc.lambda?   #=> true\n\nThis exception insures that methods never have tricks\nand makes it easy to have wrappers to define methods that behave as usual.\n\n  class C\n    def self.def2(name, &body)\n      define_method(name, &body)\n    end\n\n    def2(:f) {}\n  end\n  C.new.f(1,2)       #=> ArgumentError\n\nThe wrapper <i>def2</i> defines a method which has no tricks.",
  "binding": "Returns the binding associated with <i>prc</i>. Note that\n<code>Kernel#eval</code> accepts either a <code>Proc</code> or a\n<code>Binding</code> object as its second parameter.\n\n   def fred(param)\n     proc {}\n   end\n\n   b = fred(99)\n   eval(\"param\", b.binding)   #=> 99",
  "curry": "Returns a curried proc. If the optional <i>arity</i> argument is given,\nit determines the number of arguments.\nA curried proc receives some arguments. If a sufficient number of\narguments are supplied, it passes the supplied arguments to the original\nproc and returns the result. Otherwise, returns another curried proc that\ntakes the rest of arguments.\n\n   b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 6\n   p b.curry(5)[1][2][3][4][5]  #=> 6\n   p b.curry(5)[1, 2][3, 4][5]  #=> 6\n   p b.curry(1)[1]              #=> 1\n\n   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)[1]              #=> 1\n\n   b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 for 3)\n   p b.curry(5)                 #=> wrong number of arguments (5 for 3)\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }\n   p b.curry[1][2][3]           #=> 6\n   p b.curry[1, 2][3, 4]        #=> 10\n   p b.curry(5)[1][2][3][4][5]  #=> 15\n   p b.curry(5)[1, 2][3, 4][5]  #=> 15\n   p b.curry(1)                 #=> wrong number of arguments (1 for 3)\n\n   b = proc { :foo }\n   p b.curry[]                  #=> :foo",
  "source_location": "Returns the Ruby source filename and line number containing this proc\nor +nil+ if this proc was not defined in Ruby (i.e. native)",
  "parameters": "Returns the parameter information of this proc.\n\n   prc = lambda{|x, y=42, *other|}\n   prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]"
}