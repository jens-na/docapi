{
  "initialize": "Creates a new UNIX server socket bound to _path_.\n\n  serv = UNIXServer.new(\"/tmp/sock\")\n  s = serv.accept\n  p s.read",
  "accept": "Accepts an incoming connection.\nIt returns a new UNIXSocket object.\n\n  UNIXServer.open(\"/tmp/sock\") {|serv|\n    UNIXSocket.open(\"/tmp/sock\") {|c|\n      s = serv.accept\n      s.puts \"hi\"\n      s.close\n      p c.read #=> \"hi\\n\"\n    }\n  }",
  "accept_nonblock": "Accepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an accepted UNIXSocket for the incoming connection.\n\n=== Example\n\trequire 'socket'\n\tserv = UNIXServer.new(\"/tmp/sock\")\n\tbegin # emulate blocking accept\n\t  sock = serv.accept_nonblock\n\trescue IO::WaitReadable, Errno::EINTR\n\t  IO.select([serv])\n\t  retry\n\tend\n\t# sock is an accepted socket.\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto UNIXServer#accept_nonblock fails.\n\nUNIXServer#accept_nonblock may raise any error corresponding to accept(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED or Errno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock.\n\n=== See\n* UNIXServer#accept\n* Socket#accept",
  "sysaccept": "Accepts a new connection.\nIt returns the new file descriptor which is an integer.\n\n  UNIXServer.open(\"/tmp/sock\") {|serv|\n    UNIXSocket.open(\"/tmp/sock\") {|c|\n      fd = serv.sysaccept\n      s = IO.new(fd)\n      s.puts \"hi\"\n      s.close\n      p c.read #=> \"hi\\n\"\n    }\n  }",
  "listen": "Listens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\tsocket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsocket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised if the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference"
}