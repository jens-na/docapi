{
  "inspect": "Returns a human-readable string representation of this instruction\nsequence, including the #label and #path.",
  "disasm": "Takes +body+, a Method or Proc object, and returns a String with the\nhuman readable instructions for +body+.\n\nFor a Method object:\n\n  # /tmp/method.rb\n  def hello\n    puts \"hello, world\"\n  end\n\n  puts RubyVM::InstructionSequence.disasm(method(:hello))\n\nProduces:\n\n  == disasm: <RubyVM::InstructionSequence:hello@/tmp/method.rb>============\n  0000 trace            8                                               (   1)\n  0002 trace            1                                               (   2)\n  0004 putself\n  0005 putstring        \"hello, world\"\n  0007 send             :puts, 1, nil, 8, <ic:0>\n  0013 trace            16                                              (   3)\n  0015 leave                                                            (   2)\n\nFor a Proc:\n\n  # /tmp/proc.rb\n  p = proc { num = 1 + 2 }\n  puts RubyVM::InstructionSequence.disasm(p)\n\nProduces:\n\n  == disasm: <RubyVM::InstructionSequence:block in <main>@/tmp/proc.rb>===\n  == catch table\n  | catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000\n  | catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012\n  |------------------------------------------------------------------------\n  local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)\n  [ 2] num\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n  0008 dup\n  0009 setlocal         num, 0\n  0012 leave",
  "disassemble": "Takes +body+, a Method or Proc object, and returns a String with the\nhuman readable instructions for +body+.\n\nFor a Method object:\n\n  # /tmp/method.rb\n  def hello\n    puts \"hello, world\"\n  end\n\n  puts RubyVM::InstructionSequence.disasm(method(:hello))\n\nProduces:\n\n  == disasm: <RubyVM::InstructionSequence:hello@/tmp/method.rb>============\n  0000 trace            8                                               (   1)\n  0002 trace            1                                               (   2)\n  0004 putself\n  0005 putstring        \"hello, world\"\n  0007 send             :puts, 1, nil, 8, <ic:0>\n  0013 trace            16                                              (   3)\n  0015 leave                                                            (   2)\n\nFor a Proc:\n\n  # /tmp/proc.rb\n  p = proc { num = 1 + 2 }\n  puts RubyVM::InstructionSequence.disasm(p)\n\nProduces:\n\n  == disasm: <RubyVM::InstructionSequence:block in <main>@/tmp/proc.rb>===\n  == catch table\n  | catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000\n  | catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012\n  |------------------------------------------------------------------------\n  local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)\n  [ 2] num\n  0000 trace            1                                               (   1)\n  0002 putobject        1\n  0004 putobject        2\n  0006 opt_plus         <ic:1>\n  0008 dup\n  0009 setlocal         num, 0\n  0012 leave",
  "to_a": "Returns an Array with 14 elements representing the instruction sequence\nwith the following data:\n\n[magic]\n  A string identifying the data format. <b>Always\n  +YARVInstructionSequence/SimpleDataFormat+.</b>\n\n[major_version]\n  The major version of the instruction sequence.\n\n[minor_version]\n  The minor version of the instruction sequence.\n\n[format_type]\n  A number identifying the data format. <b>Always 1</b>.\n\n[misc]\n  A hash containing:\n\n  [+:arg_size+]\nthe total number of arguments taken by the method or the block (0 if\n_iseq_ doesn't represent a method or block)\n  [+:local_size+]\nthe number of local variables + 1\n  [+:stack_max+]\nused in calculating the stack depth at which a SystemStackError is\nthrown.\n\n[#label]\n  The name of the context (block, method, class, module, etc.) that this\n  instruction sequence belongs to.\n\n  <code><main></code> if it's at the top level, <code><compiled></code> if\n  it was evaluated from a string.\n\n[#path]\n  The relative path to the Ruby file where the instruction sequence was\n  loaded from.\n\n  <code><compiled></code> if the iseq was evaluated from a string.\n\n[#absolute_path]\n  The absolute path to the Ruby file where the instruction sequence was\n  loaded from.\n\n  +nil+ if the iseq was evaluated from a string.\n\n[#first_lineno]\n  The number of the first source line where the instruction sequence was\n  loaded from.\n\n[type]\n  The type of the instruction sequence.\n\n  Valid values are +:top+, +:method+, +:block+, +:class+, +:rescue+,\n  +:ensure+, +:eval+, +:main+, and +:defined_guard+.\n\n[locals]\n  An array containing the names of all arguments and local variables as\n  symbols.\n\n[args]\n  The arity if the method or block only has required arguments.\n\n  Otherwise an array of:\n\n    [required_argc, [optional_arg_labels, ...],\n     splat_index, post_splat_argc, post_splat_index,\n     block_index, simple]\n\n  More info about these values can be found in +vm_core.h+.\n\n[catch_table]\n  A list of exceptions and control flow operators (rescue, next, redo,\n  break, etc.).\n\n[bytecode]\n  An array of arrays containing the instruction names and operands that\n  make up the body of the instruction sequence.",
  "eval": "Evaluates the instruction sequence and returns the result.\n\n    RubyVM::InstructionSequence.compile(\"1 + 2\").eval #=> 3",
  "path": "Returns the path of this instruction sequence.\n\n<code><compiled></code> if the iseq was evaluated from a string.\n\nFor example, using irb:\n\niseq = RubyVM::InstructionSequence.compile('num = 1 + 2')\n#=> <RubyVM::InstructionSequence:<compiled>@<compiled>>\niseq.path\n#=> \"<compiled>\"\n\nUsing ::compile_file:\n\n# /tmp/method.rb\ndef hello\n puts \"hello, world\"\nend\n\n# in irb\n> iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')\n> iseq.path #=> /tmp/method.rb",
  "absolute_path": "Returns the absolute path of this instruction sequence.\n\n+nil+ if the iseq was evaluated from a string.\n\nFor example, using ::compile_file:\n\n# /tmp/method.rb\ndef hello\n puts \"hello, world\"\nend\n\n# in irb\n> iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')\n> iseq.absolute_path #=> /tmp/method.rb",
  "label": "Returns the label of this instruction sequence.\n\n<code><main></code> if it's at the top level, <code><compiled></code> if it\nwas evaluated from a string.\n\nFor example, using irb:\n\niseq = RubyVM::InstructionSequence.compile('num = 1 + 2')\n#=> <RubyVM::InstructionSequence:<compiled>@<compiled>>\niseq.label\n#=> \"<compiled>\"\n\nUsing ::compile_file:\n\n# /tmp/method.rb\ndef hello\n puts \"hello, world\"\nend\n\n# in irb\n> iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')\n> iseq.label #=> <main>",
  "base_label": "Returns the base label of this instruction sequence.\n\nFor example, using irb:\n\niseq = RubyVM::InstructionSequence.compile('num = 1 + 2')\n#=> <RubyVM::InstructionSequence:<compiled>@<compiled>>\niseq.base_label\n#=> \"<compiled>\"\n\nUsing ::compile_file:\n\n# /tmp/method.rb\ndef hello\n puts \"hello, world\"\nend\n\n# in irb\n> iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')\n> iseq.base_label #=> <main>",
  "first_lineno": "Returns the number of the first source line where the instruction sequence\nwas loaded from.\n\nFor example, using irb:\n\niseq = RubyVM::InstructionSequence.compile('num = 1 + 2')\n#=> <RubyVM::InstructionSequence:<compiled>@<compiled>>\niseq.first_lineno\n#=> 1",
  "line_trace_all": "<b>Experimental MRI specific feature, only available as C level api.</b>\n\nReturns all +specified_line+ events.",
  "line_trace_specify": "<b>Experimental MRI specific feature, only available as C level api.</b>\n\nSet a +specified_line+ event at the given line position, if the +set+\nparameter is +true+.\n\nThis method is useful for building a debugger breakpoint at a specific line.\n\nA TypeError is raised if +set+ is not boolean.\n\nIf +pos+ is a negative integer a TypeError exception is raised.",
  "marshal_dump": "",
  "marshal_load": "",
  "compile": "Takes +source+, a String of Ruby code and compiles it to an\nInstructionSequence.\n\nOptionally takes +file+, +path+, and +line+ which describe the filename,\nabsolute path and first line number of the ruby code in +source+ which are\nmetadata attached to the returned +iseq+.\n\n+options+, which can be +true+, +false+ or a +Hash+, is used to\nmodify the default behavior of the Ruby iseq compiler.\n\nFor details regarding valid compile options see ::compile_option=.\n\n   RubyVM::InstructionSequence.compile(\"a = 1 + 2\")\n   #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>",
  "new": "Takes +source+, a String of Ruby code and compiles it to an\nInstructionSequence.\n\nOptionally takes +file+, +path+, and +line+ which describe the filename,\nabsolute path and first line number of the ruby code in +source+ which are\nmetadata attached to the returned +iseq+.\n\n+options+, which can be +true+, +false+ or a +Hash+, is used to\nmodify the default behavior of the Ruby iseq compiler.\n\nFor details regarding valid compile options see ::compile_option=.\n\n   RubyVM::InstructionSequence.compile(\"a = 1 + 2\")\n   #=> <RubyVM::InstructionSequence:<compiled>@<compiled>>",
  "compile_file": "Takes +file+, a String with the location of a Ruby source file, reads,\nparses and compiles the file, and returns +iseq+, the compiled\nInstructionSequence with source location metadata set.\n\nOptionally takes +options+, which can be +true+, +false+ or a +Hash+, to\nmodify the default behavior of the Ruby iseq compiler.\n\nFor details regarding valid compile options see ::compile_option=.\n\n    # /tmp/hello.rb\n    puts \"Hello, world!\"\n\n    # elsewhere\n    RubyVM::InstructionSequence.compile_file(\"/tmp/hello.rb\")\n    #=> <RubyVM::InstructionSequence:<main>@/tmp/hello.rb>",
  "compile_option": "Returns a hash of default options used by the Ruby iseq compiler.\n\nFor details, see InstructionSequence.compile_option=.",
  "compile_option=": "Sets the default values for various optimizations in the Ruby iseq\ncompiler.\n\nPossible values for +options+ include +true+, which enables all options,\n+false+ which disables all options, and +nil+ which leaves all options\nunchanged.\n\nYou can also pass a +Hash+ of +options+ that you want to change, any\noptions not present in the hash will be left unchanged.\n\nPossible option names (which are keys in +options+) which can be set to\n+true+ or +false+ include:\n\n* +:inline_const_cache+\n* +:instructions_unification+\n* +:operands_unification+\n* +:peephole_optimization+\n* +:specialized_instruction+\n* +:stack_caching+\n* +:tailcall_optimization+\n* +:trace_instruction+\n\nAdditionally, +:debug_level+ can be set to an integer.\n\nThese default options can be overwritten for a single run of the iseq\ncompiler by passing any of the above values as the +options+ parameter to\n::new, ::compile and ::compile_file.",
  "of": "Returns the instruction sequence containing the given proc or method.\n\nFor example, using irb:\n\n# a proc\n> p = proc { num = 1 + 2 }\n> RubyVM::InstructionSequence.of(p)\n> #=> <RubyVM::InstructionSequence:block in irb_binding@(irb)>\n\n# for a method\n> def foo(bar); puts bar; end\n> RubyVM::InstructionSequence.of(method(:foo))\n> #=> <RubyVM::InstructionSequence:foo@(irb)>\n\nUsing ::compile_file:\n\n# /tmp/iseq_of.rb\ndef hello\n puts \"hello, world\"\nend\n\n$a_global_proc = proc { str = 'a' + 'b' }\n\n# in irb\n> require '/tmp/iseq_of.rb'\n\n# first the method hello\n> RubyVM::InstructionSequence.of(method(:hello))\n> #=> #<RubyVM::InstructionSequence:0x007fb73d7cb1d0>\n\n# then the global proc\n> RubyVM::InstructionSequence.of($a_global_proc)\n> #=> #<RubyVM::InstructionSequence:0x007fb73d7caf78>"
}