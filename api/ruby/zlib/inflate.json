{
  "inflate": "call-seq:\n  inflate(deflate_string)                 -> String\n  inflate(deflate_string) { |chunk| ... } -> nil\n\nInputs +deflate_string+ into the inflate stream and returns the output from\nthe stream.  Calling this method, both the input and the output buffer of\nthe stream are flushed.  If string is +nil+, this method finishes the\nstream, just like Zlib::ZStream#finish.\n\nIf a block is given consecutive inflated chunks from the +deflate_string+\nare yielded to the block and +nil+ is returned.\n\nRaises a Zlib::NeedDict exception if a preset dictionary is needed to\ndecompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then\ncall this method again with an empty string to flush the stream:\n\n  inflater = Zlib::Inflate.new\n\n  begin\n    out = inflater.inflate compressed\n  rescue Zlib::NeedDict\n    # ensure the dictionary matches the stream's required dictionary\n    raise unless inflater.adler == Zlib.adler32(dictionary)\n\n    inflater.set_dictionary dictionary\n    inflater.inflate ''\n  end\n\n  # ...\n\n  inflater.close\n\nSee also Zlib::Inflate.new",
  "initialize": "call-seq:\n  Zlib::Inflate.new(window_bits = Zlib::MAX_WBITS)\n\nCreates a new inflate stream for decompression.  +window_bits+ sets the\nsize of the history buffer and can have the following values:\n\n0::\n  Have inflate use the window size from the zlib header of the compressed\n  stream.\n\n(8..15)\n  Overrides the window size of the inflate header in the compressed stream.\n  The window size must be greater than or equal to the window size of the\n  compressed stream.\n\nGreater than 15::\n  Add 32 to window_bits to enable zlib and gzip decoding with automatic\n  header detection, or add 16 to decode only the gzip format (a\n  Zlib::DataError will be raised for a non-gzip stream).\n\n(-8..-15)::\n  Enables raw deflate mode which will not generate a check value, and will\n  not look for any check values for comparison at the end of the stream.\n\n  This is for use with other formats that use the deflate compressed data\n  format such as zip which provide their own check values.\n\n== Example\n\n  open \"compressed.file\" do |compressed_io|\n    zi = Zlib::Inflate.new(Zlib::MAX_WBITS + 32)\n\n    begin\n      open \"uncompressed.file\", \"w+\" do |uncompressed_io|\n        uncompressed_io << zi.inflate(compressed_io.read)\n      end\n    ensure\n      zi.close\n    end\n  end",
  "add_dictionary": "call-seq: add_dictionary(string)\n\nProvide the inflate stream with a dictionary that may be required in the\nfuture.  Multiple dictionaries may be provided.  The inflate stream will\nautomatically choose the correct user-provided dictionary based on the\nstream's required dictionary.",
  "<<": "Inputs +string+ into the inflate stream just like Zlib::Inflate#inflate, but\nreturns the Zlib::Inflate object itself.  The output from the stream is\npreserved in output buffer.",
  "sync": "Inputs +string+ into the end of input buffer and skips data until a full\nflush point can be found.  If the point is found in the buffer, this method\nflushes the buffer and returns false.  Otherwise it returns +true+ and the\nfollowing data of full flush point is preserved in the buffer.",
  "sync_point?": "Quoted verbatim from original documentation:\n\n  What is this?\n\n<tt>:)</tt>",
  "set_dictionary": "Sets the preset dictionary and returns +string+.  This method is available just\nonly after a Zlib::NeedDict exception was raised.  See zlib.h for details."
}