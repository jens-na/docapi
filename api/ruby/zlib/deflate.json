{
  "deflate": "call-seq:\n  z.deflate(string, flush = Zlib::NO_FLUSH)                 -> String\n  z.deflate(string, flush = Zlib::NO_FLUSH) { |chunk| ... } -> nil\n\nInputs +string+ into the deflate stream and returns the output from the\nstream.  On calling this method, both the input and the output buffers of\nthe stream are flushed.  If +string+ is nil, this method finishes the\nstream, just like Zlib::ZStream#finish.\n\nIf a block is given consecutive deflated chunks from the +string+ are\nyielded to the block and +nil+ is returned.\n\nThe +flush+ parameter specifies the flush mode.  The following constants\nmay be used:\n\nZlib::NO_FLUSH:: The default\nZlib::SYNC_FLUSH:: Flushes the output to a byte boundary\nZlib::FULL_FLUSH:: SYNC_FLUSH + resets the compression state\nZlib::FINISH:: Pending input is processed, pending output is flushed.\n\nSee the constants for further description.",
  "initialize": "call-seq:\n  Zlib::Deflate.new(level=DEFAULT_COMPRESSION, window_bits=MAX_WBITS, mem_level=DEF_MEM_LEVEL, strategy=DEFAULT_STRATEGY)\n\nCreates a new deflate stream for compression. If a given argument is nil,\nthe default value of that argument is used.\n\nThe +level+ sets the compression level for the deflate stream between 0 (no\ncompression) and 9 (best compression. The following constants have been\ndefined to make code more readable:\n\n* Zlib::NO_COMPRESSION = 0\n* Zlib::BEST_SPEED = 1\n* Zlib::DEFAULT_COMPRESSION = 6\n* Zlib::BEST_COMPRESSION = 9\n\nThe +window_bits+ sets the size of the history buffer and should be between\n8 and 15.  Larger values of this parameter result in better compression at\nthe expense of memory usage.\n\nThe +mem_level+ specifies how much memory should be allocated for the\ninternal compression state.  1 uses minimum memory but is slow and reduces\ncompression ratio while 9 uses maximum memory for optimal speed.  The\ndefault value is 8. Two constants are defined:\n\n* Zlib::DEF_MEM_LEVEL\n* Zlib::MAX_MEM_LEVEL\n\nThe +strategy+ sets the deflate compression strategy.  The following\nstrategies are available:\n\nZlib::DEFAULT_STRATEGY:: For normal data\nZlib::FILTERED:: For data produced by a filter or predictor\nZlib::FIXED:: Prevents dynamic Huffman codes\nZlib::HUFFMAN_ONLY:: Prevents string matching\nZlib::RLE:: Designed for better compression of PNG image data\n\nSee the constants for further description.\n\n== Examples\n\n=== Basic\n\n  open \"compressed.file\", \"w+\" do |io|\n    io << Zlib::Deflate.new.deflate(File.read(\"big.file\"))\n  end\n\n=== Custom compression\n\n  open \"compressed.file\", \"w+\" do |compressed_io|\n    deflate = Zlib::Deflate.new(Zlib::BEST_COMPRESSION,\n                                Zlib::MAX_WBITS,\n                                Zlib::MAX_MEM_LEVEL,\n                                Zlib::HUFFMAN_ONLY)\n\n    begin\n      open \"big.file\" do |big_io|\n        until big_io.eof? do\n          compressed_io << zd.deflate(big_io.read(16384))\n        end\n      end\n    ensure\n      deflate.close\n    end\n  end\n\nWhile this example will work, for best optimization review the flags for\nyour specific time, memory usage and output space requirements.",
  "initialize_copy": "Duplicates the deflate stream.",
  "<<": "call-seq: << string\n\nInputs +string+ into the deflate stream just like Zlib::Deflate#deflate, but\nreturns the Zlib::Deflate object itself.  The output from the stream is\npreserved in output buffer.",
  "flush": "call-seq:\n  flush(flush = Zlib::SYNC_FLUSH)                 -> String\n  flush(flush = Zlib::SYNC_FLUSH) { |chunk| ... } -> nil\n\nThis method is equivalent to <tt>deflate('', flush)</tt>. This method is\njust provided to improve the readability of your Ruby program.  If a block\nis given chunks of deflate output are yielded to the block until the buffer\nis flushed.\n\nSee Zlib::Deflate#deflate for detail on the +flush+ constants NO_FLUSH,\nSYNC_FLUSH, FULL_FLUSH and FINISH.",
  "params": "call-seq: params(level, strategy)\n\nChanges the parameters of the deflate stream to allow changes between\ndifferent types of data that require different types of compression.  Any\nunprocessed data is flushed before changing the params.\n\nSee Zlib::Deflate.new for a description of +level+ and +strategy+.",
  "set_dictionary": "call-seq: set_dictionary(string)\n\nSets the preset dictionary and returns +string+. This method is available\njust only after Zlib::Deflate.new or Zlib::ZStream#reset method was called.\nSee zlib.h for details.\n\nCan raise errors of Z_STREAM_ERROR if a parameter is invalid (such as\nNULL dictionary) or the stream state is inconsistent, Z_DATA_ERROR if\nthe given dictionary doesn't match the expected one (incorrect adler32 value)"
}