{
  "accept": "Accepts an incoming connection. It returns a new TCPSocket object.\n\n  TCPServer.open(\"127.0.0.1\", 14641) {|serv|\n    s = serv.accept\n    s.puts Time.now\n    s.close\n  }",
  "accept_nonblock": "Accepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an accepted TCPSocket for the incoming connection.\n\n=== Example\n\trequire 'socket'\n\tserv = TCPServer.new(2202)\n\tbegin # emulate blocking accept\n\t  sock = serv.accept_nonblock\n\trescue IO::WaitReadable, Errno::EINTR\n\t  IO.select([serv])\n\t  retry\n\tend\n\t# sock is an accepted socket.\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto TCPServer#accept_nonblock fails.\n\nTCPServer#accept_nonblock may raise any error corresponding to accept(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED, Errno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock.\n\n=== See\n* TCPServer#accept\n* Socket#accept",
  "sysaccept": "Returns a file descriptor of a accepted connection.\n\n  TCPServer.open(\"127.0.0.1\", 28561) {|serv|\n    fd = serv.sysaccept\n    s = IO.for_fd(fd)\n    s.puts Time.now\n    s.close\n  }",
  "initialize": "Creates a new server socket bound to _port_.\n\nIf _hostname_ is given, the socket is bound to it.\n\n  serv = TCPServer.new(\"127.0.0.1\", 28561)\n  s = serv.accept\n  s.puts Time.now\n  s.close\n\nInternally, TCPServer.new calls getaddrinfo() function to\nobtain addresses.\nIf getaddrinfo() returns multiple addresses,\nTCPServer.new tries to create a server socket for each address\nand returns first one that is successful.",
  "listen": "Listens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\tsocket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsocket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised if the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference"
}