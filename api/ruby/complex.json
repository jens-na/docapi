{
  "rectangular": "Returns an array; [cmp.real, cmp.imag].\n\n   Complex(1, 2).rectangular  #=> [1, 2]",
  "rect": "Returns an array; [cmp.real, cmp.imag].\n\n   Complex(1, 2).rectangular  #=> [1, 2]",
  "polar": "Returns an array; [cmp.abs, cmp.arg].\n\n   Complex(1, 2).polar  #=> [2.23606797749979, 1.1071487177940904]",
  "real": "Returns the real part.\n\n   Complex(7).real      #=> 7\n   Complex(9, -4).real  #=> 9",
  "imaginary": "Returns the imaginary part.\n\n   Complex(7).imaginary      #=> 0\n   Complex(9, -4).imaginary  #=> -4",
  "imag": "Returns the imaginary part.\n\n   Complex(7).imaginary      #=> 0\n   Complex(9, -4).imaginary  #=> -4",
  "-@": "Returns negation of the value.\n\n   -Complex(1, 2)  #=> (-1-2i)",
  "+": "Performs addition.\n\n   Complex(2, 3)  + Complex(2, 3)   #=> (4+6i)\n   Complex(900)   + Complex(1)      #=> (901+0i)\n   Complex(-2, 9) + Complex(-9, 2)  #=> (-11+11i)\n   Complex(9, 8)  + 4               #=> (13+8i)\n   Complex(20, 9) + 9.8             #=> (29.8+9i)",
  "-": "Performs subtraction.\n\n   Complex(2, 3)  - Complex(2, 3)   #=> (0+0i)\n   Complex(900)   - Complex(1)      #=> (899+0i)\n   Complex(-2, 9) - Complex(-9, 2)  #=> (7+7i)\n   Complex(9, 8)  - 4               #=> (5+8i)\n   Complex(20, 9) - 9.8             #=> (10.2+9i)",
  "*": "Performs multiplication.\n\n   Complex(2, 3)  * Complex(2, 3)   #=> (-5+12i)\n   Complex(900)   * Complex(1)      #=> (900+0i)\n   Complex(-2, 9) * Complex(-9, 2)  #=> (0-85i)\n   Complex(9, 8)  * 4               #=> (36+32i)\n   Complex(20, 9) * 9.8             #=> (196.0+88.2i)",
  "/": "Performs division.\n\n   Complex(2, 3)  / Complex(2, 3)   #=> ((1/1)+(0/1)*i)\n   Complex(900)   / Complex(1)      #=> ((900/1)+(0/1)*i)\n   Complex(-2, 9) / Complex(-9, 2)  #=> ((36/85)-(77/85)*i)\n   Complex(9, 8)  / 4               #=> ((9/4)+(2/1)*i)\n   Complex(20, 9) / 9.8             #=> (2.0408163265306123+0.9183673469387754i)",
  "quo": "",
  "fdiv": "Performs division as each part is a float, never returns a float.\n\n   Complex(11, 22).fdiv(3)  #=> (3.6666666666666665+7.333333333333333i)",
  "**": "Performs exponentiation.\n\n   Complex('i') ** 2              #=> (-1+0i)\n   Complex(-8) ** Rational(1, 3)  #=> (1.0000000000000002+1.7320508075688772i)",
  "==": "Returns true if cmp equals object numerically.\n\n   Complex(2, 3)  == Complex(2, 3)   #=> true\n   Complex(5)     == 5               #=> true\n   Complex(0)     == 0.0             #=> true\n   Complex('1/3') == 0.33            #=> false\n   Complex('1/2') == '1/2'           #=> false",
  "coerce": ":nodoc:",
  "abs": "Returns the absolute part of its polar form.\n\n   Complex(-1).abs         #=> 1\n   Complex(3.0, -4.0).abs  #=> 5.0",
  "magnitude": "Returns the absolute part of its polar form.\n\n   Complex(-1).abs         #=> 1\n   Complex(3.0, -4.0).abs  #=> 5.0",
  "abs2": "Returns square of the absolute value.\n\n   Complex(-1).abs2         #=> 1\n   Complex(3.0, -4.0).abs2  #=> 25.0",
  "arg": "Returns the angle part of its polar form.\n\n   Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966",
  "angle": "Returns the angle part of its polar form.\n\n   Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966",
  "phase": "Returns the angle part of its polar form.\n\n   Complex.polar(3, Math::PI/2).arg  #=> 1.5707963267948966",
  "conjugate": "Returns the complex conjugate.\n\n   Complex(1, 2).conjugate  #=> (1-2i)",
  "conj": "Returns the complex conjugate.\n\n   Complex(1, 2).conjugate  #=> (1-2i)",
  "~": "Returns the complex conjugate.\n\n   Complex(1, 2).conjugate  #=> (1-2i)",
  "real?": "Returns false.",
  "complex?": ":nodoc:",
  "exact?": ":nodoc:",
  "inexact?": ":nodoc:",
  "numerator": "Returns the numerator.\n\n       1   2       3+4i  <-  numerator\n       - + -i  ->  ----\n       2   3        6    <-  denominator\n\n   c = Complex('1/2+2/3i')  #=> ((1/2)+(2/3)*i)\n   n = c.numerator          #=> (3+4i)\n   d = c.denominator        #=> 6\n   n / d                    #=> ((1/2)+(2/3)*i)\n   Complex(Rational(n.real, d), Rational(n.imag, d))\n                            #=> ((1/2)+(2/3)*i)\nSee denominator.",
  "denominator": "Returns the denominator (lcm of both denominator - real and imag).\n\nSee numerator.",
  "hash": ":nodoc:",
  "eql?": ":nodoc:",
  "to_s": "Returns the value as a string.\n\n   Complex(2).to_s                       #=> \"2+0i\"\n   Complex('-8/6').to_s                  #=> \"-4/3+0i\"\n   Complex('1/2i').to_s                  #=> \"0+1/2i\"\n   Complex(0, Float::INFINITY).to_s      #=> \"0+Infinity*i\"\n   Complex(Float::NAN, Float::NAN).to_s  #=> \"NaN+NaN*i\"",
  "inspect": "Returns the value as a string for inspection.\n\n   Complex(2).inspect                       #=> \"(2+0i)\"\n   Complex('-8/6').inspect                  #=> \"((-4/3)+0i)\"\n   Complex('1/2i').inspect                  #=> \"(0+(1/2)*i)\"\n   Complex(0, Float::INFINITY).inspect      #=> \"(0+Infinity*i)\"\n   Complex(Float::NAN, Float::NAN).inspect  #=> \"(NaN+NaN*i)\"",
  "marshal_dump": ":nodoc:",
  "compatible": "",
  "to_i": "Returns the value as an integer if possible (the imaginary part\nshould be exactly zero).\n\n   Complex(1, 0).to_i    #=> 1\n   Complex(1, 0.0).to_i  # RangeError\n   Complex(1, 2).to_i    # RangeError",
  "to_f": "Returns the value as a float if possible (the imaginary part should\nbe exactly zero).\n\n   Complex(1, 0).to_f    #=> 1.0\n   Complex(1, 0.0).to_f  # RangeError\n   Complex(1, 2).to_f    # RangeError",
  "to_r": "Returns the value as a rational if possible (the imaginary part\nshould be exactly zero).\n\n   Complex(1, 0).to_r    #=> (1/1)\n   Complex(1, 0.0).to_r  # RangeError\n   Complex(1, 2).to_r    # RangeError\n\nSee rationalize.",
  "rationalize": "Returns the value as a rational if possible (the imaginary part\nshould be exactly zero).\n\n   Complex(1.0/3, 0).rationalize  #=> (1/3)\n   Complex(1, 0.0).rationalize    # RangeError\n   Complex(1, 2).rationalize      # RangeError\n\nSee to_r.",
  "to_c": "Returns self.\n\n   Complex(2).to_c      #=> (2+0i)\n   Complex(-8, 6).to_c  #=> (-8+6i)",
  "I": "The imaginary unit."
}