{
  "Error": "",
  "initialize": "Creates a new StringScanner object to scan over the given +string+.\n+dup+ argument is obsolete and not used now.",
  "initialize_copy": "Duplicates a StringScanner object.",
  "must_C_version": "This method is defined for backward compatibility.",
  "reset": "Reset the scan pointer (index 0) and clear matching data.",
  "terminate": "Set the scan pointer to the end of the string and clear matching data.",
  "clear": "Equivalent to #terminate.\nThis method is obsolete; use #terminate instead.",
  "string": "Returns the string being scanned.",
  "string=": "Changes the string being scanned to +str+ and resets the scanner.\nReturns +str+.",
  "concat": "Appends +str+ to the string being scanned.\nThis method does not affect scan pointer.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.scan(/Fri /)\n  s << \" +1000 GMT\"\n  s.string            # -> \"Fri Dec 12 1975 14:39 +1000 GMT\"\n  s.scan(/Dec/)       # -> \"Dec\"",
  "<<": "Appends +str+ to the string being scanned.\nThis method does not affect scan pointer.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.scan(/Fri /)\n  s << \" +1000 GMT\"\n  s.string            # -> \"Fri Dec 12 1975 14:39 +1000 GMT\"\n  s.scan(/Dec/)       # -> \"Dec\"",
  "pos": "Returns the byte position of the scan pointer.  In the 'reset' position, this\nvalue is zero.  In the 'terminated' position (i.e. the string is exhausted),\nthis value is the bytesize of the string.\n\nIn short, it's a 0-based index into bytes of the string.\n\n  s = StringScanner.new('test string')\n  s.pos               # -> 0\n  s.scan_until /str/  # -> \"test str\"\n  s.pos               # -> 8\n  s.terminate         # -> #<StringScanner fin>\n  s.pos               # -> 11",
  "pos=": "Set the byte position of the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.pos = 7            # -> 7\n  s.rest               # -> \"ring\"",
  "charpos": "Returns the character position of the scan pointer.  In the 'reset' position, this\nvalue is zero.  In the 'terminated' position (i.e. the string is exhausted),\nthis value is the size of the string.\n\nIn short, it's a 0-based index into the string.\n\n  s = StringScanner.new(\"abcädeföghi\")\n  s.charpos           # -> 0\n  s.scan_until(/ä/)   # -> \"abcä\"\n  s.pos               # -> 5\n  s.charpos           # -> 4",
  "pointer": "Returns the byte position of the scan pointer.  In the 'reset' position, this\nvalue is zero.  In the 'terminated' position (i.e. the string is exhausted),\nthis value is the bytesize of the string.\n\nIn short, it's a 0-based index into bytes of the string.\n\n  s = StringScanner.new('test string')\n  s.pos               # -> 0\n  s.scan_until /str/  # -> \"test str\"\n  s.pos               # -> 8\n  s.terminate         # -> #<StringScanner fin>\n  s.pos               # -> 11",
  "pointer=": "Set the byte position of the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.pos = 7            # -> 7\n  s.rest               # -> \"ring\"",
  "scan": "Tries to match with +pattern+ at the current position. If there's a match,\nthe scanner advances the \"scan pointer\" and returns the matched string.\nOtherwise, the scanner returns +nil+.\n\n  s = StringScanner.new('test string')\n  p s.scan(/\\w+/)   # -> \"test\"\n  p s.scan(/\\w+/)   # -> nil\n  p s.scan(/\\s+/)   # -> \" \"\n  p s.scan(/\\w+/)   # -> \"string\"\n  p s.scan(/./)     # -> nil",
  "skip": "Attempts to skip over the given +pattern+ beginning with the scan pointer.\nIf it matches, the scan pointer is advanced to the end of the match, and the\nlength of the match is returned.  Otherwise, +nil+ is returned.\n\nIt's similar to #scan, but without returning the matched string.\n\n  s = StringScanner.new('test string')\n  p s.skip(/\\w+/)   # -> 4\n  p s.skip(/\\w+/)   # -> nil\n  p s.skip(/\\s+/)   # -> 1\n  p s.skip(/\\w+/)   # -> 6\n  p s.skip(/./)     # -> nil",
  "match?": "Tests whether the given +pattern+ is matched from the current scan pointer.\nReturns the length of the match, or +nil+.  The scan pointer is not advanced.\n\n  s = StringScanner.new('test string')\n  p s.match?(/\\w+/)   # -> 4\n  p s.match?(/\\w+/)   # -> 4\n  p s.match?(/\\s+/)   # -> nil",
  "check": "This returns the value that #scan would return, without advancing the scan\npointer.  The match register is affected, though.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.check /Fri/               # -> \"Fri\"\n  s.pos                       # -> 0\n  s.matched                   # -> \"Fri\"\n  s.check /12/                # -> nil\n  s.matched                   # -> nil\n\nMnemonic: it \"checks\" to see whether a #scan will return a value.",
  "scan_full": "Tests whether the given +pattern+ is matched from the current scan pointer.\nAdvances the scan pointer if +advance_pointer_p+ is true.\nReturns the matched string if +return_string_p+ is true.\nThe match register is affected.\n\n\"full\" means \"#scan with full parameters\".",
  "scan_until": "Scans the string _until_ the +pattern+ is matched.  Returns the substring up\nto and including the end of the match, advancing the scan pointer to that\nlocation. If there is no match, +nil+ is returned.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.scan_until(/1/)        # -> \"Fri Dec 1\"\n  s.pre_match              # -> \"Fri Dec \"\n  s.scan_until(/XYZ/)      # -> nil",
  "skip_until": "Advances the scan pointer until +pattern+ is matched and consumed.  Returns\nthe number of bytes advanced, or +nil+ if no match was found.\n\nLook ahead to match +pattern+, and advance the scan pointer to the _end_\nof the match.  Return the number of characters advanced, or +nil+ if the\nmatch was unsuccessful.\n\nIt's similar to #scan_until, but without returning the intervening string.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.skip_until /12/           # -> 10\n  s                           #",
  "exist?": "Looks _ahead_ to see if the +pattern+ exists _anywhere_ in the string,\nwithout advancing the scan pointer.  This predicates whether a #scan_until\nwill return a value.\n\n  s = StringScanner.new('test string')\n  s.exist? /s/            # -> 3\n  s.scan /test/           # -> \"test\"\n  s.exist? /s/            # -> 2\n  s.exist? /e/            # -> nil",
  "check_until": "This returns the value that #scan_until would return, without advancing the\nscan pointer.  The match register is affected, though.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.check_until /12/          # -> \"Fri Dec 12\"\n  s.pos                       # -> 0\n  s.matched                   # -> 12\n\nMnemonic: it \"checks\" to see whether a #scan_until will return a value.",
  "search_full": "Scans the string _until_ the +pattern+ is matched.\nAdvances the scan pointer if +advance_pointer_p+, otherwise not.\nReturns the matched string if +return_string_p+ is true, otherwise\nreturns the number of bytes advanced.\nThis method does affect the match register.",
  "getch": "Scans one character and returns it.\nThis method is multibyte character sensitive.\n\n  s = StringScanner.new(\"ab\")\n  s.getch           # => \"a\"\n  s.getch           # => \"b\"\n  s.getch           # => nil\n\n  $KCODE = 'EUC'\n  s = StringScanner.new(\"\\244\\242\")\n  s.getch           # => \"\\244\\242\"   # Japanese hira-kana \"A\" in EUC-JP\n  s.getch           # => nil",
  "get_byte": "Scans one byte and returns it.\nThis method is not multibyte character sensitive.\nSee also: #getch.\n\n  s = StringScanner.new('ab')\n  s.get_byte         # => \"a\"\n  s.get_byte         # => \"b\"\n  s.get_byte         # => nil\n\n  $KCODE = 'EUC'\n  s = StringScanner.new(\"\\244\\242\")\n  s.get_byte         # => \"\\244\"\n  s.get_byte         # => \"\\242\"\n  s.get_byte         # => nil",
  "getbyte": "Equivalent to #get_byte.\nThis method is obsolete; use #get_byte instead.",
  "peek": "Extracts a string corresponding to <tt>string[pos,len]</tt>, without\nadvancing the scan pointer.\n\n  s = StringScanner.new('test string')\n  s.peek(7)          # => \"test st\"\n  s.peek(7)          # => \"test st\"",
  "peep": "Equivalent to #peek.\nThis method is obsolete; use #peek instead.",
  "unscan": "Set the scan pointer to the previous position.  Only one previous position is\nremembered, and it changes with each scanning operation.\n\n  s = StringScanner.new('test string')\n  s.scan(/\\w+/)        # => \"test\"\n  s.unscan\n  s.scan(/../)         # => \"te\"\n  s.scan(/\\d/)         # => nil\n  s.unscan             # ScanError: unscan failed: previous match record not exist",
  "beginning_of_line?": "Returns +true+ iff the scan pointer is at the beginning of the line.\n\n  s = StringScanner.new(\"test\\ntest\\n\")\n  s.bol?           # => true\n  s.scan(/te/)\n  s.bol?           # => false\n  s.scan(/st\\n/)\n  s.bol?           # => true\n  s.terminate\n  s.bol?           # => true",
  "eos?": "Returns +true+ if the scan pointer is at the end of the string.\n\n  s = StringScanner.new('test string')\n  p s.eos?          # => false\n  s.scan(/test/)\n  p s.eos?          # => false\n  s.terminate\n  p s.eos?          # => true",
  "empty?": "Equivalent to #eos?.\nThis method is obsolete, use #eos? instead.",
  "rest?": "Returns true iff there is more data in the string.  See #eos?.\nThis method is obsolete; use #eos? instead.\n\n  s = StringScanner.new('test string')\n  s.eos?              # These two\n  s.rest?             # are opposites.",
  "matched?": "Returns +true+ iff the last match was successful.\n\n  s = StringScanner.new('test string')\n  s.match?(/\\w+/)     # => 4\n  s.matched?          # => true\n  s.match?(/\\d+/)     # => nil\n  s.matched?          # => false",
  "matched": "Returns the last matched string.\n\n  s = StringScanner.new('test string')\n  s.match?(/\\w+/)     # -> 4\n  s.matched           # -> \"test\"",
  "matched_size": "Returns the size of the most recent match (see #matched), or +nil+ if there\nwas no recent match.\n\n  s = StringScanner.new('test string')\n  s.check /\\w+/           # -> \"test\"\n  s.matched_size          # -> 4\n  s.check /\\d+/           # -> nil\n  s.matched_size          # -> nil",
  "[]": "Return the n-th subgroup in the most recent match.\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.scan(/(\\w+) (\\w+) (\\d+) /)       # -> \"Fri Dec 12 \"\n  s[0]                               # -> \"Fri Dec 12 \"\n  s[1]                               # -> \"Fri\"\n  s[2]                               # -> \"Dec\"\n  s[3]                               # -> \"12\"\n  s.post_match                       # -> \"1975 14:39\"\n  s.pre_match                        # -> \"\"\n\n  s.reset\n  s.scan(/(?<wday>\\w+) (?<month>\\w+) (?<day>\\d+) /)       # -> \"Fri Dec 12 \"\n  s[0]                               # -> \"Fri Dec 12 \"\n  s[1]                               # -> \"Fri\"\n  s[2]                               # -> \"Dec\"\n  s[3]                               # -> \"12\"\n  s[:wday]                           # -> \"Fri\"\n  s[:month]                          # -> \"Dec\"\n  s[:day]                            # -> \"12\"\n  s.post_match                       # -> \"1975 14:39\"\n  s.pre_match                        # -> \"\"",
  "pre_match": "Return the <i><b>pre</b>-match</i> (in the regular expression sense) of the last scan.\n\n  s = StringScanner.new('test string')\n  s.scan(/\\w+/)           # -> \"test\"\n  s.scan(/\\s+/)           # -> \" \"\n  s.pre_match             # -> \"test\"\n  s.post_match            # -> \"string\"",
  "post_match": "Return the <i><b>post</b>-match</i> (in the regular expression sense) of the last scan.\n\n  s = StringScanner.new('test string')\n  s.scan(/\\w+/)           # -> \"test\"\n  s.scan(/\\s+/)           # -> \" \"\n  s.pre_match             # -> \"test\"\n  s.post_match            # -> \"string\"",
  "rest": "Returns the \"rest\" of the string (i.e. everything after the scan pointer).\nIf there is no more data (eos? = true), it returns <tt>\"\"</tt>.",
  "rest_size": "<tt>s.rest_size</tt> is equivalent to <tt>s.rest.size</tt>.",
  "restsize": "<tt>s.restsize</tt> is equivalent to <tt>s.rest_size</tt>.\nThis method is obsolete; use #rest_size instead.",
  "inspect": "Returns a string that represents the StringScanner object, showing:\n- the current position\n- the size of the string\n- the characters surrounding the scan pointer\n\n  s = StringScanner.new(\"Fri Dec 12 1975 14:39\")\n  s.inspect            # -> '#<StringScanner 0/21 @ \"Fri D...\">'\n  s.scan_until /12/    # -> \"Fri Dec 12\"\n  s.inspect            # -> '#<StringScanner 10/21 \"...ec 12\" @ \" 1975...\">'"
}