{
  "[]": "Element Reference---Retrieves the <i>value</i> object corresponding\nto the <i>key</i> object. If not found, returns the default value (see\n<code>Hash::new</code> for details).\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h[\"a\"]   #=> 100\n   h[\"c\"]   #=> nil",
  "try_convert": "Try to convert <i>obj</i> into a hash, using to_hash method.\nReturns converted hash or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Hash.try_convert({1=>2})   # => {1=>2}\n   Hash.try_convert(\"1=>2\")   # => nil",
  "initialize": "Returns a new, empty hash. If this hash is subsequently accessed by\na key that doesn't correspond to a hash entry, the value returned\ndepends on the style of <code>new</code> used to create the hash. In\nthe first form, the access returns <code>nil</code>. If\n<i>obj</i> is specified, this single object will be used for\nall <em>default values</em>. If a block is specified, it will be\ncalled with the hash object and the key, and should return the\ndefault value. It is the block's responsibility to store the value\nin the hash if required.\n\n   h = Hash.new(\"Go Fish\")\n   h[\"a\"] = 100\n   h[\"b\"] = 200\n   h[\"a\"]           #=> 100\n   h[\"c\"]           #=> \"Go Fish\"\n   # The following alters the single default object\n   h[\"c\"].upcase!   #=> \"GO FISH\"\n   h[\"d\"]           #=> \"GO FISH\"\n   h.keys           #=> [\"a\", \"b\"]\n\n   # While this creates a new default object each time\n   h = Hash.new { |hash, key| hash[key] = \"Go Fish: #{key}\" }\n   h[\"c\"]           #=> \"Go Fish: c\"\n   h[\"c\"].upcase!   #=> \"GO FISH: C\"\n   h[\"d\"]           #=> \"Go Fish: d\"\n   h.keys           #=> [\"c\", \"d\"]",
  "initialize_copy": ":nodoc:",
  "rehash": "Rebuilds the hash based on the current hash values for each key. If\nvalues of key objects have changed since they were inserted, this\nmethod will reindex <i>hsh</i>. If <code>Hash#rehash</code> is\ncalled while an iterator is traversing the hash, an\n<code>RuntimeError</code> will be raised in the iterator.\n\n   a = [ \"a\", \"b\" ]\n   c = [ \"c\", \"d\" ]\n   h = { a => 100, c => 300 }\n   h[a]       #=> 100\n   a[0] = \"z\"\n   h[a]       #=> nil\n   h.rehash   #=> {[\"z\", \"b\"]=>100, [\"c\", \"d\"]=>300}\n   h[a]       #=> 100",
  "to_hash": "Returns +self+.",
  "to_h": "Returns +self+. If called on a subclass of Hash, converts\nthe receiver to a Hash object.",
  "to_a": "Converts <i>hsh</i> to a nested array of <code>[</code> <i>key,\nvalue</i> <code>]</code> arrays.\n\n   h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n   h.to_a   #=> [[\"c\", 300], [\"a\", 100], [\"d\", 400]]",
  "inspect": "Return the contents of this hash as a string.\n\n    h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n    h.to_s   #=> \"{\\\"c\\\"=>300, \\\"a\\\"=>100, \\\"d\\\"=>400}\"",
  "to_s": "Return the contents of this hash as a string.\n\n    h = { \"c\" => 300, \"a\" => 100, \"d\" => 400, \"c\" => 300  }\n    h.to_s   #=> \"{\\\"c\\\"=>300, \\\"a\\\"=>100, \\\"d\\\"=>400}\"",
  "==": "Equality---Two hashes are equal if they each contain the same number\nof keys and if each key-value pair is equal to (according to\n<code>Object#==</code>) the corresponding elements in the other\nhash.\n\n   h1 = { \"a\" => 1, \"c\" => 2 }\n   h2 = { 7 => 35, \"c\" => 2, \"a\" => 1 }\n   h3 = { \"a\" => 1, \"c\" => 2, 7 => 35 }\n   h4 = { \"a\" => 1, \"d\" => 2, \"f\" => 35 }\n   h1 == h2   #=> false\n   h2 == h3   #=> true\n   h3 == h4   #=> false",
  "hash": "Compute a hash-code for this hash. Two hashes with the same content\nwill have the same hash code (and will compare using <code>eql?</code>).",
  "eql?": "Returns <code>true</code> if <i>hash</i> and <i>other</i> are\nboth hashes with the same content.",
  "fetch": "Returns a value from the hash for the given key. If the key can't be\nfound, there are several options: With no other arguments, it will\nraise an <code>KeyError</code> exception; if <i>default</i> is\ngiven, then that will be returned; if the optional code block is\nspecified, then that will be run and its result returned.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"a\")                            #=> 100\n   h.fetch(\"z\", \"go fish\")                 #=> \"go fish\"\n   h.fetch(\"z\") { |el| \"go fish, #{el}\"}   #=> \"go fish, z\"\n\nThe following example shows that an exception is raised if the key\nis not found and a default value is not supplied.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.fetch(\"z\")\n\n<em>produces:</em>\n\n   prog.rb:2:in `fetch': key not found (KeyError)\n    from prog.rb:2",
  "[]=": "== Element Assignment\n\nAssociates the value given by +value+ with the key given by +key+.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h[\"a\"] = 9\n   h[\"c\"] = 4\n   h   #=> {\"a\"=>9, \"b\"=>200, \"c\"=>4}\n   h.store(\"d\", 42) #=> {\"a\"=>9, \"b\"=>200, \"c\"=>4, \"d\"=>42}\n\n+key+ should not have its value changed while it is in use as a key (an\n<tt>unfrozen String</tt> passed as a key will be duplicated and frozen).\n\n   a = \"a\"\n   b = \"b\".freeze\n   h = { a => 100, b => 200 }\n   h.key(100).equal? a #=> false\n   h.key(200).equal? b #=> true",
  "store": "== Element Assignment\n\nAssociates the value given by +value+ with the key given by +key+.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h[\"a\"] = 9\n   h[\"c\"] = 4\n   h   #=> {\"a\"=>9, \"b\"=>200, \"c\"=>4}\n   h.store(\"d\", 42) #=> {\"a\"=>9, \"b\"=>200, \"c\"=>4, \"d\"=>42}\n\n+key+ should not have its value changed while it is in use as a key (an\n<tt>unfrozen String</tt> passed as a key will be duplicated and frozen).\n\n   a = \"a\"\n   b = \"b\".freeze\n   h = { a => 100, b => 200 }\n   h.key(100).equal? a #=> false\n   h.key(200).equal? b #=> true",
  "default": "Returns the default value, the value that would be returned by\n<i>hsh</i>[<i>key</i>] if <i>key</i> did not exist in <i>hsh</i>.\nSee also <code>Hash::new</code> and <code>Hash#default=</code>.\n\n   h = Hash.new                            #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> nil\n\n   h = Hash.new(\"cat\")                     #=> {}\n   h.default                               #=> \"cat\"\n   h.default(2)                            #=> \"cat\"\n\n   h = Hash.new {|h,k| h[k] = k.to_i*10}   #=> {}\n   h.default                               #=> nil\n   h.default(2)                            #=> 20",
  "default=": "Sets the default value, the value returned for a key that does not\nexist in the hash. It is not possible to set the default to a\n<code>Proc</code> that will be executed on each key lookup.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.default = \"Go fish\"\n   h[\"a\"]     #=> 100\n   h[\"z\"]     #=> \"Go fish\"\n   # This doesn't do what you might hope...\n   h.default = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> #<Proc:0x401b3948@-:6>\n   h[\"cat\"]   #=> #<Proc:0x401b3948@-:6>",
  "default_proc": "If <code>Hash::new</code> was invoked with a block, return that\nblock, otherwise return <code>nil</code>.\n\n   h = Hash.new {|h,k| h[k] = k*k }   #=> {}\n   p = h.default_proc                 #=> #<Proc:0x401b3d08@-:1>\n   a = []                             #=> []\n   p.call(a, 2)\n   a                                  #=> [nil, nil, 4]",
  "default_proc=": "Sets the default proc to be executed on each failed key lookup.\n\n   h.default_proc = proc do |hash, key|\n     hash[key] = key + key\n   end\n   h[2]       #=> 4\n   h[\"cat\"]   #=> \"catcat\"",
  "key": "Returns the key of an occurrence of a given value. If the value is\nnot found, returns <code>nil</code>.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300, \"d\" => 300 }\n   h.key(200)   #=> \"b\"\n   h.key(300)   #=> \"c\"\n   h.key(999)   #=> nil",
  "index": ":nodoc:",
  "size": "Returns the number of key-value pairs in the hash.\n\n   h = { \"d\" => 100, \"a\" => 200, \"v\" => 300, \"e\" => 400 }\n   h.length        #=> 4\n   h.delete(\"a\")   #=> 200\n   h.length        #=> 3",
  "length": "Returns the number of key-value pairs in the hash.\n\n   h = { \"d\" => 100, \"a\" => 200, \"v\" => 300, \"e\" => 400 }\n   h.length        #=> 4\n   h.delete(\"a\")   #=> 200\n   h.length        #=> 3",
  "empty?": "Returns <code>true</code> if <i>hsh</i> contains no key-value pairs.\n\n   {}.empty?   #=> true",
  "each_value": "Calls <i>block</i> once for each key in <i>hsh</i>, passing the\nvalue as a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each_value {|value| puts value }\n\n<em>produces:</em>\n\n   100\n   200",
  "each_key": "Calls <i>block</i> once for each key in <i>hsh</i>, passing the key\nas a parameter.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each_key {|key| puts key }\n\n<em>produces:</em>\n\n   a\n   b",
  "each_pair": "Calls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each {|key, value| puts \"#{key} is #{value}\" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200",
  "each": "Calls <i>block</i> once for each key in <i>hsh</i>, passing the key-value\npair as parameters.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.each {|key, value| puts \"#{key} is #{value}\" }\n\n<em>produces:</em>\n\n   a is 100\n   b is 200",
  "keys": "Returns a new array populated with the keys from this hash. See also\n<code>Hash#values</code>.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300, \"d\" => 400 }\n   h.keys   #=> [\"a\", \"b\", \"c\", \"d\"]",
  "values": "Returns a new array populated with the values from <i>hsh</i>. See\nalso <code>Hash#keys</code>.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.values   #=> [100, 200, 300]",
  "values_at": "Return an array containing the values associated with the given keys.\nAlso see <code>Hash.select</code>.\n\n  h = { \"cat\" => \"feline\", \"dog\" => \"canine\", \"cow\" => \"bovine\" }\n  h.values_at(\"cow\", \"cat\")  #=> [\"bovine\", \"feline\"]",
  "shift": "Removes a key-value pair from <i>hsh</i> and returns it as the\ntwo-item array <code>[</code> <i>key, value</i> <code>]</code>, or\nthe hash's default value if the hash is empty.\n\n   h = { 1 => \"a\", 2 => \"b\", 3 => \"c\" }\n   h.shift   #=> [1, \"a\"]\n   h         #=> {2=>\"b\", 3=>\"c\"}",
  "delete": "Deletes the key-value pair and returns the value from <i>hsh</i> whose\nkey is equal to <i>key</i>. If the key is not found, returns the\n<em>default value</em>. If the optional code block is given and the\nkey is not found, pass in the key and return the result of\n<i>block</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.delete(\"a\")                              #=> 100\n   h.delete(\"z\")                              #=> nil\n   h.delete(\"z\") { |el| \"#{el} not found\" }   #=> \"z not found\"",
  "delete_if": "Deletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to <code>true</code>.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.delete_if {|key, value| key >= \"b\" }   #=> {\"a\"=>100}",
  "keep_if": "Deletes every key-value pair from <i>hsh</i> for which <i>block</i>\nevaluates to false.\n\nIf no block is given, an enumerator is returned instead.",
  "select": "Returns a new hash consisting of entries for which the block returns true.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.select {|k,v| k > \"a\"}  #=> {\"b\" => 200, \"c\" => 300}\n   h.select {|k,v| v < 200}  #=> {\"a\" => 100}",
  "select!": "Equivalent to <code>Hash#keep_if</code>, but returns\n<code>nil</code> if no changes were made.",
  "reject": "Returns a new hash consisting of entries for which the block returns false.\n\nIf no block is given, an enumerator is returned instead.\n\n   h = { \"a\" => 100, \"b\" => 200, \"c\" => 300 }\n   h.reject {|k,v| k < \"b\"}  #=> {\"b\" => 200, \"c\" => 300}\n   h.reject {|k,v| v > 100}  #=> {\"a\" => 100}",
  "reject!": "Equivalent to <code>Hash#delete_if</code>, but returns\n<code>nil</code> if no changes were made.",
  "clear": "Removes all key-value pairs from <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }   #=> {\"a\"=>100, \"b\"=>200}\n   h.clear                          #=> {}",
  "invert": "Returns a new hash created by using <i>hsh</i>'s values as keys, and\nthe keys as values.\n\n   h = { \"n\" => 100, \"m\" => 100, \"y\" => 300, \"d\" => 200, \"a\" => 0 }\n   h.invert   #=> {0=>\"a\", 100=>\"m\", 200=>\"d\", 300=>\"y\"}",
  "update": "Adds the contents of _other_hash_ to _hsh_.  If no block is specified,\nentries with duplicate keys are overwritten with the values from\n_other_hash_, otherwise the value of each duplicate key is determined by\ncalling the block with the key, its value in _hsh_ and its value in\n_other_hash_.\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n                   #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}",
  "replace": "Replaces the contents of <i>hsh</i> with the contents of\n<i>other_hash</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.replace({ \"c\" => 300, \"d\" => 400 })   #=> {\"c\"=>300, \"d\"=>400}",
  "merge!": "Adds the contents of _other_hash_ to _hsh_.  If no block is specified,\nentries with duplicate keys are overwritten with the values from\n_other_hash_, otherwise the value of each duplicate key is determined by\ncalling the block with the key, its value in _hsh_ and its value in\n_other_hash_.\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge!(h2) { |key, v1, v2| v1 }\n                   #=> {\"a\"=>100, \"b\"=>200, \"c\"=>300}",
  "merge": "Returns a new hash containing the contents of <i>other_hash</i> and\nthe contents of <i>hsh</i>. If no block is specified, the value for\nentries with duplicate keys will be that of <i>other_hash</i>. Otherwise\nthe value for each duplicate key is determined by calling the block\nwith the key, its value in <i>hsh</i> and its value in <i>other_hash</i>.\n\n   h1 = { \"a\" => 100, \"b\" => 200 }\n   h2 = { \"b\" => 254, \"c\" => 300 }\n   h1.merge(h2)   #=> {\"a\"=>100, \"b\"=>254, \"c\"=>300}\n   h1.merge(h2){|key, oldval, newval| newval - oldval}\n                  #=> {\"a\"=>100, \"b\"=>54,  \"c\"=>300}\n   h1             #=> {\"a\"=>100, \"b\"=>200}",
  "assoc": "Searches through the hash comparing _obj_ with the key using <code>==</code>.\nReturns the key-value pair (two elements array) or +nil+\nif no match is found.  See <code>Array#assoc</code>.\n\n   h = {\"colors\"  => [\"red\", \"blue\", \"green\"],\n        \"letters\" => [\"a\", \"b\", \"c\" ]}\n   h.assoc(\"letters\")  #=> [\"letters\", [\"a\", \"b\", \"c\"]]\n   h.assoc(\"foo\")      #=> nil",
  "rassoc": "Searches through the hash comparing _obj_ with the value using <code>==</code>.\nReturns the first key-value pair (two-element array) that matches. See\nalso <code>Array#rassoc</code>.\n\n   a = {1=> \"one\", 2 => \"two\", 3 => \"three\", \"ii\" => \"two\"}\n   a.rassoc(\"two\")    #=> [2, \"two\"]\n   a.rassoc(\"four\")   #=> nil",
  "flatten": "Returns a new array that is a one-dimensional flattening of this\nhash. That is, for every key or value that is an array, extract\nits elements into the new array.  Unlike Array#flatten, this\nmethod does not flatten recursively by default.  The optional\n<i>level</i> argument determines the level of recursion to flatten.\n\n   a =  {1=> \"one\", 2 => [2,\"two\"], 3 => \"three\"}\n   a.flatten    # => [1, \"one\", 2, [2, \"two\"], 3, \"three\"]\n   a.flatten(2) # => [1, \"one\", 2, 2, \"two\", 3, \"three\"]",
  "include?": "Returns <code>true</code> if the given key is present in <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false",
  "member?": "Returns <code>true</code> if the given key is present in <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false",
  "has_key?": "Returns <code>true</code> if the given key is present in <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false",
  "has_value?": "Returns <code>true</code> if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false",
  "key?": "Returns <code>true</code> if the given key is present in <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_key?(\"a\")   #=> true\n   h.has_key?(\"z\")   #=> false",
  "value?": "Returns <code>true</code> if the given value is present for some key\nin <i>hsh</i>.\n\n   h = { \"a\" => 100, \"b\" => 200 }\n   h.has_value?(100)   #=> true\n   h.has_value?(999)   #=> false",
  "compare_by_identity": "Makes <i>hsh</i> compare its keys by their identity, i.e. it\nwill consider exact same objects as same keys.\n\n   h1 = { \"a\" => 100, \"b\" => 200, :c => \"c\" }\n   h1[\"a\"]        #=> 100\n   h1.compare_by_identity\n   h1.compare_by_identity? #=> true\n   h1[\"a\"]        #=> nil  # different objects.\n   h1[:c]         #=> \"c\"  # same symbols are all same.",
  "compare_by_identity?": "Returns <code>true</code> if <i>hsh</i> will compare its keys by\ntheir identity.  Also see <code>Hash#compare_by_identity</code>."
}