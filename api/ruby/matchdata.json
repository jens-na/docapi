{
  "initialize_copy": ":nodoc:",
  "regexp": "Returns the regexp.\n\n    m = /a.*b/.match(\"abc\")\n    m.regexp #=> /a.*b/",
  "names": "Returns a list of names of captures as an array of strings.\nIt is same as mtch.regexp.names.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.match(\"hoge\").names\n    #=> [\"foo\", \"bar\", \"baz\"]\n\n    m = /(?<x>.)(?<y>.)?/.match(\"a\") #=> #<MatchData \"a\" x:\"a\" y:nil>\n    m.names                          #=> [\"x\", \"y\"]",
  "size": "Returns the number of elements in the match array.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.length   #=> 5\n   m.size     #=> 5",
  "length": "Returns the number of elements in the match array.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.length   #=> 5\n   m.size     #=> 5",
  "offset": "Returns a two-element array containing the beginning and ending offsets of\nthe <em>n</em>th match.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.offset(0)      #=> [1, 7]\n   m.offset(4)      #=> [6, 7]\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.offset(:foo) #=> [0, 1]\n   p m.offset(:bar) #=> [2, 3]",
  "begin": "Returns the offset of the start of the <em>n</em>th element of the match\narray in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.begin(0)       #=> 1\n   m.begin(2)       #=> 2\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.begin(:foo)  #=> 0\n   p m.begin(:bar)  #=> 2",
  "end": "Returns the offset of the character immediately following the end of the\n<em>n</em>th element of the match array in the string.\n<em>n</em> can be a string or symbol to reference a named capture.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.end(0)         #=> 7\n   m.end(2)         #=> 3\n\n   m = /(?<foo>.)(.)(?<bar>.)/.match(\"hoge\")\n   p m.end(:foo)    #=> 1\n   p m.end(:bar)    #=> 3",
  "to_a": "Returns the array of matches.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.to_a   #=> [\"HX1138\", \"H\", \"X\", \"113\", \"8\"]\n\nBecause <code>to_a</code> is called when expanding\n<code>*</code><em>variable</em>, there's a useful assignment\nshortcut for extracting matched fields. This is slightly slower than\naccessing the fields directly (as an intermediate array is\ngenerated).\n\n   all,f1,f2,f3 = *(/(.)(.)(\\d+)(\\d)/.match(\"THX1138.\"))\n   all   #=> \"HX1138\"\n   f1    #=> \"H\"\n   f2    #=> \"X\"\n   f3    #=> \"113\"",
  "[]": "Match Reference -- <code>MatchData</code> acts as an array, and may be\naccessed using the normal array indexing techniques.  <code>mtch[0]</code>\nis equivalent to the special variable <code>$&</code>, and returns the\nentire matched string.  <code>mtch[1]</code>, <code>mtch[2]</code>, and so\non return the values of the matched backreferences (portions of the\npattern between parentheses).\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m          #=> #<MatchData \"HX1138\" 1:\"H\" 2:\"X\" 3:\"113\" 4:\"8\">\n   m[0]       #=> \"HX1138\"\n   m[1, 2]    #=> [\"H\", \"X\"]\n   m[1..3]    #=> [\"H\", \"X\", \"113\"]\n   m[-3, 2]   #=> [\"X\", \"113\"]\n\n   m = /(?<foo>a+)b/.match(\"ccaaab\")\n   m          #=> #<MatchData \"aaab\" foo:\"aaa\">\n   m[\"foo\"]   #=> \"aaa\"\n   m[:foo]    #=> \"aaa\"",
  "captures": "Returns the array of captures; equivalent to <code>mtch.to_a[1..-1]</code>.\n\n   f1,f2,f3,f4 = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\").captures\n   f1    #=> \"H\"\n   f2    #=> \"X\"\n   f3    #=> \"113\"\n   f4    #=> \"8\"",
  "values_at": "Uses each <i>index</i> to access the matching values, returning an array of\nthe corresponding matches.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138: The Movie\")\n   m.to_a               #=> [\"HX1138\", \"H\", \"X\", \"113\", \"8\"]\n   m.values_at(0, 2, -2)   #=> [\"HX1138\", \"X\", \"113\"]",
  "pre_match": "Returns the portion of the original string before the current match.\nEquivalent to the special variable <code>$`</code>.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.pre_match   #=> \"T\"",
  "post_match": "Returns the portion of the original string after the current match.\nEquivalent to the special variable <code>$'</code>.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138: The Movie\")\n   m.post_match   #=> \": The Movie\"",
  "to_s": "Returns the entire matched string.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.to_s   #=> \"HX1138\"",
  "inspect": "Returns a printable version of <i>mtch</i>.\n\n    puts /.$/.match(\"foo\").inspect\n    #=> #<MatchData \"o\">\n\n    puts /(.)(.)(.)/.match(\"foo\").inspect\n    #=> #<MatchData \"foo\" 1:\"f\" 2:\"o\" 3:\"o\">\n\n    puts /(.)(.)?(.)/.match(\"fo\").inspect\n    #=> #<MatchData \"fo\" 1:\"f\" 2:nil 3:\"o\">\n\n    puts /(?<foo>.)(?<bar>.)(?<baz>.)/.match(\"hoge\").inspect\n    #=> #<MatchData \"hog\" foo:\"h\" bar:\"o\" baz:\"g\">",
  "string": "Returns a frozen copy of the string passed in to <code>match</code>.\n\n   m = /(.)(.)(\\d+)(\\d)/.match(\"THX1138.\")\n   m.string   #=> \"THX1138.\"",
  "hash": "Produce a hash based on the target string, regexp and matched\npositions of this matchdata.",
  "eql?": "Equality---Two matchdata are equal if their target strings,\n patterns, and matched positions are identical.",
  "==": "Equality---Two matchdata are equal if their target strings,\n patterns, and matched positions are identical."
}