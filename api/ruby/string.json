{
  "try_convert": "Try to convert <i>obj</i> into a String, using to_str method.\nReturns converted string or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   String.try_convert(\"str\")     #=> \"str\"\n   String.try_convert(/re/)      #=> nil",
  "initialize": "Returns a new string object containing a copy of <i>str</i>.",
  "initialize_copy": "Replaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = \"hello\"         #=> \"hello\"\n   s.replace \"world\"   #=> \"world\"",
  "<=>": "Comparison---Returns -1, 0, +1 or nil depending on whether +string+ is less\nthan, equal to, or greater than +other_string+.\n\n+nil+ is returned if the two values are incomparable.\n\nIf the strings are of different lengths, and the strings are equal when\ncompared up to the shortest length, then the longer string is considered\ngreater than the shorter one.\n\n<code><=></code> is the basis for the methods <code><</code>,\n<code><=</code>, <code>></code>, <code>>=</code>, and\n<code>between?</code>, included from module Comparable. The method\nString#== does not use Comparable#==.\n\n   \"abcdef\" <=> \"abcde\"     #=> 1\n   \"abcdef\" <=> \"abcdef\"    #=> 0\n   \"abcdef\" <=> \"abcdefg\"   #=> -1\n   \"abcdef\" <=> \"ABCDEF\"    #=> 1",
  "==": "=== Equality\n\nReturns whether +str+ == +obj+, similar to Object#==.\n\nIf +obj+ is not an instance of String but responds to +to_str+, then the\ntwo strings are compared using case equality Object#===.\n\nOtherwise, returns similarly to String#eql?, comparing length and content.",
  "===": "=== Equality\n\nReturns whether +str+ == +obj+, similar to Object#==.\n\nIf +obj+ is not an instance of String but responds to +to_str+, then the\ntwo strings are compared using case equality Object#===.\n\nOtherwise, returns similarly to String#eql?, comparing length and content.",
  "eql?": "Two strings are equal if they have the same length and content.",
  "hash": "Return a hash based on the string's length and content.",
  "casecmp": "Case-insensitive version of <code>String#<=></code>.\n\n   \"abcdef\".casecmp(\"abcde\")     #=> 1\n   \"aBcDeF\".casecmp(\"abcdef\")    #=> 0\n   \"abcdef\".casecmp(\"abcdefg\")   #=> -1\n   \"abcdef\".casecmp(\"ABCDEF\")    #=> 0",
  "+": "Concatenation---Returns a new <code>String</code> containing\n<i>other_str</i> concatenated to <i>str</i>.\n\n   \"Hello from \" + self.to_s   #=> \"Hello from main\"",
  "*": "Copy --- Returns a new String containing +integer+ copies of the receiver.\n+integer+ must be greater than or equal to 0.\n\n   \"Ho! \" * 3   #=> \"Ho! Ho! Ho! \"\n   \"Ho! \" * 0   #=> \"\"",
  "%": "Format---Uses <i>str</i> as a format specification, and returns the result\nof applying it to <i>arg</i>. If the format specification contains more than\none substitution, then <i>arg</i> must be an <code>Array</code> or <code>Hash</code>\ncontaining the values to be substituted. See <code>Kernel::sprintf</code> for\ndetails of the format string.\n\n   \"%05d\" % 123                              #=> \"00123\"\n   \"%-5s: %08x\" % [ \"ID\", self.object_id ]   #=> \"ID   : 200e14d6\"\n   \"foo = %{foo}\" % { :foo => 'bar' }        #=> \"foo = bar\"",
  "[]": "Element Reference --- If passed a single +index+, returns a substring of\none character at that index. If passed a +start+ index and a +length+,\nreturns a substring containing +length+ characters starting at the\n+index+. If passed a +range+, its beginning and end are interpreted as\noffsets delimiting the substring to be returned.\n\nIn these three cases, if an index is negative, it is counted from the end\nof the string.  For the +start+ and +range+ cases the starting index\nis just before a character and an index matching the string's size.\nAdditionally, an empty string is returned when the starting index for a\ncharacter range is at the end of the string.\n\nReturns +nil+ if the initial index falls outside the string or the length\nis negative.\n\nIf a +Regexp+ is supplied, the matching portion of the string is\nreturned.  If a +capture+ follows the regular expression, which may be a\ncapture group index or name, follows the regular expression that component\nof the MatchData is returned instead.\n\nIf a +match_str+ is given, that string is returned if it occurs in\nthe string.\n\nReturns +nil+ if the regular expression does not match or the match string\ncannot be found.\n\n   a = \"hello there\"\n\n   a[1]                   #=> \"e\"\n   a[2, 3]                #=> \"llo\"\n   a[2..3]                #=> \"ll\"\n\n   a[-3, 2]               #=> \"er\"\n   a[7..-2]               #=> \"her\"\n   a[-4..-2]              #=> \"her\"\n   a[-2..-4]              #=> \"\"\n\n   a[11, 0]               #=> \"\"\n   a[11]                  #=> nil\n   a[12, 0]               #=> nil\n   a[12..-1]              #=> nil\n\n   a[/[aeiou](.)\\1/]      #=> \"ell\"\n   a[/[aeiou](.)\\1/, 0]   #=> \"ell\"\n   a[/[aeiou](.)\\1/, 1]   #=> \"l\"\n   a[/[aeiou](.)\\1/, 2]   #=> nil\n\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"non_vowel\"] #=> \"l\"\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"vowel\"]     #=> \"e\"\n\n   a[\"lo\"]                #=> \"lo\"\n   a[\"bye\"]               #=> nil",
  "[]=": "Element Assignment---Replaces some or all of the content of <i>str</i>. The\nportion of the string affected is determined using the same criteria as\n<code>String#[]</code>. If the replacement string is not the same length as\nthe text it is replacing, the string will be adjusted accordingly. If the\nregular expression or string is used as the index doesn't match a position\nin the string, <code>IndexError</code> is raised. If the regular expression\nform is used, the optional second <code>Fixnum</code> allows you to specify\nwhich portion of the match to replace (effectively using the\n<code>MatchData</code> indexing rules. The forms that take a\n<code>Fixnum</code> will raise an <code>IndexError</code> if the value is\nout of range; the <code>Range</code> form will raise a\n<code>RangeError</code>, and the <code>Regexp</code> and <code>String</code>\nwill raise an <code>IndexError</code> on negative match.",
  "insert": "Inserts <i>other_str</i> before the character at the given\n<i>index</i>, modifying <i>str</i>. Negative indices count from the\nend of the string, and insert <em>after</em> the given character.\nThe intent is insert <i>aString</i> so that it starts at the given\n<i>index</i>.\n\n   \"abcd\".insert(0, 'X')    #=> \"Xabcd\"\n   \"abcd\".insert(3, 'X')    #=> \"abcXd\"\n   \"abcd\".insert(4, 'X')    #=> \"abcdX\"\n   \"abcd\".insert(-3, 'X')   #=> \"abXcd\"\n   \"abcd\".insert(-1, 'X')   #=> \"abcdX\"",
  "length": "Returns the character length of <i>str</i>.",
  "size": "Returns the character length of <i>str</i>.",
  "bytesize": "Returns the length of +str+ in bytes.\n\n  \"\\x80\\u3042\".bytesize  #=> 4\n  \"hello\".bytesize       #=> 5",
  "empty?": "Returns <code>true</code> if <i>str</i> has a length of zero.\n\n   \"hello\".empty?   #=> false\n   \" \".empty?       #=> false\n   \"\".empty?        #=> true",
  "=~": "Match---If <i>obj</i> is a <code>Regexp</code>, use it as a pattern to match\nagainst <i>str</i>,and returns the position the match starts, or\n<code>nil</code> if there is no match. Otherwise, invokes\n<i>obj.=~</i>, passing <i>str</i> as an argument. The default\n<code>=~</code> in <code>Object</code> returns <code>nil</code>.\n\nNote: <code>str =~ regexp</code> is not the same as\n<code>regexp =~ str</code>. Strings captured from named capture groups\nare assigned to local variables only in the second case.\n\n   \"cat o' 9 tails\" =~ /\\d/   #=> 7\n   \"cat o' 9 tails\" =~ 9      #=> nil",
  "match": "Converts <i>pattern</i> to a <code>Regexp</code> (if it isn't already one),\nthen invokes its <code>match</code> method on <i>str</i>.  If the second\nparameter is present, it specifies the position in the string to begin the\nsearch.\n\n   'hello'.match('(.)\\1')      #=> #<MatchData \"ll\" 1:\"l\">\n   'hello'.match('(.)\\1')[0]   #=> \"ll\"\n   'hello'.match(/(.)\\1/)[0]   #=> \"ll\"\n   'hello'.match('xx')         #=> nil\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   str.match(pat) {|m| ...}\n\ninstead of\n\n   if m = str.match(pat)\n     ...\n   end\n\nThe return value is a value from block execution in this case.",
  "succ": "Returns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   \"abcd\".succ        #=> \"abce\"\n   \"THX1138\".succ     #=> \"THX1139\"\n   \"<<koala>>\".succ   #=> \"<<koalb>>\"\n   \"1999zzz\".succ     #=> \"2000aaa\"\n   \"ZZZ9999\".succ     #=> \"AAAA0000\"\n   \"***\".succ         #=> \"**+\"",
  "succ!": "Equivalent to <code>String#succ</code>, but modifies the receiver in\nplace.",
  "next": "Returns the successor to <i>str</i>. The successor is calculated by\nincrementing characters starting from the rightmost alphanumeric (or\nthe rightmost character if there are no alphanumerics) in the\nstring. Incrementing a digit always results in another digit, and\nincrementing a letter results in another letter of the same case.\nIncrementing nonalphanumerics uses the underlying character set's\ncollating sequence.\n\nIf the increment generates a ``carry,'' the character to the left of\nit is incremented. This process repeats until there is no carry,\nadding an additional character if necessary.\n\n   \"abcd\".succ        #=> \"abce\"\n   \"THX1138\".succ     #=> \"THX1139\"\n   \"<<koala>>\".succ   #=> \"<<koalb>>\"\n   \"1999zzz\".succ     #=> \"2000aaa\"\n   \"ZZZ9999\".succ     #=> \"AAAA0000\"\n   \"***\".succ         #=> \"**+\"",
  "next!": "Equivalent to <code>String#succ</code>, but modifies the receiver in\nplace.",
  "upto": "Iterates through successive values, starting at <i>str</i> and\nending at <i>other_str</i> inclusive, passing each value in turn to\nthe block. The <code>String#succ</code> method is used to generate\neach value.  If optional second argument exclusive is omitted or is false,\nthe last value will be included; otherwise it will be excluded.\n\nIf no block is given, an enumerator is returned instead.\n\n   \"a8\".upto(\"b6\") {|s| print s, ' ' }\n   for s in \"a8\"..\"b6\"\n     print s, ' '\n   end\n\n<em>produces:</em>\n\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n   a8 a9 b0 b1 b2 b3 b4 b5 b6\n\nIf <i>str</i> and <i>other_str</i> contains only ascii numeric characters,\nboth are recognized as decimal numbers. In addition, the width of\nstring (e.g. leading zeros) is handled appropriately.\n\n   \"9\".upto(\"11\").to_a   #=> [\"9\", \"10\", \"11\"]\n   \"25\".upto(\"5\").to_a   #=> []\n   \"07\".upto(\"11\").to_a  #=> [\"07\", \"08\", \"09\", \"10\", \"11\"]",
  "index": "Returns the index of the first occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns <code>nil</code> if not\nfound. If the second parameter is present, it specifies the position in the\nstring to begin the search.\n\n   \"hello\".index('e')             #=> 1\n   \"hello\".index('lo')            #=> 3\n   \"hello\".index('a')             #=> nil\n   \"hello\".index(?e)              #=> 1\n   \"hello\".index(/[aeiou]/, -3)   #=> 4",
  "rindex": "Returns the index of the last occurrence of the given <i>substring</i> or\npattern (<i>regexp</i>) in <i>str</i>. Returns <code>nil</code> if not\nfound. If the second parameter is present, it specifies the position in the\nstring to end the search---characters beyond this point will not be\nconsidered.\n\n   \"hello\".rindex('e')             #=> 1\n   \"hello\".rindex('l')             #=> 3\n   \"hello\".rindex('a')             #=> nil\n   \"hello\".rindex(?e)              #=> 1\n   \"hello\".rindex(/[aeiou]/, -2)   #=> 1",
  "replace": "Replaces the contents and taintedness of <i>str</i> with the corresponding\nvalues in <i>other_str</i>.\n\n   s = \"hello\"         #=> \"hello\"\n   s.replace \"world\"   #=> \"world\"",
  "clear": "Makes string empty.\n\n   a = \"abcde\"\n   a.clear    #=> \"\"",
  "chr": "Returns a one-character string at the beginning of the string.\n\n   a = \"abcde\"\n   a.chr    #=> \"a\"",
  "getbyte": "returns the <i>index</i>th byte as an integer.",
  "setbyte": "modifies the <i>index</i>th byte as <i>integer</i>.",
  "byteslice": "Byte Reference---If passed a single <code>Fixnum</code>, returns a\nsubstring of one byte at that position. If passed two <code>Fixnum</code>\nobjects, returns a substring starting at the offset given by the first, and\na length given by the second. If given a <code>Range</code>, a substring containing\nbytes at offsets given by the range is returned. In all three cases, if\nan offset is negative, it is counted from the end of <i>str</i>. Returns\n<code>nil</code> if the initial offset falls outside the string, the length\nis negative, or the beginning of the range is greater than the end.\nThe encoding of the resulted string keeps original encoding.\n\n   \"hello\".byteslice(1)     #=> \"e\"\n   \"hello\".byteslice(-1)    #=> \"o\"\n   \"hello\".byteslice(1, 2)  #=> \"el\"\n   \"\\x80\\u3042\".byteslice(1, 3) #=> \"\\u3042\"\n   \"\\x03\\u3042\\xff\".byteslice(1..3) #=> \"\\u3042\"",
  "scrub": "If the string is invalid byte sequence then replace invalid bytes with given replacement\ncharacter, else returns self.\nIf block is given, replace invalid bytes with returned value of the block.\n\n   \"abc\\u3042\\x81\".scrub #=> \"abc\\u3042\\uFFFD\"\n   \"abc\\u3042\\x81\".scrub(\"*\") #=> \"abc\\u3042*\"\n   \"abc\\u3042\\xE3\\x80\".scrub{|bytes| '<'+bytes.unpack('H*')[0]+'>' } #=> \"abc\\u3042<e380>\"",
  "scrub!": "If the string is invalid byte sequence then replace invalid bytes with given replacement\ncharacter, else returns self.\nIf block is given, replace invalid bytes with returned value of the block.\n\n   \"abc\\u3042\\x81\".scrub! #=> \"abc\\u3042\\uFFFD\"\n   \"abc\\u3042\\x81\".scrub!(\"*\") #=> \"abc\\u3042*\"\n   \"abc\\u3042\\xE3\\x80\".scrub!{|bytes| '<'+bytes.unpack('H*')[0]+'>' } #=> \"abc\\u3042<e380>\"",
  "freeze": "Prevents further modifications to <i>obj</i>. A\n<code>RuntimeError</code> will be raised if modification is attempted.\nThere is no way to unfreeze a frozen object. See also\n<code>Object#frozen?</code>.\n\nThis method returns self.\n\n   a = [ \"a\", \"b\", \"c\" ]\n   a.freeze\n   a << \"z\"\n\n<em>produces:</em>\n\n   prog.rb:3:in `<<': can't modify frozen array (RuntimeError)\n   \tfrom prog.rb:3",
  "to_i": "Returns the result of interpreting leading characters in <i>str</i> as an\ninteger base <i>base</i> (between 2 and 36). Extraneous characters past the\nend of a valid number are ignored. If there is not a valid number at the\nstart of <i>str</i>, <code>0</code> is returned. This method never raises an\nexception when <i>base</i> is valid.\n\n   \"12345\".to_i             #=> 12345\n   \"99 red balloons\".to_i   #=> 99\n   \"0a\".to_i                #=> 0\n   \"0a\".to_i(16)            #=> 10\n   \"hello\".to_i             #=> 0\n   \"1100101\".to_i(2)        #=> 101\n   \"1100101\".to_i(8)        #=> 294977\n   \"1100101\".to_i(10)       #=> 1100101\n   \"1100101\".to_i(16)       #=> 17826049",
  "to_f": "Returns the result of interpreting leading characters in <i>str</i> as a\nfloating point number. Extraneous characters past the end of a valid number\nare ignored. If there is not a valid number at the start of <i>str</i>,\n<code>0.0</code> is returned. This method never raises an exception.\n\n   \"123.45e1\".to_f        #=> 1234.5\n   \"45.67 degrees\".to_f   #=> 45.67\n   \"thx1138\".to_f         #=> 0.0",
  "to_s": "Returns the receiver.",
  "to_str": "Returns the receiver.",
  "inspect": "Returns a printable version of _str_, surrounded by quote marks,\nwith special characters escaped.\n\n   str = \"hello\"\n   str[3] = \"\\b\"\n   str.inspect       #=> \"\\\"hel\\\\bo\\\"\"",
  "dump": "Produces a version of +str+ with all non-printing characters replaced by\n<code>\\nnn</code> notation and all special characters escaped.\n\n  \"hello \\n ''\".dump  #=> \"\\\"hello \\\\n ''\\\"",
  "upcase": "Returns a copy of <i>str</i> with all lowercase letters replaced with their\nuppercase counterparts. The operation is locale insensitive---only\ncharacters ``a'' to ``z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   \"hEllO\".upcase   #=> \"HELLO\"",
  "downcase": "Returns a copy of <i>str</i> with all uppercase letters replaced with their\nlowercase counterparts. The operation is locale insensitive---only\ncharacters ``A'' to ``Z'' are affected.\nNote: case replacement is effective only in ASCII region.\n\n   \"hEllO\".downcase   #=> \"hello\"",
  "capitalize": "Returns a copy of <i>str</i> with the first character converted to uppercase\nand the remainder to lowercase.\nNote: case conversion is effective only in ASCII region.\n\n   \"hello\".capitalize    #=> \"Hello\"\n   \"HELLO\".capitalize    #=> \"Hello\"\n   \"123ABC\".capitalize   #=> \"123abc\"",
  "swapcase": "Returns a copy of <i>str</i> with uppercase alphabetic characters converted\nto lowercase and lowercase characters converted to uppercase.\nNote: case conversion is effective only in ASCII region.\n\n   \"Hello\".swapcase          #=> \"hELLO\"\n   \"cYbEr_PuNk11\".swapcase   #=> \"CyBeR_pUnK11\"",
  "upcase!": "Upcases the contents of <i>str</i>, returning <code>nil</code> if no changes\nwere made.\nNote: case replacement is effective only in ASCII region.",
  "downcase!": "Downcases the contents of <i>str</i>, returning <code>nil</code> if no\nchanges were made.\nNote: case replacement is effective only in ASCII region.",
  "capitalize!": "Modifies <i>str</i> by converting the first character to uppercase and the\nremainder to lowercase. Returns <code>nil</code> if no changes are made.\nNote: case conversion is effective only in ASCII region.\n\n   a = \"hello\"\n   a.capitalize!   #=> \"Hello\"\n   a               #=> \"Hello\"\n   a.capitalize!   #=> nil",
  "swapcase!": "Equivalent to <code>String#swapcase</code>, but modifies the receiver in\nplace, returning <i>str</i>, or <code>nil</code> if no changes were made.\nNote: case conversion is effective only in ASCII region.",
  "hex": "Treats leading characters from <i>str</i> as a string of hexadecimal digits\n(with an optional sign and an optional <code>0x</code>) and returns the\ncorresponding number. Zero is returned on error.\n\n   \"0x0a\".hex     #=> 10\n   \"-1234\".hex    #=> -4660\n   \"0\".hex        #=> 0\n   \"wombat\".hex   #=> 0",
  "oct": "Treats leading characters of <i>str</i> as a string of octal digits (with an\noptional sign) and returns the corresponding number.  Returns 0 if the\nconversion fails.\n\n   \"123\".oct       #=> 83\n   \"-377\".oct      #=> -255\n   \"bad\".oct       #=> 0\n   \"0377bad\".oct   #=> 255",
  "split": "Divides <i>str</i> into substrings based on a delimiter, returning an array\nof these substrings.\n\nIf <i>pattern</i> is a <code>String</code>, then its contents are used as\nthe delimiter when splitting <i>str</i>. If <i>pattern</i> is a single\nspace, <i>str</i> is split on whitespace, with leading whitespace and runs\nof contiguous whitespace characters ignored.\n\nIf <i>pattern</i> is a <code>Regexp</code>, <i>str</i> is divided where the\npattern matches. Whenever the pattern matches a zero-length string,\n<i>str</i> is split into individual characters. If <i>pattern</i> contains\ngroups, the respective matches will be returned in the array as well.\n\nIf <i>pattern</i> is omitted, the value of <code>$;</code> is used.  If\n<code>$;</code> is <code>nil</code> (which is the default), <i>str</i> is\nsplit on whitespace as if ` ' were specified.\n\nIf the <i>limit</i> parameter is omitted, trailing null fields are\nsuppressed. If <i>limit</i> is a positive number, at most that number of\nfields will be returned (if <i>limit</i> is <code>1</code>, the entire\nstring is returned as the only entry in an array). If negative, there is no\nlimit to the number of fields returned, and trailing null fields are not\nsuppressed.\n\nWhen the input +str+ is empty an empty Array is returned as the string is\nconsidered to have no fields to split.\n\n   \" now's  the time\".split        #=> [\"now's\", \"the\", \"time\"]\n   \" now's  the time\".split(' ')   #=> [\"now's\", \"the\", \"time\"]\n   \" now's  the time\".split(/ /)   #=> [\"\", \"now's\", \"\", \"the\", \"time\"]\n   \"1, 2.34,56, 7\".split(%r{,\\s*}) #=> [\"1\", \"2.34\", \"56\", \"7\"]\n   \"hello\".split(//)               #=> [\"h\", \"e\", \"l\", \"l\", \"o\"]\n   \"hello\".split(//, 3)            #=> [\"h\", \"e\", \"llo\"]\n   \"hi mom\".split(%r{\\s*})         #=> [\"h\", \"i\", \"m\", \"o\", \"m\"]\n\n   \"mellow yellow\".split(\"ello\")   #=> [\"m\", \"w y\", \"w\"]\n   \"1,2,,3,4,,\".split(',')         #=> [\"1\", \"2\", \"\", \"3\", \"4\"]\n   \"1,2,,3,4,,\".split(',', 4)      #=> [\"1\", \"2\", \"\", \"3,4,,\"]\n   \"1,2,,3,4,,\".split(',', -4)     #=> [\"1\", \"2\", \"\", \"3\", \"4\", \"\", \"\"]\n\n   \"\".split(',', -1)               #=> []",
  "lines": "Returns an array of lines in <i>str</i> split using the supplied\nrecord separator (<code>$/</code> by default).  This is a\nshorthand for <code>str.each_line(separator).to_a</code>.\n\nIf a block is given, which is a deprecated form, works the same as\n<code>each_line</code>.",
  "bytes": "Returns an array of bytes in <i>str</i>.  This is a shorthand for\n<code>str.each_byte.to_a</code>.\n\nIf a block is given, which is a deprecated form, works the same as\n<code>each_byte</code>.",
  "chars": "Returns an array of characters in <i>str</i>.  This is a shorthand\nfor <code>str.each_char.to_a</code>.\n\nIf a block is given, which is a deprecated form, works the same as\n<code>each_char</code>.",
  "codepoints": "Returns an array of the <code>Integer</code> ordinals of the\ncharacters in <i>str</i>.  This is a shorthand for\n<code>str.each_codepoint.to_a</code>.\n\nIf a block is given, which is a deprecated form, works the same as\n<code>each_codepoint</code>.",
  "reverse": "Returns a new string with the characters from <i>str</i> in reverse order.\n\n   \"stressed\".reverse   #=> \"desserts\"",
  "reverse!": "Reverses <i>str</i> in place.",
  "concat": "Append---Concatenates the given object to <i>str</i>. If the object is a\n<code>Integer</code>, it is considered as a codepoint, and is converted\nto a character before concatenation.\n\n   a = \"hello \"\n   a << \"world\"   #=> \"hello world\"\n   a.concat(33)   #=> \"hello world!\"",
  "<<": "Append---Concatenates the given object to <i>str</i>. If the object is a\n<code>Integer</code>, it is considered as a codepoint, and is converted\nto a character before concatenation.\n\n   a = \"hello \"\n   a << \"world\"   #=> \"hello world\"\n   a.concat(33)   #=> \"hello world!\"",
  "prepend": "Prepend---Prepend the given string to <i>str</i>.\n\n   a = \"world\"\n   a.prepend(\"hello \") #=> \"hello world\"\n   a                   #=> \"hello world\"",
  "crypt": "Applies a one-way cryptographic hash to <i>str</i> by invoking the\nstandard library function <code>crypt(3)</code> with the given\nsalt string.  While the format and the result are system and\nimplementation dependent, using a salt matching the regular\nexpression <code>\\A[a-zA-Z0-9./]{2}</code> should be valid and\nsafe on any platform, in which only the first two characters are\nsignificant.\n\nThis method is for use in system specific scripts, so if you want\na cross-platform hash function consider using Digest or OpenSSL\ninstead.",
  "intern": "Returns the <code>Symbol</code> corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See <code>Symbol#id2name</code>.\n\n   \"Koala\".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n<code>:xxx</code> notation.\n\n   'cat and dog'.to_sym   #=> :\"cat and dog\"",
  "to_sym": "Returns the <code>Symbol</code> corresponding to <i>str</i>, creating the\nsymbol if it did not previously exist. See <code>Symbol#id2name</code>.\n\n   \"Koala\".intern         #=> :Koala\n   s = 'cat'.to_sym       #=> :cat\n   s == :cat              #=> true\n   s = '@cat'.to_sym      #=> :@cat\n   s == :@cat             #=> true\n\nThis can also be used to create symbols that cannot be represented using the\n<code>:xxx</code> notation.\n\n   'cat and dog'.to_sym   #=> :\"cat and dog\"",
  "ord": "Return the <code>Integer</code> ordinal of a one-character string.\n\n   \"a\".ord         #=> 97",
  "include?": "Returns <code>true</code> if <i>str</i> contains the given string or\ncharacter.\n\n   \"hello\".include? \"lo\"   #=> true\n   \"hello\".include? \"ol\"   #=> false\n   \"hello\".include? ?h     #=> true",
  "start_with?": "Returns true if +str+ starts with one of the +prefixes+ given.\n\n  \"hello\".start_with?(\"hell\")               #=> true\n\n  # returns true if one of the prefixes matches.\n  \"hello\".start_with?(\"heaven\", \"hell\")     #=> true\n  \"hello\".start_with?(\"heaven\", \"paradise\") #=> false",
  "end_with?": "Returns true if +str+ ends with one of the +suffixes+ given.",
  "scan": "Both forms iterate through <i>str</i>, matching the pattern (which may be a\n<code>Regexp</code> or a <code>String</code>). For each match, a result is\ngenerated and either added to the result array or passed to the block. If\nthe pattern contains no groups, each individual result consists of the\nmatched string, <code>$&</code>.  If the pattern contains groups, each\nindividual result is itself an array containing one entry per group.\n\n   a = \"cruel world\"\n   a.scan(/\\w+/)        #=> [\"cruel\", \"world\"]\n   a.scan(/.../)        #=> [\"cru\", \"el \", \"wor\"]\n   a.scan(/(...)/)      #=> [[\"cru\"], [\"el \"], [\"wor\"]]\n   a.scan(/(..)(..)/)   #=> [[\"cr\", \"ue\"], [\"l \", \"wo\"]]\n\nAnd the block form:\n\n   a.scan(/\\w+/) {|w| print \"<<#{w}>> \" }\n   print \"\\n\"\n   a.scan(/(.)(.)/) {|x,y| print y, x }\n   print \"\\n\"\n\n<em>produces:</em>\n\n   <<cruel>> <<world>>\n   rceu lowlr",
  "ljust": "If <i>integer</i> is greater than the length of <i>str</i>, returns a new\n<code>String</code> of length <i>integer</i> with <i>str</i> left justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   \"hello\".ljust(4)            #=> \"hello\"\n   \"hello\".ljust(20)           #=> \"hello               \"\n   \"hello\".ljust(20, '1234')   #=> \"hello123412341234123\"",
  "rjust": "If <i>integer</i> is greater than the length of <i>str</i>, returns a new\n<code>String</code> of length <i>integer</i> with <i>str</i> right justified\nand padded with <i>padstr</i>; otherwise, returns <i>str</i>.\n\n   \"hello\".rjust(4)            #=> \"hello\"\n   \"hello\".rjust(20)           #=> \"               hello\"\n   \"hello\".rjust(20, '1234')   #=> \"123412341234123hello\"",
  "center": "Centers +str+ in +width+.  If +width+ is greater than the length of +str+,\nreturns a new String of length +width+ with +str+ centered and padded with\n+padstr+; otherwise, returns +str+.\n\n   \"hello\".center(4)         #=> \"hello\"\n   \"hello\".center(20)        #=> \"       hello        \"\n   \"hello\".center(20, '123') #=> \"1231231hello12312312\"",
  "sub": "Returns a copy of +str+ with the _first_ occurrence of +pattern+\nreplaced by the second argument. The +pattern+ is typically a Regexp; if\ngiven as a String, any regular expression metacharacters it contains will\nbe interpreted literally, e.g. <code>'\\\\\\d'</code> will match a backlash\nfollowed by 'd', instead of a digit.\n\nIf +replacement+ is a String it will be substituted for the matched text.\nIt may contain back-references to the pattern's capture groups of the form\n<code>\"\\\\d\"</code>, where <i>d</i> is a group number, or\n<code>\"\\\\k<n>\"</code>, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within +replacement+ the special match\nvariables, such as <code>&$</code>, will not refer to the current match.\n\nIf the second argument is a Hash, and the matched text is one of its keys,\nthe corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as <code>$1</code>, <code>$2</code>, <code>$`</code>,\n<code>$&</code>, and <code>$'</code> will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\n   \"hello\".sub(/[aeiou]/, '*')                  #=> \"h*llo\"\n   \"hello\".sub(/([aeiou])/, '<\\1>')             #=> \"h<e>llo\"\n   \"hello\".sub(/./) {|s| s.ord.to_s + ' ' }     #=> \"104 ello\"\n   \"hello\".sub(/(?<foo>[aeiou])/, '*\\k<foo>*')  #=> \"h*e*llo\"\n   'Is SHELL your preferred shell?'.sub(/[[:upper:]]{2,}/, ENV)\n    #=> \"Is /bin/bash your preferred shell?\"",
  "gsub": "Returns a copy of <i>str</i> with the <em>all</em> occurrences of\n<i>pattern</i> substituted for the second argument. The <i>pattern</i> is\ntypically a <code>Regexp</code>; if given as a <code>String</code>, any\nregular expression metacharacters it contains will be interpreted\nliterally, e.g. <code>'\\\\\\d'</code> will match a backlash followed by 'd',\ninstead of a digit.\n\nIf <i>replacement</i> is a <code>String</code> it will be substituted for\nthe matched text. It may contain back-references to the pattern's capture\ngroups of the form <code>\\\\\\d</code>, where <i>d</i> is a group number, or\n<code>\\\\\\k<n></code>, where <i>n</i> is a group name. If it is a\ndouble-quoted string, both back-references must be preceded by an\nadditional backslash. However, within <i>replacement</i> the special match\nvariables, such as <code>$&</code>, will not refer to the current match.\n\nIf the second argument is a <code>Hash</code>, and the matched text is one\nof its keys, the corresponding value is the replacement string.\n\nIn the block form, the current match string is passed in as a parameter,\nand variables such as <code>$1</code>, <code>$2</code>, <code>$`</code>,\n<code>$&</code>, and <code>$'</code> will be set appropriately. The value\nreturned by the block will be substituted for the match on each call.\n\nThe result inherits any tainting in the original string or any supplied\nreplacement string.\n\nWhen neither a block nor a second argument is supplied, an\n<code>Enumerator</code> is returned.\n\n   \"hello\".gsub(/[aeiou]/, '*')                  #=> \"h*ll*\"\n   \"hello\".gsub(/([aeiou])/, '<\\1>')             #=> \"h<e>ll<o>\"\n   \"hello\".gsub(/./) {|s| s.ord.to_s + ' '}      #=> \"104 101 108 108 111 \"\n   \"hello\".gsub(/(?<foo>[aeiou])/, '{\\k<foo>}')  #=> \"h{e}ll{o}\"\n   'hello'.gsub(/[eo]/, 'e' => 3, 'o' => '*')    #=> \"h3ll*\"",
  "chop": "Returns a new <code>String</code> with the last character removed.  If the\nstring ends with <code>\\r\\n</code>, both characters are removed. Applying\n<code>chop</code> to an empty string returns an empty\nstring. <code>String#chomp</code> is often a safer alternative, as it leaves\nthe string unchanged if it doesn't end in a record separator.\n\n   \"string\\r\\n\".chop   #=> \"string\"\n   \"string\\n\\r\".chop   #=> \"string\\n\"\n   \"string\\n\".chop     #=> \"string\"\n   \"string\".chop       #=> \"strin\"\n   \"x\".chop.chop       #=> \"\"",
  "chomp": "Returns a new <code>String</code> with the given record separator removed\nfrom the end of <i>str</i> (if present). If <code>$/</code> has not been\nchanged from the default Ruby record separator, then <code>chomp</code> also\nremoves carriage return characters (that is it will remove <code>\\n</code>,\n<code>\\r</code>, and <code>\\r\\n</code>).\n\n   \"hello\".chomp            #=> \"hello\"\n   \"hello\\n\".chomp          #=> \"hello\"\n   \"hello\\r\\n\".chomp        #=> \"hello\"\n   \"hello\\n\\r\".chomp        #=> \"hello\\n\"\n   \"hello\\r\".chomp          #=> \"hello\"\n   \"hello \\n there\".chomp   #=> \"hello \\n there\"\n   \"hello\".chomp(\"llo\")     #=> \"he\"",
  "strip": "Returns a copy of <i>str</i> with leading and trailing whitespace removed.\n\n   \"    hello    \".strip   #=> \"hello\"\n   \"\\tgoodbye\\r\\n\".strip   #=> \"goodbye\"",
  "lstrip": "Returns a copy of <i>str</i> with leading whitespace removed. See also\n<code>String#rstrip</code> and <code>String#strip</code>.\n\n   \"  hello  \".lstrip   #=> \"hello  \"\n   \"hello\".lstrip       #=> \"hello\"",
  "rstrip": "Returns a copy of <i>str</i> with trailing whitespace removed. See also\n<code>String#lstrip</code> and <code>String#strip</code>.\n\n   \"  hello  \".rstrip   #=> \"  hello\"\n   \"hello\".rstrip       #=> \"hello\"",
  "sub!": "Performs the same substitution as String#sub in-place.\n\nReturns +str+ if a substitution was performed or +nil+ if no substitution\nwas performed.",
  "gsub!": "Performs the substitutions of <code>String#gsub</code> in place, returning\n<i>str</i>, or <code>nil</code> if no substitutions were performed.\nIf no block and no <i>replacement</i> is given, an enumerator is returned instead.",
  "chop!": "Processes <i>str</i> as for <code>String#chop</code>, returning <i>str</i>,\nor <code>nil</code> if <i>str</i> is the empty string.  See also\n<code>String#chomp!</code>.",
  "chomp!": "Modifies <i>str</i> in place as described for <code>String#chomp</code>,\nreturning <i>str</i>, or <code>nil</code> if no modifications were made.",
  "strip!": "Removes leading and trailing whitespace from <i>str</i>. Returns\n<code>nil</code> if <i>str</i> was not altered.",
  "lstrip!": "Removes leading whitespace from <i>str</i>, returning <code>nil</code> if no\nchange was made. See also <code>String#rstrip!</code> and\n<code>String#strip!</code>.\n\n   \"  hello  \".lstrip   #=> \"hello  \"\n   \"hello\".lstrip!      #=> nil",
  "rstrip!": "Removes trailing whitespace from <i>str</i>, returning <code>nil</code> if\nno change was made. See also <code>String#lstrip!</code> and\n<code>String#strip!</code>.\n\n   \"  hello  \".rstrip   #=> \"  hello\"\n   \"hello\".rstrip!      #=> nil",
  "tr": "Returns a copy of +str+ with the characters in +from_str+ replaced by the\ncorresponding characters in +to_str+.  If +to_str+ is shorter than\n+from_str+, it is padded with its last character in order to maintain the\ncorrespondence.\n\n   \"hello\".tr('el', 'ip')      #=> \"hippo\"\n   \"hello\".tr('aeiou', '*')    #=> \"h*ll*\"\n   \"hello\".tr('aeiou', 'AA*')  #=> \"hAll*\"\n\nBoth strings may use the <code>c1-c2</code> notation to denote ranges of\ncharacters, and +from_str+ may start with a <code>^</code>, which denotes\nall characters except those listed.\n\n   \"hello\".tr('a-y', 'b-z')    #=> \"ifmmp\"\n   \"hello\".tr('^aeiou', '*')   #=> \"*e**o\"\n\nThe backslash character <code>\\</code> can be used to escape\n<code>^</code> or <code>-</code> and is otherwise ignored unless it\nappears at the end of a range or the end of the +from_str+ or +to_str+:\n\n   \"hello^world\".tr(\"\\\\^aeiou\", \"*\") #=> \"h*ll**w*rld\"\n   \"hello-world\".tr(\"a\\\\-eo\", \"*\")   #=> \"h*ll**w*rld\"\n\n   \"hello\\r\\nworld\".tr(\"\\r\", \"\")   #=> \"hello\\nworld\"\n   \"hello\\r\\nworld\".tr(\"\\\\r\", \"\")  #=> \"hello\\r\\nwold\"\n   \"hello\\r\\nworld\".tr(\"\\\\\\r\", \"\") #=> \"hello\\nworld\"\n\n   \"X['\\\\b']\".tr(\"X\\\\\", \"\")   #=> \"['b']\"\n   \"X['\\\\b']\".tr(\"X-\\\\]\", \"\") #=> \"'b'\"",
  "tr_s": "Processes a copy of <i>str</i> as described under <code>String#tr</code>,\nthen removes duplicate characters in regions that were affected by the\ntranslation.\n\n   \"hello\".tr_s('l', 'r')     #=> \"hero\"\n   \"hello\".tr_s('el', '*')    #=> \"h*o\"\n   \"hello\".tr_s('el', 'hx')   #=> \"hhxo\"",
  "delete": "Returns a copy of <i>str</i> with all characters in the intersection of its\narguments deleted. Uses the same rules for building the set of characters as\n<code>String#count</code>.\n\n   \"hello\".delete \"l\",\"lo\"        #=> \"heo\"\n   \"hello\".delete \"lo\"            #=> \"he\"\n   \"hello\".delete \"aeiou\", \"^e\"   #=> \"hell\"\n   \"hello\".delete \"ej-m\"          #=> \"ho\"",
  "squeeze": "Builds a set of characters from the <i>other_str</i> parameter(s) using the\nprocedure described for <code>String#count</code>. Returns a new string\nwhere runs of the same character that occur in this set are replaced by a\nsingle character. If no arguments are given, all runs of identical\ncharacters are replaced by a single character.\n\n   \"yellow moon\".squeeze                  #=> \"yelow mon\"\n   \"  now   is  the\".squeeze(\" \")         #=> \" now is the\"\n   \"putters shoot balls\".squeeze(\"m-z\")   #=> \"puters shot balls\"",
  "count": "Each +other_str+ parameter defines a set of characters to count.  The\nintersection of these sets defines the characters to count in +str+.  Any\n+other_str+ that starts with a caret <code>^</code> is negated.  The\nsequence <code>c1-c2</code> means all characters between c1 and c2.  The\nbackslash character <code>\\</code> can be used to escape <code>^</code> or\n<code>-</code> and is otherwise ignored unless it appears at the end of a\nsequence or the end of a +other_str+.\n\n   a = \"hello world\"\n   a.count \"lo\"                   #=> 5\n   a.count \"lo\", \"o\"              #=> 2\n   a.count \"hello\", \"^l\"          #=> 4\n   a.count \"ej-m\"                 #=> 4\n\n   \"hello^world\".count \"\\\\^aeiou\" #=> 4\n   \"hello-world\".count \"a\\\\-eo\"   #=> 4\n\n   c = \"hello world\\\\r\\\\n\"\n   c.count \"\\\\\"                   #=> 2\n   c.count \"\\\\A\"                  #=> 0\n   c.count \"X-\\\\w\"                #=> 3",
  "tr!": "Translates <i>str</i> in place, using the same rules as\n<code>String#tr</code>. Returns <i>str</i>, or <code>nil</code> if no\nchanges were made.",
  "tr_s!": "Performs <code>String#tr_s</code> processing on <i>str</i> in place,\nreturning <i>str</i>, or <code>nil</code> if no changes were made.",
  "delete!": "Performs a <code>delete</code> operation in place, returning <i>str</i>, or\n<code>nil</code> if <i>str</i> was not modified.",
  "squeeze!": "Squeezes <i>str</i> in place, returning either <i>str</i>, or\n<code>nil</code> if no changes were made.",
  "each_line": "Splits <i>str</i> using the supplied parameter as the record\nseparator (<code>$/</code> by default), passing each substring in\nturn to the supplied block.  If a zero-length record separator is\nsupplied, the string is split into paragraphs delimited by\nmultiple successive newlines.\n\nIf no block is given, an enumerator is returned instead.\n\n   print \"Example one\\n\"\n   \"hello\\nworld\".each_line {|s| p s}\n   print \"Example two\\n\"\n   \"hello\\nworld\".each_line('l') {|s| p s}\n   print \"Example three\\n\"\n   \"hello\\n\\n\\nworld\".each_line('') {|s| p s}\n\n<em>produces:</em>\n\n   Example one\n   \"hello\\n\"\n   \"world\"\n   Example two\n   \"hel\"\n   \"l\"\n   \"o\\nworl\"\n   \"d\"\n   Example three\n   \"hello\\n\\n\\n\"\n   \"world\"",
  "each_byte": "Passes each byte in <i>str</i> to the given block, or returns an\nenumerator if no block is given.\n\n   \"hello\".each_byte {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111",
  "each_char": "Passes each character in <i>str</i> to the given block, or returns\nan enumerator if no block is given.\n\n   \"hello\".each_char {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   h e l l o",
  "each_codepoint": "Passes the <code>Integer</code> ordinal of each character in <i>str</i>,\nalso known as a <i>codepoint</i> when applied to Unicode strings to the\ngiven block.\n\nIf no block is given, an enumerator is returned instead.\n\n   \"hello\\u0639\".each_codepoint {|c| print c, ' ' }\n\n<em>produces:</em>\n\n   104 101 108 108 111 1593",
  "sum": "Returns a basic <em>n</em>-bit checksum of the characters in <i>str</i>,\nwhere <em>n</em> is the optional <code>Fixnum</code> parameter, defaulting\nto 16. The result is simply the sum of the binary value of each character in\n<i>str</i> modulo <code>2**n - 1</code>. This is not a particularly good\nchecksum.",
  "slice": "Element Reference --- If passed a single +index+, returns a substring of\none character at that index. If passed a +start+ index and a +length+,\nreturns a substring containing +length+ characters starting at the\n+index+. If passed a +range+, its beginning and end are interpreted as\noffsets delimiting the substring to be returned.\n\nIn these three cases, if an index is negative, it is counted from the end\nof the string.  For the +start+ and +range+ cases the starting index\nis just before a character and an index matching the string's size.\nAdditionally, an empty string is returned when the starting index for a\ncharacter range is at the end of the string.\n\nReturns +nil+ if the initial index falls outside the string or the length\nis negative.\n\nIf a +Regexp+ is supplied, the matching portion of the string is\nreturned.  If a +capture+ follows the regular expression, which may be a\ncapture group index or name, follows the regular expression that component\nof the MatchData is returned instead.\n\nIf a +match_str+ is given, that string is returned if it occurs in\nthe string.\n\nReturns +nil+ if the regular expression does not match or the match string\ncannot be found.\n\n   a = \"hello there\"\n\n   a[1]                   #=> \"e\"\n   a[2, 3]                #=> \"llo\"\n   a[2..3]                #=> \"ll\"\n\n   a[-3, 2]               #=> \"er\"\n   a[7..-2]               #=> \"her\"\n   a[-4..-2]              #=> \"her\"\n   a[-2..-4]              #=> \"\"\n\n   a[11, 0]               #=> \"\"\n   a[11]                  #=> nil\n   a[12, 0]               #=> nil\n   a[12..-1]              #=> nil\n\n   a[/[aeiou](.)\\1/]      #=> \"ell\"\n   a[/[aeiou](.)\\1/, 0]   #=> \"ell\"\n   a[/[aeiou](.)\\1/, 1]   #=> \"l\"\n   a[/[aeiou](.)\\1/, 2]   #=> nil\n\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"non_vowel\"] #=> \"l\"\n   a[/(?<vowel>[aeiou])(?<non_vowel>[^aeiou])/, \"vowel\"]     #=> \"e\"\n\n   a[\"lo\"]                #=> \"lo\"\n   a[\"bye\"]               #=> nil",
  "slice!": "Deletes the specified portion from <i>str</i>, and returns the portion\ndeleted.\n\n   string = \"this is a string\"\n   string.slice!(2)        #=> \"i\"\n   string.slice!(3..6)     #=> \" is \"\n   string.slice!(/s.*t/)   #=> \"sa st\"\n   string.slice!(\"r\")      #=> \"r\"\n   string                  #=> \"thing\"",
  "partition": "Searches <i>sep</i> or pattern (<i>regexp</i>) in the string\nand returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   \"hello\".partition(\"l\")         #=> [\"he\", \"l\", \"lo\"]\n   \"hello\".partition(\"x\")         #=> [\"hello\", \"\", \"\"]\n   \"hello\".partition(/.l/)        #=> [\"h\", \"el\", \"lo\"]",
  "rpartition": "Searches <i>sep</i> or pattern (<i>regexp</i>) in the string from the end\nof the string, and returns the part before it, the match, and the part\nafter it.\nIf it is not found, returns two empty strings and <i>str</i>.\n\n   \"hello\".rpartition(\"l\")         #=> [\"hel\", \"l\", \"o\"]\n   \"hello\".rpartition(\"x\")         #=> [\"\", \"\", \"hello\"]\n   \"hello\".rpartition(/.l/)        #=> [\"he\", \"ll\", \"o\"]",
  "encoding": "",
  "force_encoding": "Changes the encoding to +encoding+ and returns self.",
  "b": "Returns a copied string whose encoding is ASCII-8BIT.",
  "valid_encoding?": "Returns true for a string which encoded correctly.\n\n  \"\\xc2\\xa1\".force_encoding(\"UTF-8\").valid_encoding?  #=> true\n  \"\\xc2\".force_encoding(\"UTF-8\").valid_encoding?      #=> false\n  \"\\x80\".force_encoding(\"UTF-8\").valid_encoding?      #=> false",
  "ascii_only?": "Returns true for a string which has only ASCII characters.\n\n  \"abc\".force_encoding(\"UTF-8\").ascii_only?          #=> true\n  \"abc\\u{6666}\".force_encoding(\"UTF-8\").ascii_only?  #=> false",
  "to_c": "Returns a complex which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\n   '9'.to_c           #=> (9+0i)\n   '2.5'.to_c         #=> (2.5+0i)\n   '2.5/1'.to_c       #=> ((5/2)+0i)\n   '-3/2'.to_c        #=> ((-3/2)+0i)\n   '-i'.to_c          #=> (0-1i)\n   '45i'.to_c         #=> (0+45i)\n   '3-4i'.to_c        #=> (3-4i)\n   '-4e2-4e-2i'.to_c  #=> (-400.0-0.04i)\n   '-0.0-0.0i'.to_c   #=> (-0.0-0.0i)\n   '1/2+3/4i'.to_c    #=> ((1/2)+(3/4)*i)\n   'ruby'.to_c        #=> (0+0i)\n\nSee Kernel.Complex.",
  "to_r": "Returns a rational which denotes the string form.  The parser\nignores leading whitespaces and trailing garbage.  Any digit\nsequences can be separated by an underscore.  Returns zero for null\nor garbage string.\n\nNOTE: '0.3'.to_r isn't the same as 0.3.to_r.  The former is\nequivalent to '3/10'.to_r, but the latter isn't so.\n\n   '  2  '.to_r       #=> (2/1)\n   '300/2'.to_r       #=> (150/1)\n   '-9.2'.to_r        #=> (-46/5)\n   '-9.2e2'.to_r      #=> (-920/1)\n   '1_234_567'.to_r   #=> (1234567/1)\n   '21 june 09'.to_r  #=> (21/1)\n   '21/06/09'.to_r    #=> (7/2)\n   'bwv 1079'.to_r    #=> (0/1)\n\nSee Kernel.Rational.",
  "encode": "The first form returns a copy of +str+ transcoded\nto encoding +encoding+.\nThe second form returns a copy of +str+ transcoded\nfrom src_encoding to dst_encoding.\nThe last form returns a copy of +str+ transcoded to\n<tt>Encoding.default_internal</tt>.\n\nBy default, the first and second form raise\nEncoding::UndefinedConversionError for characters that are\nundefined in the destination encoding, and\nEncoding::InvalidByteSequenceError for invalid byte sequences\nin the source encoding. The last form by default does not raise\nexceptions but uses replacement strings.\n\nThe +options+ Hash gives details for conversion and can have the following\nkeys:\n\n:invalid ::\n  If the value is +:replace+, #encode replaces invalid byte sequences in\n  +str+ with the replacement character.  The default is to raise the\n  Encoding::InvalidByteSequenceError exception\n:undef ::\n  If the value is +:replace+, #encode replaces characters which are\n  undefined in the destination encoding with the replacement character.\n  The default is to raise the Encoding::UndefinedConversionError.\n:replace ::\n  Sets the replacement string to the given value. The default replacement\n  string is \"\\uFFFD\" for Unicode encoding forms, and \"?\" otherwise.\n:fallback ::\n  Sets the replacement string by the given object for undefined\n  character.  The object should be a Hash, a Proc, a Method, or an\n  object which has [] method.\n  Its key is an undefined character encoded in the source encoding\n  of current transcoder. Its value can be any encoding until it\n  can be converted into the destination encoding of the transcoder.\n:xml ::\n  The value must be +:text+ or +:attr+.\n  If the value is +:text+ #encode replaces undefined characters with their\n  (upper-case hexadecimal) numeric character references. '&', '<', and '>'\n  are converted to \"&amp;\", \"&lt;\", and \"&gt;\", respectively.\n  If the value is +:attr+, #encode also quotes the replacement result\n  (using '\"'), and replaces '\"' with \"&quot;\".\n:cr_newline ::\n  Replaces LF (\"\\n\") with CR (\"\\r\") if value is true.\n:crlf_newline ::\n  Replaces LF (\"\\n\") with CRLF (\"\\r\\n\") if value is true.\n:universal_newline ::\n  Replaces CRLF (\"\\r\\n\") and CR (\"\\r\") with LF (\"\\n\") if value is true.",
  "encode!": "The first form transcodes the contents of <i>str</i> from\nstr.encoding to +encoding+.\nThe second form transcodes the contents of <i>str</i> from\nsrc_encoding to dst_encoding.\nThe options Hash gives details for conversion. See String#encode\nfor details.\nReturns the string even if no changes were made.",
  "str2big_poweroftwo": "",
  "str2big_normal": "",
  "str2big_karatsuba": "",
  "str2big_gmp": "",
  "unpack": "Decodes <i>str</i> (which may contain binary data) according to the\nformat string, returning an array of each value extracted. The\nformat string consists of a sequence of single-character directives,\nsummarized in the table at the end of this entry.\nEach directive may be followed\nby a number, indicating the number of times to repeat with this\ndirective. An asterisk (``<code>*</code>'') will use up all\nremaining elements. The directives <code>sSiIlL</code> may each be\nfollowed by an underscore (``<code>_</code>'') or\nexclamation mark (``<code>!</code>'') to use the underlying\nplatform's native size for the specified type; otherwise, it uses a\nplatform-independent consistent size. Spaces are ignored in the\nformat string. See also <code>Array#pack</code>.\n\n   \"abc \\0\\0abc \\0\\0\".unpack('A6Z6')   #=> [\"abc\", \"abc \"]\n   \"abc \\0\\0\".unpack('a3a3')           #=> [\"abc\", \" \\000\\000\"]\n   \"abc \\0abc \\0\".unpack('Z*Z*')       #=> [\"abc \", \"abc \"]\n   \"aa\".unpack('b8B8')                 #=> [\"10000110\", \"01100001\"]\n   \"aaa\".unpack('h2H2c')               #=> [\"16\", \"61\", 97]\n   \"\\xfe\\xff\\xfe\\xff\".unpack('sS')     #=> [-2, 65534]\n   \"now=20is\".unpack('M*')             #=> [\"now is\"]\n   \"whole\".unpack('xax2aX2aX1aX2a')    #=> [\"h\", \"e\", \"l\", \"l\", \"o\"]\n\nThis table summarizes the various formats and the Ruby classes\nreturned by each.\n\n Integer      |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    C         | Integer | 8-bit unsigned (unsigned char)\n    S         | Integer | 16-bit unsigned, native endian (uint16_t)\n    L         | Integer | 32-bit unsigned, native endian (uint32_t)\n    Q         | Integer | 64-bit unsigned, native endian (uint64_t)\n              |         |\n    c         | Integer | 8-bit signed (signed char)\n    s         | Integer | 16-bit signed, native endian (int16_t)\n    l         | Integer | 32-bit signed, native endian (int32_t)\n    q         | Integer | 64-bit signed, native endian (int64_t)\n              |         |\n    S_, S!    | Integer | unsigned short, native endian\n    I, I_, I! | Integer | unsigned int, native endian\n    L_, L!    | Integer | unsigned long, native endian\n    Q_, Q!    | Integer | unsigned long long, native endian (ArgumentError\n              |         | if the platform has no long long type.)\n              |         | (Q_ and Q! is available since Ruby 2.1.)\n              |         |\n    s_, s!    | Integer | signed short, native endian\n    i, i_, i! | Integer | signed int, native endian\n    l_, l!    | Integer | signed long, native endian\n    q_, q!    | Integer | signed long long, native endian (ArgumentError\n              |         | if the platform has no long long type.)\n              |         | (q_ and q! is available since Ruby 2.1.)\n              |         |\n    S> L> Q>  | Integer | same as the directives without \">\" except\n    s> l> q>  |         | big endian\n    S!> I!>   |         | (available since Ruby 1.9.3)\n    L!> Q!>   |         | \"S>\" is same as \"n\"\n    s!> i!>   |         | \"L>\" is same as \"N\"\n    l!> q!>   |         |\n              |         |\n    S< L< Q<  | Integer | same as the directives without \"<\" except\n    s< l< q<  |         | little endian\n    S!< I!<   |         | (available since Ruby 1.9.3)\n    L!< Q!<   |         | \"S<\" is same as \"v\"\n    s!< i!<   |         | \"L<\" is same as \"V\"\n    l!< q!<   |         |\n              |         |\n    n         | Integer | 16-bit unsigned, network (big-endian) byte order\n    N         | Integer | 32-bit unsigned, network (big-endian) byte order\n    v         | Integer | 16-bit unsigned, VAX (little-endian) byte order\n    V         | Integer | 32-bit unsigned, VAX (little-endian) byte order\n              |         |\n    U         | Integer | UTF-8 character\n    w         | Integer | BER-compressed integer (see Array.pack)\n\n Float        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    D, d      | Float   | double-precision, native format\n    F, f      | Float   | single-precision, native format\n    E         | Float   | double-precision, little-endian byte order\n    e         | Float   | single-precision, little-endian byte order\n    G         | Float   | double-precision, network (big-endian) byte order\n    g         | Float   | single-precision, network (big-endian) byte order\n\n String       |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    A         | String  | arbitrary binary string (remove trailing nulls and ASCII spaces)\n    a         | String  | arbitrary binary string\n    Z         | String  | null-terminated string\n    B         | String  | bit string (MSB first)\n    b         | String  | bit string (LSB first)\n    H         | String  | hex string (high nibble first)\n    h         | String  | hex string (low nibble first)\n    u         | String  | UU-encoded string\n    M         | String  | quoted-printable, MIME encoding (see RFC2045)\n    m         | String  | base64 encoded string (RFC 2045) (default)\n              |         | base64 encoded string (RFC 4648) if followed by 0\n    P         | String  | pointer to a structure (fixed-length string)\n    p         | String  | pointer to a null-terminated string\n\n Misc.        |         |\n Directive    | Returns | Meaning\n -----------------------------------------------------------------\n    @         | ---     | skip to the offset given by the length argument\n    X         | ---     | skip backward one byte\n    x         | ---     | skip forward one byte"
}