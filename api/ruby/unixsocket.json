{
  "initialize": "Creates a new UNIX client socket connected to _path_.\n\n  s = UNIXSocket.new(\"/tmp/sock\")\n  s.send \"hello\", 0",
  "path": "Returns the path of the local address of unixsocket.\n\n  s = UNIXServer.new(\"/tmp/sock\")\n  p s.path #=> \"/tmp/sock\"",
  "addr": "Returns the local address as an array which contains\naddress_family and unix_path.\n\nExample\n  serv = UNIXServer.new(\"/tmp/sock\")\n  p serv.addr #=> [\"AF_UNIX\", \"/tmp/sock\"]",
  "peeraddr": "Returns the remote address as an array which contains\naddress_family and unix_path.\n\nExample\n  serv = UNIXServer.new(\"/tmp/sock\")\n  c = UNIXSocket.new(\"/tmp/sock\")\n  p c.peeraddr #=> [\"AF_UNIX\", \"/tmp/sock\"]",
  "recvfrom": "Receives a message via _unixsocket_.\n\n_maxlen_ is the maximum number of bytes to receive.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  s1 = Socket.new(:UNIX, :DGRAM, 0)\n  s1_ai = Addrinfo.unix(\"/tmp/sock1\")\n  s1.bind(s1_ai)\n\n  s2 = Socket.new(:UNIX, :DGRAM, 0)\n  s2_ai = Addrinfo.unix(\"/tmp/sock2\")\n  s2.bind(s2_ai)\n  s3 = UNIXSocket.for_fd(s2.fileno)\n\n  s1.send \"a\", 0, s2_ai\n  p s3.recvfrom(10) #=> [\"a\", [\"AF_UNIX\", \"/tmp/sock1\"]]",
  "send_io": "Sends _io_ as file descriptor passing.\n\n  s1, s2 = UNIXSocket.pair\n\n  s1.send_io STDOUT\n  stdout = s2.recv_io\n\n  p STDOUT.fileno #=> 1\n  p stdout.fileno #=> 6\n\n  stdout.puts \"hello\" # outputs \"hello\\n\" to standard output.",
  "recv_io": "UNIXServer.open(\"/tmp/sock\") {|serv|\n    UNIXSocket.open(\"/tmp/sock\") {|c|\n      s = serv.accept\n\n      c.send_io STDOUT\n      stdout = s.recv_io\n\n      p STDOUT.fileno #=> 1\n      p stdout.fileno #=> 7\n\n      stdout.puts \"hello\" # outputs \"hello\\n\" to standard output.\n    }\n  }",
  "socketpair": "Creates a pair of sockets connected each other.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = UNIXSocket.pair\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  p s2.recv(10) #=> \"ab\"",
  "pair": "Creates a pair of sockets connected each other.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain.\n0 is default protocol for the domain.\n\n  s1, s2 = UNIXSocket.pair\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  p s2.recv(10) #=> \"ab\""
}