{
  "initialize": "Constructs a range using the given +begin+ and +end+. If the +exclude_end+\nparameter is omitted or is <code>false</code>, the +rng+ will include\nthe end object; otherwise, it will be excluded.",
  "initialize_copy": ":nodoc:",
  "==": "Returns <code>true</code> only if +obj+ is a Range, has equivalent\nbegin and end items (by comparing them with <code>==</code>), and has\nthe same #exclude_end? setting as the range.\n\n  (0..2) == (0..2)            #=> true\n  (0..2) == Range.new(0,2)    #=> true\n  (0..2) == (0...2)           #=> false",
  "===": "Returns <code>true</code> if +obj+ is an element of the range,\n<code>false</code> otherwise.  Conveniently, <code>===</code> is the\ncomparison operator used by <code>case</code> statements.\n\n   case 79\n   when 1..50   then   print \"low\\n\"\n   when 51..75  then   print \"medium\\n\"\n   when 76..100 then   print \"high\\n\"\n   end\n\n<em>produces:</em>\n\n   high",
  "eql?": "Returns <code>true</code> only if +obj+ is a Range, has equivalent\nbegin and end items (by comparing them with <code>eql?</code>),\nand has the same #exclude_end? setting as the range.\n\n  (0..2).eql?(0..2)            #=> true\n  (0..2).eql?(Range.new(0,2))  #=> true\n  (0..2).eql?(0...2)           #=> false",
  "hash": "Compute a hash-code for this range. Two ranges with equal\nbegin and end points (using <code>eql?</code>), and the same\n#exclude_end? value will generate the same hash-code.",
  "each": "Iterates over the elements of range, passing each in turn to the\nblock.\n\nThe +each+ method can only be used if the begin object of the range\nsupports the +succ+ method.  A TypeError is raised if the object\ndoes not have +succ+ method defined (like Float).\n\nIf no block is given, an enumerator is returned instead.\n\n   (10..15).each {|n| print n, ' ' }\n   # prints: 10 11 12 13 14 15\n\n   (2.5..5).each {|n| print n, ' ' }\n   # raises: TypeError: can't iterate from Float",
  "step": "Iterates over the range, passing each <code>n</code>th element to the block.\nIf begin and end are numeric, +n+ is added for each iteration.\nOtherwise <code>step</code> invokes <code>succ</code> to iterate through\nrange elements.\n\nIf no block is given, an enumerator is returned instead.\n\n  range = Xs.new(1)..Xs.new(10)\n  range.step(2) {|x| puts x}\n  puts\n  range.step(3) {|x| puts x}\n\n<em>produces:</em>\n\n   1 x\n   3 xxx\n   5 xxxxx\n   7 xxxxxxx\n   9 xxxxxxxxx\n\n   1 x\n   4 xxxx\n   7 xxxxxxx\n  10 xxxxxxxxxx\n\nSee Range for the definition of class Xs.",
  "bsearch": "By using binary search, finds a value in range which meets the given\ncondition in O(log n) where n is the size of the range.\n\nYou can use this method in two use cases: a find-minimum mode and\na find-any mode.  In either case, the elements of the range must be\nmonotone (or sorted) with respect to the block.\n\nIn find-minimum mode (this is a good choice for typical use case),\nthe block must return true or false, and there must be a value x\nso that:\n\n- the block returns false for any value which is less than x, and\n- the block returns true for any value which is greater than or\n  equal to i.\n\nIf x is within the range, this method returns the value x.\nOtherwise, it returns nil.\n\n   ary = [0, 4, 7, 10, 12]\n   (0...ary.size).bsearch {|i| ary[i] >= 4 } #=> 1\n   (0...ary.size).bsearch {|i| ary[i] >= 6 } #=> 2\n   (0...ary.size).bsearch {|i| ary[i] >= 8 } #=> 3\n   (0...ary.size).bsearch {|i| ary[i] >= 100 } #=> nil\n\n   (0.0...Float::INFINITY).bsearch {|x| Math.log(x) >= 0 } #=> 1.0\n\nIn find-any mode (this behaves like libc's bsearch(3)), the block\nmust return a number, and there must be two values x and y (x <= y)\nso that:\n\n- the block returns a positive number for v if v < x,\n- the block returns zero for v if x <= v < y, and\n- the block returns a negative number for v if y <= v.\n\nThis method returns any value which is within the intersection of\nthe given range and x...y (if any).  If there is no value that\nsatisfies the condition, it returns nil.\n\n   ary = [0, 100, 100, 100, 200]\n   (0..4).bsearch {|i| 100 - ary[i] } #=> 1, 2 or 3\n   (0..4).bsearch {|i| 300 - ary[i] } #=> nil\n   (0..4).bsearch {|i|  50 - ary[i] } #=> nil\n\nYou must not mix the two modes at a time; the block must always\nreturn either true/false, or always return a number.  It is\nundefined which value is actually picked up at each iteration.",
  "begin": "Returns the object that defines the beginning of the range.\n\n    (1..10).begin   #=> 1",
  "end": "Returns the object that defines the end of the range.\n\n   (1..10).end    #=> 10\n   (1...10).end   #=> 10",
  "first": "Returns the first object in the range, or an array of the first +n+\nelements.\n\n  (10..20).first     #=> 10\n  (10..20).first(3)  #=> [10, 11, 12]",
  "last": "Returns the last object in the range,\nor an array of the last +n+ elements.\n\nNote that with no arguments +last+ will return the object that defines\nthe end of the range even if #exclude_end? is +true+.\n\n  (10..20).last      #=> 20\n  (10...20).last     #=> 20\n  (10..20).last(3)   #=> [18, 19, 20]\n  (10...20).last(3)  #=> [17, 18, 19]",
  "min": "Returns the minimum value in the range. Returns +nil+ if the begin\nvalue of the range is larger than the end value.\n\nCan be given an optional block to override the default comparison\nmethod <code>a <=> b</code>.\n\n  (10..20).min    #=> 10",
  "max": "Returns the maximum value in the range. Returns +nil+ if the begin\nvalue of the range larger than the end value.\n\nCan be given an optional block to override the default comparison\nmethod <code>a <=> b</code>.\n\n  (10..20).max    #=> 20",
  "size": "Returns the number of elements in the range. Both the begin and the end of\nthe Range must be Numeric, otherwise nil is returned.\n\n  (10..20).size    #=> 11\n  ('a'..'z').size  #=> nil\n  (-Float::INFINITY..Float::INFINITY).size #=> Infinity",
  "to_s": "Convert this range object to a printable form (using #to_s to convert the\nbegin and end objects).",
  "inspect": "Convert this range object to a printable form (using\n<code>inspect</code> to convert the begin and end\nobjects).",
  "exclude_end?": "Returns <code>true</code> if the range excludes its end value.\n\n   (1..5).exclude_end?     #=> false\n   (1...5).exclude_end?    #=> true",
  "member?": "Returns <code>true</code> if +obj+ is an element of\nthe range, <code>false</code> otherwise.  If begin and end are\nnumeric, comparison is done according to the magnitude of the values.\n\n   (\"a\"..\"z\").include?(\"g\")   #=> true\n   (\"a\"..\"z\").include?(\"A\")   #=> false\n   (\"a\"..\"z\").include?(\"cc\")  #=> false",
  "include?": "Returns <code>true</code> if +obj+ is an element of\nthe range, <code>false</code> otherwise.  If begin and end are\nnumeric, comparison is done according to the magnitude of the values.\n\n   (\"a\"..\"z\").include?(\"g\")   #=> true\n   (\"a\"..\"z\").include?(\"A\")   #=> false\n   (\"a\"..\"z\").include?(\"cc\")  #=> false",
  "cover?": "Returns <code>true</code> if +obj+ is between the begin and end of\nthe range.\n\nThis tests <code>begin <= obj <= end</code> when #exclude_end? is +false+\nand <code>begin <= obj < end</code> when #exclude_end? is +true+.\n\n   (\"a\"..\"z\").cover?(\"c\")    #=> true\n   (\"a\"..\"z\").cover?(\"5\")    #=> false\n   (\"a\"..\"z\").cover?(\"cc\")   #=> true"
}