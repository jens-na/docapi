{
  "initialize": "Creates a new SSL socket from +io+ which must be a real ruby object (not an\nIO-like object that responds to read/write).\n\nIf +ctx+ is provided the SSL Sockets initial params will be taken from\nthe context.\n\nThe OpenSSL::Buffering module provides additional IO methods.\n\nThis method will freeze the SSLContext if one is provided;\nhowever, session management is still allowed in the frozen SSLContext.",
  "to_io": "",
  "connect": "Initiates an SSL/TLS handshake with a server.  The handshake may be started\nafter unencrypted data has been sent over the socket.",
  "connect_nonblock": "Initiates the SSL/TLS handshake as a client in non-blocking manner.\n\n  # emulates blocking connect\n  begin\n    ssl.connect_nonblock\n  rescue IO::WaitReadable\n    IO.select([s2])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [s2])\n    retry\n  end",
  "accept": "Waits for a SSL/TLS client to initiate a handshake.  The handshake may be\nstarted after unencrypted data has been sent over the socket.",
  "accept_nonblock": "Initiates the SSL/TLS handshake as a server in non-blocking manner.\n\n  # emulates blocking accept\n  begin\n    ssl.accept_nonblock\n  rescue IO::WaitReadable\n    IO.select([s2])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [s2])\n    retry\n  end",
  "sysread": "Reads +length+ bytes from the SSL connection.  If a pre-allocated +buffer+\nis provided the data will be written into it.",
  "sysread_nonblock": "A non-blocking version of #sysread.  Raises an SSLError if reading would\nblock.  If \"exception: false\" is passed, this method returns a symbol of\n:wait_readable, :wait_writable, or nil, rather than raising an exception.\n\nReads +length+ bytes from the SSL connection.  If a pre-allocated +buffer+\nis provided the data will be written into it.",
  "syswrite": "Writes +string+ to the SSL connection.",
  "syswrite_nonblock": "Writes +string+ to the SSL connection in a non-blocking manner.  Raises an\nSSLError if writing would block.",
  "sysclose": "Shuts down the SSL connection and prepares it for another connection.",
  "cert": "The X509 certificate for this socket endpoint.",
  "peer_cert": "The X509 certificate for this socket's peer.",
  "peer_cert_chain": "The X509 certificate chain for this socket's peer.",
  "ssl_version": "Returns a String representing the SSL/TLS version that was negotiated\nfor the connection, for example \"TLSv1.2\".",
  "cipher": "The cipher being used for the current connection",
  "state": "A description of the current connection state.",
  "pending": "The number of bytes that are immediately available for reading",
  "session_reused?": "Returns true if a reused session was negotiated during the handshake.",
  "session=": "Sets the Session to be used when the connection is established.",
  "verify_result": "Returns the result of the peer certificates verification.  See verify(1)\nfor error values and descriptions.\n\nIf no peer certificate was presented X509_V_OK is returned.",
  "client_ca": "Returns the list of client CAs. Please note that in contrast to\nSSLContext#client_ca= no array of X509::Certificate is returned but\nX509::Name instances of the CA's subject distinguished name.\n\nIn server mode, returns the list set by SSLContext#client_ca=.\nIn client mode, returns the list of client CAs sent from the server.",
  "npn_protocol": "Returns the protocol string that was finally selected by the client\nduring the handshake."
}