{
  "do_not_reverse_lookup": "Gets the do_not_reverse_lookup flag of _basicsocket_.\n\n  TCPSocket.open(\"www.ruby-lang.org\", 80) {|sock|\n    p sock.do_not_reverse_lookup      #=> false\n    p sock.peeraddr                   #=> [\"AF_INET\", 80, \"carbon.ruby-lang.org\", \"221.186.184.68\"]\n    sock.do_not_reverse_lookup = true\n    p sock.peeraddr                   #=> [\"AF_INET\", 80, \"221.186.184.68\", \"221.186.184.68\"]\n  }",
  "do_not_reverse_lookup=": "Sets the do_not_reverse_lookup flag of _basicsocket_.\n\n  BasicSocket.do_not_reverse_lookup = false\n  p TCPSocket.new(\"127.0.0.1\", 80).do_not_reverse_lookup #=> false\n  BasicSocket.do_not_reverse_lookup = true\n  p TCPSocket.new(\"127.0.0.1\", 80).do_not_reverse_lookup #=> true",
  "for_fd": "Returns a socket object which contains the file descriptor, _fd_.\n\n  # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.\n  STDIN_SOCK = Socket.for_fd(STDIN.fileno)\n  p STDIN_SOCK.remote_address",
  "close_read": "Disallows further read using shutdown system call.\n\n  s1, s2 = UNIXSocket.pair\n  s1.close_read\n  s2.puts #=> Broken pipe (Errno::EPIPE)",
  "close_write": "Disallows further write using shutdown system call.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.print \"ping\"\n    s1.close_write\n    p s2.read        #=> \"ping\"\n    s2.print \"pong\"\n    s2.close\n    p s1.read        #=> \"pong\"\n  }",
  "shutdown": "Calls shutdown(2) system call.\n\ns.shutdown(Socket::SHUT_RD) disallows further read.\n\ns.shutdown(Socket::SHUT_WR) disallows further write.\n\ns.shutdown(Socket::SHUT_RDWR) disallows further read and write.\n\n_how_ can be symbol or string:\n- :RD, :SHUT_RD, \"RD\" and \"SHUT_RD\" are accepted as Socket::SHUT_RD.\n- :WR, :SHUT_WR, \"WR\" and \"SHUT_WR\" are accepted as Socket::SHUT_WR.\n- :RDWR, :SHUT_RDWR, \"RDWR\" and \"SHUT_RDWR\" are accepted as Socket::SHUT_RDWR.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.puts \"ping\"\n    s1.shutdown(:WR)\n    p s2.read          #=> \"ping\\n\"\n    s2.puts \"pong\"\n    s2.close\n    p s1.read          #=> \"pong\\n\"\n  }",
  "setsockopt": "Sets a socket option. These are protocol and system specific, see your\nlocal system documentation for details.\n\n=== Parameters\n* +level+ is an integer, usually one of the SOL_ constants such as\n  Socket::SOL_SOCKET, or a protocol level.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optname+ is an integer, usually one of the SO_ constants, such\n  as Socket::SO_REUSEADDR.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optval+ is the value of the option, it is passed to the underlying\n  setsockopt() as a pointer to a certain number of bytes. How this is\n  done depends on the type:\n  - Fixnum: value is assigned to an int, and a pointer to the int is\n    passed, with length of sizeof(int).\n  - true or false: 1 or 0 (respectively) is assigned to an int, and the\n    int is passed as for a Fixnum. Note that +false+ must be passed,\n    not +nil+.\n  - String: the string's data and length is passed to the socket.\n* +socketoption+ is an instance of Socket::Option\n\n=== Examples\n\nSome socket options are integers with boolean values, in this case\n#setsockopt could be called like this:\n  sock.setsockopt(:SOCKET, :REUSEADDR, true)\n  sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)\n  sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))\n\nSome socket options are integers with numeric values, in this case\n#setsockopt could be called like this:\n  sock.setsockopt(:IP, :TTL, 255)\n  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)\n  sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))\n\nOption values may be structs. Passing them can be complex as it involves\nexamining your system headers to determine the correct definition. An\nexample is an +ip_mreq+, which may be defined in your system headers as:\n  struct ip_mreq {\n    struct  in_addr imr_multiaddr;\n    struct  in_addr imr_interface;\n  };\n\nIn this case #setsockopt could be called like this:\n  optval = IPAddr.new(\"224.0.0.251\").hton +\n           IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton\n  sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)",
  "getsockopt": "Gets a socket option. These are protocol and system specific, see your\nlocal system documentation for details. The option is returned as\na Socket::Option object.\n\n=== Parameters\n* +level+ is an integer, usually one of the SOL_ constants such as\n  Socket::SOL_SOCKET, or a protocol level.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n* +optname+ is an integer, usually one of the SO_ constants, such\n  as Socket::SO_REUSEADDR.\n  A string or symbol of the name, possibly without prefix, is also\n  accepted.\n\n=== Examples\n\nSome socket options are integers with boolean values, in this case\n#getsockopt could be called like this:\n\n  reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool\n\n  optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)\n  optval = optval.unpack \"i\"\n  reuseaddr = optval[0] == 0 ? false : true\n\nSome socket options are integers with numeric values, in this case\n#getsockopt could be called like this:\n\n  ipttl = sock.getsockopt(:IP, :TTL).int\n\n  optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)\n  ipttl = optval.unpack(\"i\")[0]\n\nOption values may be structs. Decoding them can be complex as it involves\nexamining your system headers to determine the correct definition. An\nexample is a +struct linger+, which may be defined in your system headers\nas:\n  struct linger {\n    int l_onoff;\n    int l_linger;\n  };\n\nIn this case #getsockopt could be called like this:\n\n  # Socket::Option knows linger structure.\n  onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger\n\n  optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)\n  onoff, linger = optval.unpack \"ii\"\n  onoff = onoff == 0 ? false : true",
  "getsockname": "Returns the local address of the socket as a sockaddr string.\n\n  TCPServer.open(\"127.0.0.1\", 15120) {|serv|\n    p serv.getsockname #=> \"\\x02\\x00;\\x10\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  }\n\nIf Addrinfo object is preferred over the binary string,\nuse BasicSocket#local_address.",
  "getpeername": "Returns the remote address of the socket as a sockaddr string.\n\n  TCPServer.open(\"127.0.0.1\", 1440) {|serv|\n    c = TCPSocket.new(\"127.0.0.1\", 1440)\n    s = serv.accept\n    p s.getpeername #=> \"\\x02\\x00\\x82u\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  }\n\nIf Addrinfo object is preferred over the binary string,\nuse BasicSocket#remote_address.",
  "getpeereid": "Returns the user and group on the peer of the UNIX socket.\nThe result is a two element array which contains the effective uid and the effective gid.\n\n  Socket.unix_server_loop(\"/tmp/sock\") {|s|\n    begin\n      euid, egid = s.getpeereid\n\n      # Check the connected client is myself or not.\n      next if euid != Process.uid\n\n      # do something about my resource.\n\n    ensure\n      s.close\n    end\n  }",
  "local_address": "Returns an Addrinfo object for local address obtained by getsockname.\n\nNote that addrinfo.protocol is filled by 0.\n\n  TCPSocket.open(\"www.ruby-lang.org\", 80) {|s|\n    p s.local_address #=> #<Addrinfo: 192.168.0.129:36873 TCP>\n  }\n\n  TCPServer.open(\"127.0.0.1\", 1512) {|serv|\n    p serv.local_address #=> #<Addrinfo: 127.0.0.1:1512 TCP>\n  }",
  "remote_address": "Returns an Addrinfo object for remote address obtained by getpeername.\n\nNote that addrinfo.protocol is filled by 0.\n\n  TCPSocket.open(\"www.ruby-lang.org\", 80) {|s|\n    p s.remote_address #=> #<Addrinfo: 221.186.184.68:80 TCP>\n  }\n\n  TCPServer.open(\"127.0.0.1\", 1728) {|serv|\n    c = TCPSocket.new(\"127.0.0.1\", 1728)\n    s = serv.accept\n    p s.remote_address #=> #<Addrinfo: 127.0.0.1:36504 TCP>\n  }",
  "send": "send _mesg_ via _basicsocket_.\n\n_mesg_ should be a string.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n_dest_sockaddr_ should be a packed sockaddr string or an addrinfo.\n\n  TCPSocket.open(\"localhost\", 80) {|s|\n    s.send \"GET / HTTP/1.0\\r\\n\\r\\n\", 0\n    p s.read\n  }",
  "recv": "Receives a message.\n\n_maxlen_ is the maximum number of bytes to receive.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  UNIXSocket.pair {|s1, s2|\n    s1.puts \"Hello World\"\n    p s2.recv(4)                     #=> \"Hell\"\n    p s2.recv(4, Socket::MSG_PEEK)   #=> \"o Wo\"\n    p s2.recv(4)                     #=> \"o Wo\"\n    p s2.recv(10)                    #=> \"rld\\n\"\n  }",
  "recv_nonblock": "Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\n_flags_ is zero or more of the +MSG_+ options.\nThe result, _mesg_, is the data received.\n\nWhen recvfrom(2) returns 0, Socket#recv_nonblock returns\nan empty string as data.\nThe meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.\n\n=== Parameters\n* +maxlen+ - the number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n\tserv = TCPServer.new(\"127.0.0.1\", 0)\n\taf, port, host, addr = serv.addr\n\tc = TCPSocket.new(addr, port)\n\ts = serv.accept\n\tc.send \"aaa\", 0\n\tbegin # emulate blocking recv.\n\t  p s.recv_nonblock(10) #=> \"aaa\"\n\trescue IO::WaitReadable\n\t  IO.select([s])\n\t  retry\n\tend\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recv_nonblock_ fails.\n\nBasicSocket#recv_nonblock may raise any error corresponding to recvfrom(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying recv_nonblock.\n\n=== See\n* Socket#recvfrom",
  "sendmsg": "sendmsg sends a message using sendmsg(2) system call in blocking manner.\n\n_mesg_ is a string to send.\n\n_flags_ is bitwise OR of MSG_* constants such as Socket::MSG_OOB.\n\n_dest_sockaddr_ is a destination socket address for connection-less socket.\nIt should be a sockaddr such as a result of Socket.sockaddr_in.\nAn Addrinfo object can be used too.\n\n_controls_ is a list of ancillary data.\nThe element of _controls_ should be Socket::AncillaryData or\n3-elements array.\nThe 3-element array should contains cmsg_level, cmsg_type and data.\n\nThe return value, _numbytes_sent_ is an integer which is the number of bytes sent.\n\nsendmsg can be used to implement send_io as follows:\n\n  # use Socket::AncillaryData.\n  ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)\n  sock.sendmsg(\"a\", 0, nil, ancdata)\n\n  # use 3-element array.\n  ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack(\"i!\")]\n  sock.sendmsg(\"\\0\", 0, nil, ancdata)",
  "sendmsg_nonblock": "sendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking manner.\n\nIt is similar to BasicSocket#sendmsg\nbut the non-blocking flag is set before the system call\nand it doesn't retry the system call.",
  "recvmsg": "recvmsg receives a message using recvmsg(2) system call in blocking manner.\n\n_maxmesglen_ is the maximum length of mesg to receive.\n\n_flags_ is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.\n\n_maxcontrollen_ is the maximum length of controls (ancillary data) to receive.\n\n_opts_ is option hash.\nCurrently :scm_rights=>bool is the only option.\n\n:scm_rights option specifies that application expects SCM_RIGHTS control message.\nIf the value is nil or false, application don't expects SCM_RIGHTS control message.\nIn this case, recvmsg closes the passed file descriptors immediately.\nThis is the default behavior.\n\nIf :scm_rights value is neither nil nor false, application expects SCM_RIGHTS control message.\nIn this case, recvmsg creates IO objects for each file descriptors for\nSocket::AncillaryData#unix_rights method.\n\nThe return value is 4-elements array.\n\n_mesg_ is a string of the received message.\n\n_sender_addrinfo_ is a sender socket address for connection-less socket.\nIt is an Addrinfo object.\nFor connection-oriented socket such as TCP, sender_addrinfo is platform dependent.\n\n_rflags_ is a flags on the received message which is bitwise OR of MSG_* constants such as Socket::MSG_TRUNC.\nIt will be nil if the system uses 4.3BSD style old recvmsg system call.\n\n_controls_ is ancillary data which is an array of Socket::AncillaryData objects such as:\n\n  #<Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7>\n\n_maxmesglen_ and _maxcontrollen_ can be nil.\nIn that case, the buffer will be grown until the message is not truncated.\nInternally, MSG_PEEK is used and MSG_TRUNC/MSG_CTRUNC are checked.\n\nrecvmsg can be used to implement recv_io as follows:\n\n  mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=>true)\n  controls.each {|ancdata|\n    if ancdata.cmsg_is?(:SOCKET, :RIGHTS)\n      return ancdata.unix_rights[0]\n    end\n  }",
  "recvmsg_nonblock": "recvmsg receives a message using recvmsg(2) system call in non-blocking manner.\n\nIt is similar to BasicSocket#recvmsg\nbut non-blocking flag is set before the system call\nand it doesn't retry the system call."
}