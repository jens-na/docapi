{
  "initialize": "returns a new instance of Addrinfo.\nThe instance contains sockaddr, family, socktype, protocol.\nsockaddr means struct sockaddr which can be used for connect(2), etc.\nfamily, socktype and protocol are integers which is used for arguments of socket(2).\n\nsockaddr is specified as an array or a string.\nThe array should be compatible to the value of IPSocket#addr or UNIXSocket#addr.\nThe string should be struct sockaddr as generated by\nSocket.sockaddr_in or Socket.unpack_sockaddr_un.\n\nsockaddr examples:\n- [\"AF_INET\", 46102, \"localhost.localdomain\", \"127.0.0.1\"]\n- [\"AF_INET6\", 42304, \"ip6-localhost\", \"::1\"]\n- [\"AF_UNIX\", \"/tmp/sock\"]\n- Socket.sockaddr_in(\"smtp\", \"2001:DB8::1\")\n- Socket.sockaddr_in(80, \"172.18.22.42\")\n- Socket.sockaddr_in(80, \"www.ruby-lang.org\")\n- Socket.sockaddr_un(\"/tmp/sock\")\n\nIn an AF_INET/AF_INET6 sockaddr array, the 4th element,\nnumeric IP address, is used to construct socket address in the Addrinfo instance.\nIf the 3rd element, textual host name, is non-nil, it is also recorded but used only for Addrinfo#inspect.\n\nfamily is specified as an integer to specify the protocol family such as Socket::PF_INET.\nIt can be a symbol or a string which is the constant name\nwith or without PF_ prefix such as :INET, :INET6, :UNIX, \"PF_INET\", etc.\nIf omitted, PF_UNSPEC is assumed.\n\nsocktype is specified as an integer to specify the socket type such as Socket::SOCK_STREAM.\nIt can be a symbol or a string which is the constant name\nwith or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, \"SOCK_STREAM\", etc.\nIf omitted, 0 is assumed.\n\nprotocol is specified as an integer to specify the protocol such as Socket::IPPROTO_TCP.\nIt must be an integer, unlike family and socktype.\nIf omitted, 0 is assumed.\nNote that 0 is reasonable value for most protocols, except raw socket.",
  "inspect": "returns a string which shows addrinfo in human-readable form.\n\n  Addrinfo.tcp(\"localhost\", 80).inspect #=> \"#<Addrinfo: 127.0.0.1:80 TCP (localhost)>\"\n  Addrinfo.unix(\"/tmp/sock\").inspect    #=> \"#<Addrinfo: /tmp/sock SOCK_STREAM>\"",
  "inspect_sockaddr": "returns a string which shows the sockaddr in _addrinfo_ with human-readable form.\n\n  Addrinfo.tcp(\"localhost\", 80).inspect_sockaddr     #=> \"127.0.0.1:80\"\n  Addrinfo.tcp(\"ip6-localhost\", 80).inspect_sockaddr #=> \"[::1]:80\"\n  Addrinfo.unix(\"/tmp/sock\").inspect_sockaddr        #=> \"/tmp/sock\"",
  "getaddrinfo": "returns a list of addrinfo objects as an array.\n\nThis method converts nodename (hostname) and service (port) to addrinfo.\nSince the conversion is not unique, the result is a list of addrinfo objects.\n\nnodename or service can be nil if no conversion intended.\n\nfamily, socktype and protocol are hint for preferred protocol.\nIf the result will be used for a socket with SOCK_STREAM,\nSOCK_STREAM should be specified as socktype.\nIf so, Addrinfo.getaddrinfo returns addrinfo list appropriate for SOCK_STREAM.\nIf they are omitted or nil is given, the result is not restricted.\n\nSimilarly, PF_INET6 as family restricts for IPv6.\n\nflags should be bitwise OR of Socket::AI_??? constants such as follows.\nNote that the exact list of the constants depends on OS.\n\n  AI_PASSIVE      Get address to use with bind()\n  AI_CANONNAME    Fill in the canonical name\n  AI_NUMERICHOST  Prevent host name resolution\n  AI_NUMERICSERV  Prevent service name resolution\n  AI_V4MAPPED     Accept IPv4-mapped IPv6 addresses\n  AI_ALL          Allow all addresses\n  AI_ADDRCONFIG   Accept only if any address is assigned\n\nNote that socktype should be specified whenever application knows the usage of the address.\nSome platform causes an error when socktype is omitted and servname is specified as an integer\nbecause some port numbers, 512 for example, are ambiguous without socktype.\n\n  Addrinfo.getaddrinfo(\"www.kame.net\", 80, nil, :STREAM)\n  #=> [#<Addrinfo: 203.178.141.194:80 TCP (www.kame.net)>,\n  #    #<Addrinfo: [2001:200:dff:fff1:216:3eff:feb1:44d7]:80 TCP (www.kame.net)>]",
  "ip": "returns an addrinfo object for IP address.\n\nThe port, socktype, protocol of the result is filled by zero.\nSo, it is not appropriate to create a socket.\n\n  Addrinfo.ip(\"localhost\") #=> #<Addrinfo: 127.0.0.1 (localhost)>",
  "tcp": "returns an addrinfo object for TCP address.\n\n  Addrinfo.tcp(\"localhost\", \"smtp\") #=> #<Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)>",
  "udp": "returns an addrinfo object for UDP address.\n\n  Addrinfo.udp(\"localhost\", \"daytime\") #=> #<Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)>",
  "unix": "returns an addrinfo object for UNIX socket address.\n\n_socktype_ specifies the socket type.\nIf it is omitted, :STREAM is used.\n\n  Addrinfo.unix(\"/tmp/sock\")         #=> #<Addrinfo: /tmp/sock SOCK_STREAM>\n  Addrinfo.unix(\"/tmp/sock\", :DGRAM) #=> #<Addrinfo: /tmp/sock SOCK_DGRAM>",
  "afamily": "returns the address family as an integer.\n\n  Addrinfo.tcp(\"localhost\", 80).afamily == Socket::AF_INET #=> true",
  "pfamily": "returns the protocol family as an integer.\n\n  Addrinfo.tcp(\"localhost\", 80).pfamily == Socket::PF_INET #=> true",
  "socktype": "returns the socket type as an integer.\n\n  Addrinfo.tcp(\"localhost\", 80).socktype == Socket::SOCK_STREAM #=> true",
  "protocol": "returns the socket type as an integer.\n\n  Addrinfo.tcp(\"localhost\", 80).protocol == Socket::IPPROTO_TCP #=> true",
  "canonname": "returns the canonical name as an string.\n\nnil is returned if no canonical name.\n\nThe canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is specified.\n\n  list = Addrinfo.getaddrinfo(\"www.ruby-lang.org\", 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)\n  p list[0] #=> #<Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org)>\n  p list[0].canonname #=> \"carbon.ruby-lang.org\"",
  "ipv4?": "returns true if addrinfo is IPv4 address.\nreturns false otherwise.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ipv4? #=> true\n  Addrinfo.tcp(\"::1\", 80).ipv4?       #=> false\n  Addrinfo.unix(\"/tmp/sock\").ipv4?    #=> false",
  "ipv6?": "returns true if addrinfo is IPv6 address.\nreturns false otherwise.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ipv6? #=> false\n  Addrinfo.tcp(\"::1\", 80).ipv6?       #=> true\n  Addrinfo.unix(\"/tmp/sock\").ipv6?    #=> false",
  "unix?": "returns true if addrinfo is UNIX address.\nreturns false otherwise.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).unix? #=> false\n  Addrinfo.tcp(\"::1\", 80).unix?       #=> false\n  Addrinfo.unix(\"/tmp/sock\").unix?    #=> true",
  "ip?": "returns true if addrinfo is internet (IPv4/IPv6) address.\nreturns false otherwise.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ip? #=> true\n  Addrinfo.tcp(\"::1\", 80).ip?       #=> true\n  Addrinfo.unix(\"/tmp/sock\").ip?    #=> false",
  "ip_unpack": "Returns the IP address and port number as 2-element array.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ip_unpack    #=> [\"127.0.0.1\", 80]\n  Addrinfo.tcp(\"::1\", 80).ip_unpack          #=> [\"::1\", 80]",
  "ip_address": "Returns the IP address as a string.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ip_address    #=> \"127.0.0.1\"\n  Addrinfo.tcp(\"::1\", 80).ip_address          #=> \"::1\"",
  "ip_port": "Returns the port number as an integer.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).ip_port    #=> 80\n  Addrinfo.tcp(\"::1\", 80).ip_port          #=> 80",
  "ipv4_private?": "Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16).\nIt returns false otherwise.",
  "ipv4_loopback?": "Returns true for IPv4 loopback address (127.0.0.0/8).\nIt returns false otherwise.",
  "ipv4_multicast?": "Returns true for IPv4 multicast address (224.0.0.0/4).\nIt returns false otherwise.",
  "ipv6_unspecified?": "Returns true for IPv6 unspecified address (::).\nIt returns false otherwise.",
  "ipv6_loopback?": "Returns true for IPv6 loopback address (::1).\nIt returns false otherwise.",
  "ipv6_multicast?": "Returns true for IPv6 multicast address (ff00::/8).\nIt returns false otherwise.",
  "ipv6_linklocal?": "Returns true for IPv6 link local address (ff80::/10).\nIt returns false otherwise.",
  "ipv6_sitelocal?": "Returns true for IPv6 site local address (ffc0::/10).\nIt returns false otherwise.",
  "ipv6_unique_local?": "Returns true for IPv6 unique local address (fc00::/7, RFC4193).\nIt returns false otherwise.",
  "ipv6_v4mapped?": "Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80).\nIt returns false otherwise.",
  "ipv6_v4compat?": "Returns true for IPv4-compatible IPv6 address (::/80).\nIt returns false otherwise.",
  "ipv6_mc_nodelocal?": "Returns true for IPv6 multicast node-local scope address.\nIt returns false otherwise.",
  "ipv6_mc_linklocal?": "Returns true for IPv6 multicast link-local scope address.\nIt returns false otherwise.",
  "ipv6_mc_sitelocal?": "Returns true for IPv6 multicast site-local scope address.\nIt returns false otherwise.",
  "ipv6_mc_orglocal?": "Returns true for IPv6 multicast organization-local scope address.\nIt returns false otherwise.",
  "ipv6_mc_global?": "Returns true for IPv6 multicast global scope address.\nIt returns false otherwise.",
  "ipv6_to_ipv4": "Returns IPv4 address of IPv4 mapped/compatible IPv6 address.\nIt returns nil if +self+ is not IPv4 mapped/compatible IPv6 address.\n\n  Addrinfo.ip(\"::192.0.2.3\").ipv6_to_ipv4      #=> #<Addrinfo: 192.0.2.3>\n  Addrinfo.ip(\"::ffff:192.0.2.3\").ipv6_to_ipv4 #=> #<Addrinfo: 192.0.2.3>\n  Addrinfo.ip(\"::1\").ipv6_to_ipv4              #=> nil\n  Addrinfo.ip(\"192.0.2.3\").ipv6_to_ipv4        #=> nil\n  Addrinfo.unix(\"/tmp/sock\").ipv6_to_ipv4      #=> nil",
  "unix_path": "Returns the socket path as a string.\n\n  Addrinfo.unix(\"/tmp/sock\").unix_path       #=> \"/tmp/sock\"",
  "to_sockaddr": "returns the socket address as packed struct sockaddr string.\n\n  Addrinfo.tcp(\"localhost\", 80).to_sockaddr\n  #=> \"\\x02\\x00\\x00P\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
  "to_s": "returns the socket address as packed struct sockaddr string.\n\n  Addrinfo.tcp(\"localhost\", 80).to_sockaddr\n  #=> \"\\x02\\x00\\x00P\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
  "getnameinfo": "returns nodename and service as a pair of strings.\nThis converts struct sockaddr in addrinfo to textual representation.\n\nflags should be bitwise OR of Socket::NI_??? constants.\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).getnameinfo #=> [\"localhost\", \"www\"]\n\n  Addrinfo.tcp(\"127.0.0.1\", 80).getnameinfo(Socket::NI_NUMERICSERV)\n  #=> [\"localhost\", \"80\"]",
  "marshal_dump": ":nodoc:",
  "marshal_load": ":nodoc:"
}