{
  "included": "Not documented",
  "extended": "Not documented",
  "prepended": "Not documented",
  "method_added": "Not documented",
  "method_removed": "Not documented",
  "method_undefined": "Not documented",
  "freeze": "Prevents further modifications to <i>mod</i>.\n\nThis method returns self.",
  "===": "Case Equality---Returns <code>true</code> if <i>anObject</i> is an\ninstance of <i>mod</i> or one of <i>mod</i>'s descendants. Of\nlimited use for modules, but can be used in <code>case</code>\nstatements to classify objects by class.",
  "==": "Equality --- At the <code>Object</code> level, <code>==</code> returns\n<code>true</code> only if +obj+ and +other+ are the same object.\nTypically, this method is overridden in descendant classes to provide\nclass-specific meaning.\n\nUnlike <code>==</code>, the <code>equal?</code> method should never be\noverridden by subclasses as it is used to determine object identity\n(that is, <code>a.equal?(b)</code> if and only if <code>a</code> is the\nsame object as <code>b</code>):\n\n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n\nThe <code>eql?</code> method returns <code>true</code> if +obj+ and\n+other+ refer to the same hash key.  This is used by Hash to test members\nfor equality.  For objects of class <code>Object</code>, <code>eql?</code>\nis synonymous with <code>==</code>.  Subclasses normally continue this\ntradition by aliasing <code>eql?</code> to their overridden <code>==</code>\nmethod, but there are exceptions.  <code>Numeric</code> types, for\nexample, perform type conversion across <code>==</code>, but not across\n<code>eql?</code>, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false",
  "<=>": "Comparison---Returns -1, 0, +1 or nil depending on whether +module+\nincludes +other_module+, they are the same, or if +module+ is included by\n+other_module+. This is the basis for the tests in Comparable.\n\nReturns +nil+ if +module+ has no relationship with +other_module+, if\n+other_module+ is not a module, or if the two values are incomparable.",
  "<": "Returns true if <i>mod</i> is a subclass of <i>other</i>. Returns\n<code>nil</code> if there's no relationship between the two.\n(Think of the relationship in terms of the class definition:\n\"class A<B\" implies \"A<B\").",
  "<=": "Returns true if <i>mod</i> is a subclass of <i>other</i> or\nis the same as <i>other</i>. Returns\n<code>nil</code> if there's no relationship between the two.\n(Think of the relationship in terms of the class definition:\n\"class A<B\" implies \"A<B\").",
  ">": "Returns true if <i>mod</i> is an ancestor of <i>other</i>. Returns\n<code>nil</code> if there's no relationship between the two.\n(Think of the relationship in terms of the class definition:\n\"class A<B\" implies \"B>A\").",
  ">=": "Returns true if <i>mod</i> is an ancestor of <i>other</i>, or the\ntwo modules are the same. Returns\n<code>nil</code> if there's no relationship between the two.\n(Think of the relationship in terms of the class definition:\n\"class A<B\" implies \"B>A\").",
  "initialize_copy": ":nodoc:",
  "to_s": "Return a string representing this module or class. For basic\nclasses and modules, this is the name. For singletons, we\nshow information on the thing we're attached to as well.",
  "inspect": "Return a string representing this module or class. For basic\nclasses and modules, this is the name. For singletons, we\nshow information on the thing we're attached to as well.",
  "included_modules": "Returns the list of modules included in <i>mod</i>.\n\n   module Mixin\n   end\n\n   module Outer\n     include Mixin\n   end\n\n   Mixin.included_modules   #=> []\n   Outer.included_modules   #=> [Mixin]",
  "include?": "Returns <code>true</code> if <i>module</i> is included in\n<i>mod</i> or one of <i>mod</i>'s ancestors.\n\n   module A\n   end\n   class B\n     include A\n   end\n   class C < B\n   end\n   B.include?(A)   #=> true\n   C.include?(A)   #=> true\n   A.include?(A)   #=> false",
  "name": "",
  "ancestors": "Returns a list of modules included in <i>mod</i> (including\n<i>mod</i> itself).\n\n   module Mod\n     include Math\n     include Comparable\n   end\n\n   Mod.ancestors    #=> [Mod, Comparable, Math]\n   Math.ancestors   #=> [Math]",
  "attr": "",
  "attr_reader": "Creates instance variables and corresponding methods that return the\nvalue of each instance variable. Equivalent to calling\n``<code>attr</code><i>:name</i>'' on each name in turn.\nString arguments are converted to symbols.",
  "attr_writer": "Creates an accessor method to allow assignment to the attribute\n<i>symbol</i><code>.id2name</code>.\nString arguments are converted to symbols.",
  "attr_accessor": "Defines a named attribute for this module, where the name is\n<i>symbol.</i><code>id2name</code>, creating an instance variable\n(<code>@name</code>) and a corresponding access method to read it.\nAlso creates a method called <code>name=</code> to set the attribute.\nString arguments are converted to symbols.\n\n   module Mod\n     attr_accessor(:one, :two)\n   end\n   Mod.instance_methods.sort   #=> [:one, :one=, :two, :two=]",
  "initialize": "Creates a new anonymous module. If a block is given, it is passed\nthe module object, and the block is evaluated in the context of this\nmodule using <code>module_eval</code>.\n\n   fred = Module.new do\n     def meth1\n       \"hello\"\n     end\n     def meth2\n       \"bye\"\n     end\n   end\n   a = \"my string\"\n   a.extend(fred)   #=> \"my string\"\n   a.meth1          #=> \"hello\"\n   a.meth2          #=> \"bye\"\n\nAssign the module to a constant (name starting uppercase) if you\nwant to treat it like a regular module.",
  "instance_methods": "Returns an array containing the names of the public and protected instance\nmethods in the receiver. For a module, these are the public and protected methods;\nfor a class, they are the instance (not singleton) methods. With no\nargument, or with an argument that is <code>false</code>, the\ninstance methods in <i>mod</i> are returned, otherwise the methods\nin <i>mod</i> and <i>mod</i>'s superclasses are returned.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     def method3()  end\n   end\n\n   A.instance_methods                #=> [:method1]\n   B.instance_methods(false)         #=> [:method2]\n   C.instance_methods(false)         #=> [:method3]\n   C.instance_methods(true).length   #=> 43",
  "public_instance_methods": "Returns a list of the public instance methods defined in <i>mod</i>.\nIf the optional parameter is not <code>false</code>, the methods of\nany ancestors are included.",
  "protected_instance_methods": "Returns a list of the protected instance methods defined in\n<i>mod</i>. If the optional parameter is not <code>false</code>, the\nmethods of any ancestors are included.",
  "private_instance_methods": "Returns a list of the private instance methods defined in\n<i>mod</i>. If the optional parameter is not <code>false</code>, the\nmethods of any ancestors are included.\n\n   module Mod\n     def method1()  end\n     private :method1\n     def method2()  end\n   end\n   Mod.instance_methods           #=> [:method2]\n   Mod.private_instance_methods   #=> [:method1]",
  "constants": "In the first form, returns an array of the names of all\nconstants accessible from the point of call.\nThis list includes the names of all modules and classes\ndefined in the global scope.\n\n   Module.constants.first(4)\n      # => [:ARGF, :ARGV, :ArgumentError, :Array]\n\n   Module.constants.include?(:SEEK_SET)   # => false\n\n   class IO\n     Module.constants.include?(:SEEK_SET) # => true\n   end\n\nThe second form calls the instance method +constants+.",
  "const_get": "Checks for a constant with the given name in <i>mod</i>\nIf +inherit+ is set, the lookup will also search\nthe ancestors (and +Object+ if <i>mod</i> is a +Module+.)\n\nThe value of the constant is returned if a definition is found,\notherwise a +NameError+ is raised.\n\n   Math.const_get(:PI)   #=> 3.14159265358979\n\nThis method will recursively look up constant names if a namespaced\nclass name is provided.  For example:\n\n   module Foo; class Bar; end end\n   Object.const_get 'Foo::Bar'\n\nThe +inherit+ flag is respected on each lookup.  For example:\n\n   module Foo\n     class Bar\n       VAL = 10\n     end\n\n     class Baz < Bar; end\n   end\n\n   Object.const_get 'Foo::Baz::VAL'         # => 10\n   Object.const_get 'Foo::Baz::VAL', false  # => NameError\n\nIf neither +sym+ nor +str+ is not a valid constant name a NameError will be\nraised with a warning \"wrong constant name\".\n\nObject.const_get 'foobar' #=> NameError: wrong constant name foobar",
  "const_set": "Sets the named constant to the given object, returning that object.\nCreates a new constant if no constant with the given name previously\nexisted.\n\n   Math.const_set(\"HIGH_SCHOOL_PI\", 22.0/7.0)   #=> 3.14285714285714\n   Math::HIGH_SCHOOL_PI - Math::PI              #=> 0.00126448926734968\n\nIf neither +sym+ nor +str+ is not a valid constant name a NameError will be\nraised with a warning \"wrong constant name\".\n\nObject.const_set('foobar', 42) #=> NameError: wrong constant name foobar",
  "const_defined?": "Checks for a constant with the given name in <i>mod</i>\nIf +inherit+ is set, the lookup will also search\nthe ancestors (and +Object+ if <i>mod</i> is a +Module+.)\n\nReturns whether or not a definition is found:\n\n   Math.const_defined? \"PI\"   #=> true\n   IO.const_defined? :SYNC   #=> true\n   IO.const_defined? :SYNC, false   #=> false\n\nIf neither +sym+ nor +str+ is not a valid constant name a NameError will be\nraised with a warning \"wrong constant name\".\n\nHash.const_defined? 'foobar' #=> NameError: wrong constant name foobar",
  "remove_const": "",
  "const_missing": "",
  "class_variables": "",
  "remove_class_variable": "",
  "class_variable_get": "Returns the value of the given class variable (or throws a\n<code>NameError</code> exception). The <code>@@</code> part of the\nvariable name should be included for regular class variables\nString arguments are converted to symbols.\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_get(:@@foo)     #=> 99",
  "class_variable_set": "Sets the class variable names by <i>symbol</i> to\n<i>object</i>.\nIf the class variable name is passed as a string, that string\nis converted to a symbol.\n\n   class Fred\n     @@foo = 99\n     def foo\n       @@foo\n     end\n   end\n   Fred.class_variable_set(:@@foo, 101)     #=> 101\n   Fred.new.foo                             #=> 101",
  "class_variable_defined?": "Returns <code>true</code> if the given class variable is defined\nin <i>obj</i>.\nString arguments are converted to symbols.\n\n   class Fred\n     @@foo = 99\n   end\n   Fred.class_variable_defined?(:@@foo)    #=> true\n   Fred.class_variable_defined?(:@@bar)    #=> false",
  "public_constant": "",
  "private_constant": "",
  "singleton_class?": "Returns <code>true</code> if <i>mod</i> is a singleton class or\n<code>false</code> if it is an ordinary class or module.\n\n   class C\n   end\n   C.singleton_class?                  #=> false\n   C.singleton_class.singleton_class?  #=> true",
  "module_exec": "Evaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\nAny arguments passed to the method will be passed to the block.\nThis can be used if the block needs to access instance variables.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() \"Hello there!\" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!",
  "class_exec": "Evaluates the given block in the context of the class/module.\nThe method defined in the block will belong to the receiver.\nAny arguments passed to the method will be passed to the block.\nThis can be used if the block needs to access instance variables.\n\n   class Thing\n   end\n   Thing.class_exec{\n     def hello() \"Hello there!\" end\n   }\n   puts Thing.new.hello()\n\n<em>produces:</em>\n\n   Hello there!",
  "module_eval": "Evaluates the string or block in the context of _mod_, except that when\na block is given, constant/class variable lookup is not affected. This\ncan be used to add methods to a class. <code>module_eval</code> returns\nthe result of evaluating its argument. The optional _filename_ and\n_lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() \"Hello there!\" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval(\"invalid code\", \"dummy\", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class",
  "class_eval": "Evaluates the string or block in the context of _mod_, except that when\na block is given, constant/class variable lookup is not affected. This\ncan be used to add methods to a class. <code>module_eval</code> returns\nthe result of evaluating its argument. The optional _filename_ and\n_lineno_ parameters set the text for error messages.\n\n   class Thing\n   end\n   a = %q{def hello() \"Hello there!\" end}\n   Thing.module_eval(a)\n   puts Thing.new.hello()\n   Thing.module_eval(\"invalid code\", \"dummy\", 123)\n\n<em>produces:</em>\n\n   Hello there!\n   dummy:123:in `module_eval': undefined local variable\n       or method `code' for Thing:Class",
  "remove_method": "Removes the method identified by _symbol_ from the current\nclass. For an example, see <code>Module.undef_method</code>.\nString arguments are converted to symbols.",
  "undef_method": "Prevents the current class from responding to calls to the named\nmethod. Contrast this with <code>remove_method</code>, which deletes\nthe method from the particular class; Ruby will still search\nsuperclasses and mixed-in modules for a possible receiver.\nString arguments are converted to symbols.\n\n   class Parent\n     def hello\n       puts \"In parent\"\n     end\n   end\n   class Child < Parent\n     def hello\n       puts \"In child\"\n     end\n   end\n\n\n   c = Child.new\n   c.hello\n\n\n   class Child\n     remove_method :hello  # remove from child, still in parent\n   end\n   c.hello\n\n\n   class Child\n     undef_method :hello   # prevent any calls to 'hello'\n   end\n   c.hello\n\n<em>produces:</em>\n\n   In child\n   In parent\n   prog.rb:23: undefined method `hello' for #<Child:0x401b3bb4> (NoMethodError)",
  "alias_method": "Makes <i>new_name</i> a new copy of the method <i>old_name</i>. This can\nbe used to retain access to methods that are overridden.\n\n   module Mod\n     alias_method :orig_exit, :exit\n     def exit(code=0)\n       puts \"Exiting with code #{code}\"\n       orig_exit(code)\n     end\n   end\n   include Mod\n   exit(99)\n\n<em>produces:</em>\n\n   Exiting with code 99",
  "public": "With no arguments, sets the default visibility for subsequently\ndefined methods to public. With arguments, sets the named methods to\nhave public visibility.\nString arguments are converted to symbols.",
  "protected": "With no arguments, sets the default visibility for subsequently\ndefined methods to protected. With arguments, sets the named methods\nto have protected visibility.\nString arguments are converted to symbols.",
  "private": "With no arguments, sets the default visibility for subsequently\ndefined methods to private. With arguments, sets the named methods\nto have private visibility.\nString arguments are converted to symbols.\n\n   module Mod\n     def a()  end\n     def b()  end\n     private\n     def c()  end\n     private :a\n   end\n   Mod.private_instance_methods   #=> [:a, :c]",
  "module_function": "Creates module functions for the named methods. These functions may\nbe called with the module as a receiver, and also become available\nas instance methods to classes that mix in the module. Module\nfunctions are copies of the original, and so may be changed\nindependently. The instance-method versions are made private. If\nused with no arguments, subsequently defined methods become module\nfunctions.\nString arguments are converted to symbols.\n\n   module Mod\n     def one\n       \"This is one\"\n     end\n     module_function :one\n   end\n   class Cls\n     include Mod\n     def call_one\n       one\n     end\n   end\n   Mod.one     #=> \"This is one\"\n   c = Cls.new\n   c.call_one  #=> \"This is one\"\n   module Mod\n     def one\n       \"This is the new one\"\n     end\n   end\n   Mod.one     #=> \"This is one\"\n   c.call_one  #=> \"This is the new one\"",
  "method_defined?": "Returns +true+ if the named method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors). Public and protected methods are matched.\nString arguments are converted to symbols.\n\n   module A\n     def method1()  end\n   end\n   class B\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1    #=> true\n   C.method_defined? \"method1\"   #=> true\n   C.method_defined? \"method2\"   #=> true\n   C.method_defined? \"method3\"   #=> true\n   C.method_defined? \"method4\"   #=> false",
  "public_method_defined?": "Returns +true+ if the named public method is defined by\n_mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\nString arguments are converted to symbols.\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1           #=> true\n   C.public_method_defined? \"method1\"   #=> true\n   C.public_method_defined? \"method2\"   #=> false\n   C.method_defined? \"method2\"          #=> true",
  "private_method_defined?": "Returns +true+ if the named private method is defined by\n_ mod_ (or its included modules and, if _mod_ is a class,\nits ancestors).\nString arguments are converted to symbols.\n\n   module A\n     def method1()  end\n   end\n   class B\n     private\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1            #=> true\n   C.private_method_defined? \"method1\"   #=> false\n   C.private_method_defined? \"method2\"   #=> true\n   C.method_defined? \"method2\"           #=> false",
  "protected_method_defined?": "Returns +true+ if the named protected method is defined\nby _mod_ (or its included modules and, if _mod_ is a\nclass, its ancestors).\nString arguments are converted to symbols.\n\n   module A\n     def method1()  end\n   end\n   class B\n     protected\n     def method2()  end\n   end\n   class C < B\n     include A\n     def method3()  end\n   end\n\n   A.method_defined? :method1              #=> true\n   C.protected_method_defined? \"method1\"   #=> false\n   C.protected_method_defined? \"method2\"   #=> true\n   C.method_defined? \"method2\"             #=> true",
  "public_class_method": "Makes a list of existing class methods public.\n\nString arguments are converted to symbols.",
  "private_class_method": "Makes existing class methods private. Often used to hide the default\nconstructor <code>new</code>.\n\nString arguments are converted to symbols.\n\n   class SimpleSingleton  # Not thread safe\n     private_class_method :new\n     def SimpleSingleton.create(*args, &block)\n       @me = new(*args, &block) if ! @me\n       @me\n     end\n   end",
  "include": "Invokes <code>Module.append_features</code> on each parameter in reverse order.",
  "prepend": "Invokes <code>Module.prepend_features</code> on each parameter in reverse order.",
  "append_features": "When this module is included in another, Ruby calls\n<code>append_features</code> in this module, passing it the\nreceiving module in _mod_. Ruby's default implementation is\nto add the constants, methods, and module variables of this module\nto _mod_ if this module has not already been added to\n_mod_ or one of its ancestors. See also <code>Module#include</code>.",
  "extend_object": "Extends the specified object by adding this module's constants and\nmethods (which are added as singleton methods). This is the callback\nmethod used by <code>Object#extend</code>.\n\n   module Picky\n     def Picky.extend_object(o)\n       if String === o\n         puts \"Can't add Picky to a String\"\n       else\n         puts \"Picky added to #{o.class}\"\n         super\n       end\n     end\n   end\n   (s = Array.new).extend Picky  # Call Object.extend\n   (s = \"quick brown fox\").extend Picky\n\n<em>produces:</em>\n\n   Picky added to Array\n   Can't add Picky to a String",
  "prepend_features": "When this module is prepended in another, Ruby calls\n<code>prepend_features</code> in this module, passing it the\nreceiving module in _mod_. Ruby's default implementation is\nto overlay the constants, methods, and module variables of this module\nto _mod_ if this module has not already been added to\n_mod_ or one of its ancestors. See also <code>Module#prepend</code>.",
  "refine": "Refine <i>klass</i> in the receiver.\n\nReturns an overlaid module.",
  "using": "Import class refinements from <i>module</i> into the current class or\nmodule definition.",
  "nesting": "Returns the list of +Modules+ nested at the point of call.\n\n   module M1\n     module M2\n       $a = Module.nesting\n     end\n   end\n   $a           #=> [M1::M2, M1]\n   $a[0].name   #=> \"M1::M2\"",
  "autoload": "Registers _filename_ to be loaded (using <code>Kernel::require</code>)\nthe first time that _module_ (which may be a <code>String</code> or\na symbol) is accessed in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, \"b\")\n   A::B.doit            # autoloads \"b\"",
  "autoload?": "Returns _filename_ to be loaded if _name_ is registered as\n+autoload+ in the namespace of _mod_.\n\n   module A\n   end\n   A.autoload(:B, \"b\")\n   A.autoload?(:B)            #=> \"b\"",
  "instance_method": "Returns an +UnboundMethod+ representing the given\ninstance method in _mod_.\n\n   class Interpreter\n     def do_a() print \"there, \"; end\n     def do_d() print \"Hello \";  end\n     def do_e() print \"!\\n\";     end\n     def do_v() print \"Dave\";    end\n     Dispatcher = {\n       \"a\" => instance_method(:do_a),\n       \"d\" => instance_method(:do_d),\n       \"e\" => instance_method(:do_e),\n       \"v\" => instance_method(:do_v)\n     }\n     def interpret(string)\n       string.each_char {|b| Dispatcher[b].bind(self).call }\n     end\n   end\n\n   interpreter = Interpreter.new\n   interpreter.interpret('dave')\n\n<em>produces:</em>\n\n   Hello there, Dave!",
  "public_instance_method": "Similar to _instance_method_, searches public method only.",
  "define_method": "Defines an instance method in the receiver. The _method_\nparameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.\nIf a block is specified, it is used as the method body. This block\nis evaluated using <code>instance_eval</code>, a point that is\ntricky to demonstrate because <code>define_method</code> is private.\n(This is why we resort to the +send+ hack in this example.)\n\n   class A\n     def fred\n       puts \"In Fred\"\n     end\n     def create_method(name, &block)\n       self.class.send(:define_method, name, &block)\n     end\n     define_method(:wilma) { puts \"Charge it!\" }\n   end\n   class B < A\n     define_method(:barney, instance_method(:fred))\n   end\n   a = B.new\n   a.barney\n   a.wilma\n   a.create_method(:betty) { p self }\n   a.betty\n\n<em>produces:</em>\n\n   In Fred\n   Charge it!\n   #<B:0x401b39e8>"
}