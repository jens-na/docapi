{
  "WaitReadable": "",
  "WaitWritable": "",
  "EAGAINWaitReadable": "",
  "EAGAINWaitWritable": "",
  "EWOULDBLOCKWaitReadable": ":EAGAINWaitReadable",
  "EWOULDBLOCKWaitWritable": ":EAGAINWaitWritable",
  "EINPROGRESSWaitReadable": "",
  "EINPROGRESSWaitWritable": "",
  "new": ":nodoc:",
  "open": "call-seq:\n   IO.open(fd, mode=\"r\" [, opt])                -> io\n   IO.open(fd, mode=\"r\" [, opt]) { |io| block } -> obj\n\nWith no associated block, <code>IO.open</code> is a synonym for IO.new.  If\nthe optional code block is given, it will be passed +io+ as an argument,\nand the IO object will automatically be closed when the block terminates.\nIn this instance, IO.open returns the value of the block.\n\nSee IO.new for a description of the +fd+, +mode+ and +opt+ parameters.",
  "sysopen": "Opens the given path, returning the underlying file descriptor as a\n<code>Fixnum</code>.\n\n   IO.sysopen(\"testfile\")   #=> 3",
  "for_fd": "Synonym for <code>IO.new</code>.",
  "popen": "Runs the specified command as a subprocess; the subprocess's\nstandard input and output will be connected to the returned\n<code>IO</code> object.\n\nThe PID of the started process can be obtained by IO#pid method.\n\n_cmd_ is a string or an array as follows.\n\n  cmd:\n    \"-\"                                      : fork\n    commandline                              : command line string which is passed to a shell\n    [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)\n    [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)\n  (env and opts are optional.)\n\nIf _cmd_ is a +String+ ``<code>-</code>'',\nthen a new instance of Ruby is started as the subprocess.\n\nIf <i>cmd</i> is an +Array+ of +String+,\nthen it will be used as the subprocess's +argv+ bypassing a shell.\nThe array can contains a hash at first for environments and\na hash at last for options similar to <code>spawn</code>.\n\nThe default mode for the new file object is ``r'',\nbut <i>mode</i> may be set to any of the modes listed in the description for class IO.\nThe last argument <i>opt</i> qualifies <i>mode</i>.\n\n  # set IO encoding\n  IO.popen(\"nkf -e filename\", :external_encoding=>\"EUC-JP\") {|nkf_io|\n    euc_jp_string = nkf_io.read\n  }\n\n  # merge standard output and standard error using\n  # spawn option.  See the document of Kernel.spawn.\n  IO.popen([\"ls\", \"/\", :err=>[:child, :out]]) {|ls_io|\n    ls_result_with_error = ls_io.read\n  }\n\n  # spawn options can be mixed with IO options\n  IO.popen([\"ls\", \"/\"], :err=>[:child, :out]) {|ls_io|\n    ls_result_with_error = ls_io.read\n  }\n\nRaises exceptions which <code>IO.pipe</code> and\n<code>Kernel.spawn</code> raise.\n\nIf a block is given, Ruby will run the command as a child connected\nto Ruby with a pipe. Ruby's end of the pipe will be passed as a\nparameter to the block.\nAt the end of block, Ruby close the pipe and sets <code>$?</code>.\nIn this case <code>IO.popen</code> returns\nthe value of the block.\n\nIf a block is given with a _cmd_ of ``<code>-</code>'',\nthe block will be run in two separate processes: once in the parent,\nand once in a child. The parent process will be passed the pipe\nobject as a parameter to the block, the child version of the block\nwill be passed <code>nil</code>, and the child's standard in and\nstandard out will be connected to the parent through the pipe. Not\navailable on all platforms.\n\n   f = IO.popen(\"uname\")\n   p f.readlines\n   f.close\n   puts \"Parent is #{Process.pid}\"\n   IO.popen(\"date\") { |f| puts f.gets }\n   IO.popen(\"-\") {|f| $stderr.puts \"#{Process.pid} is here, f is #{f.inspect}\"}\n   p $?\n   IO.popen(%w\"sed -e s|^|<foo>| -e s&$&;zot;&\", \"r+\") {|f|\n     f.puts \"bar\"; f.close_write; puts f.gets\n   }\n\n<em>produces:</em>\n\n   [\"Linux\\n\"]\n   Parent is 21346\n   Thu Jan 15 22:41:19 JST 2009\n   21346 is here, f is #<IO:fd 3>\n   21352 is here, f is nil\n   #<Process::Status: pid 21352 exit 0>\n   <foo>bar;zot;",
  "foreach": "Executes the block for every line in the named I/O port, where lines\nare separated by <em>sep</em>.\n\nIf no block is given, an enumerator is returned instead.\n\n   IO.foreach(\"testfile\") {|x| print \"GOT \", x }\n\n<em>produces:</em>\n\n   GOT This is line one\n   GOT This is line two\n   GOT This is line three\n   GOT And so on...\n\nIf the last argument is a hash, it's the keyword argument to open.\nSee <code>IO.read</code> for detail.",
  "readlines": "Reads all of the lines in <em>ios</em>, and returns them in\n<i>anArray</i>. Lines are separated by the optional <i>sep</i>. If\n<i>sep</i> is <code>nil</code>, the rest of the stream is returned\nas a single record.  If the first argument is an integer, or\noptional second argument is given, the returning string would not be\nlonger than the given value in bytes. The stream must be opened for\nreading or an <code>IOError</code> will be raised.\n\n   f = File.new(\"testfile\")\n   f.readlines[0]   #=> \"This is line one\\n\"",
  "read": "Reads <i>length</i> bytes from the I/O stream.\n\n<i>length</i> must be a non-negative integer or <code>nil</code>.\n\nIf <i>length</i> is a positive integer,\nit try to read <i>length</i> bytes without any conversion (binary mode).\nIt returns <code>nil</code> or a string whose length is 1 to <i>length</i> bytes.\n<code>nil</code> means it met EOF at beginning.\nThe 1 to <i>length</i>-1 bytes string means it met EOF after reading the result.\nThe <i>length</i> bytes string means it doesn't meet EOF.\nThe resulted string is always ASCII-8BIT encoding.\n\nIf <i>length</i> is omitted or is <code>nil</code>,\nit reads until EOF and the encoding conversion is applied.\nIt returns a string even if EOF is met at beginning.\n\nIf <i>length</i> is zero, it returns <code>\"\"</code>.\n\nIf the optional <i>outbuf</i> argument is present, it must reference\na String, which will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\n\nAt end of file, it returns <code>nil</code> or <code>\"\"</code>\ndepend on <i>length</i>.\n<code><i>ios</i>.read()</code> and\n<code><i>ios</i>.read(nil)</code> returns <code>\"\"</code>.\n<code><i>ios</i>.read(<i>positive-integer</i>)</code> returns <code>nil</code>.\n\n   f = File.new(\"testfile\")\n   f.read(16)   #=> \"This is line one\"\n\n   # reads whole file\n   open(\"file\") {|f|\n     data = f.read # This returns a string even if the file is empty.\n     ...\n   }\n\n   # iterate over fixed length records.\n   open(\"fixed-record-file\") {|f|\n     while record = f.read(256)\n       ...\n     end\n   }\n\n   # iterate over variable length records.\n   # record is prefixed by 32-bit length.\n   open(\"variable-record-file\") {|f|\n     while len = f.read(4)\n       len = len.unpack(\"N\")[0] # 32-bit length\n       record = f.read(len) # This returns a string even if len is 0.\n     end\n   }\n\nNote that this method behaves like fread() function in C.\nThis means it retry to invoke read(2) system call to read data with the specified length (or until EOF).\nThis behavior is preserved even if <i>ios</i> is non-blocking mode.\n(This method is non-blocking flag insensitive as other methods.)\nIf you need the behavior like single read(2) system call,\nconsider readpartial, read_nonblock and sysread.",
  "binread": "Opens the file, optionally seeks to the given <i>offset</i>, then returns\n<i>length</i> bytes (defaulting to the rest of the file).\n<code>binread</code> ensures the file is closed before returning.\nThe open mode would be \"rb:ASCII-8BIT\".\n\n   IO.binread(\"testfile\")           #=> \"This is line one\\nThis is line two\\nThis is line three\\nAnd so on...\\n\"\n   IO.binread(\"testfile\", 20)       #=> \"This is line one\\nThi\"\n   IO.binread(\"testfile\", 20, 10)   #=> \"ne one\\nThis is line \"",
  "write": "Writes the given string to <em>ios</em>. The stream must be opened\nfor writing. If the argument is not a string, it will be converted\nto a string using <code>to_s</code>. Returns the number of bytes\nwritten.\n\n   count = $stdout.write(\"This is a test\\n\")\n   puts \"That was #{count} bytes of data\"\n\n<em>produces:</em>\n\n   This is a test\n   That was 15 bytes of data",
  "binwrite": "Same as <code>IO.write</code> except opening the file in binary mode\nand ASCII-8BIT encoding (\"wb:ASCII-8BIT\").",
  "select": "[, error_array\n             [, timeout]]]) -> array  or  nil\n\nCalls select(2) system call.\nIt monitors given arrays of <code>IO</code> objects, waits one or more\nof <code>IO</code> objects ready for reading, are ready for writing,\nand have pending exceptions respectively, and returns an array that\ncontains arrays of those IO objects.  It will return <code>nil</code>\nif optional <i>timeout</i> value is given and no <code>IO</code> object\nis ready in <i>timeout</i> seconds.\n\n<code>IO.select</code> peeks the buffer of <code>IO</code> objects for testing readability.\nIf the <code>IO</code> buffer is not empty,\n<code>IO.select</code> immediately notify readability.\nThis \"peek\" is only happen for <code>IO</code> objects.\nIt is not happen for IO-like objects such as OpenSSL::SSL::SSLSocket.\n\nThe best way to use <code>IO.select</code> is invoking it\nafter nonblocking methods such as <code>read_nonblock</code>, <code>write_nonblock</code>, etc.\nThe methods raises an exception which is extended by\n<code>IO::WaitReadable</code> or <code>IO::WaitWritable</code>.\nThe modules notify how the caller should wait with <code>IO.select</code>.\nIf <code>IO::WaitReadable</code> is raised, the caller should wait for reading.\nIf <code>IO::WaitWritable</code> is raised, the caller should wait for writing.\n\nSo, blocking read (<code>readpartial</code>) can be emulated using\n<code>read_nonblock</code> and <code>IO.select</code> as follows:\n\n  begin\n    result = io_like.read_nonblock(maxlen)\n  rescue IO::WaitReadable\n    IO.select([io_like])\n    retry\n  rescue IO::WaitWritable\n    IO.select(nil, [io_like])\n    retry\n  end\n\nEspecially, the combination of nonblocking methods and\n<code>IO.select</code> is preferred for <code>IO</code> like\nobjects such as <code>OpenSSL::SSL::SSLSocket</code>.\nIt has <code>to_io</code> method to return underlying <code>IO</code> object.\n<code>IO.select</code> calls <code>to_io</code> to obtain the file descriptor to wait.\n\nThis means that readability notified by <code>IO.select</code> doesn't mean\nreadability from <code>OpenSSL::SSL::SSLSocket</code> object.\n\nMost possible situation is <code>OpenSSL::SSL::SSLSocket</code> buffers some data.\n<code>IO.select</code> doesn't see the buffer.\nSo <code>IO.select</code> can block when <code>OpenSSL::SSL::SSLSocket#readpartial</code> doesn't block.\n\nHowever several more complicated situation exists.\n\nSSL is a protocol which is sequence of records.\nThe record consists multiple bytes.\nSo, the remote side of SSL sends a partial record,\n<code>IO.select</code> notifies readability but\n<code>OpenSSL::SSL::SSLSocket</code> cannot decrypt a byte and\n<code>OpenSSL::SSL::SSLSocket#readpartial</code> will blocks.\n\nAlso, the remote side can request SSL renegotiation which forces\nthe local SSL engine writes some data.\nThis means <code>OpenSSL::SSL::SSLSocket#readpartial</code> may\ninvoke <code>write</code> system call and it can block.\nIn such situation, <code>OpenSSL::SSL::SSLSocket#read_nonblock</code>\nraises IO::WaitWritable instead of blocking.\nSo, the caller should wait for ready for writability as above example.\n\nThe combination of nonblocking methods and <code>IO.select</code> is\nalso useful for streams such as tty, pipe socket socket when\nmultiple process read form a stream.\n\nFinally, Linux kernel developers doesn't guarantee that\nreadability of select(2) means readability of following read(2) even\nfor single process.\nSee select(2) manual on GNU/Linux system.\n\nInvoking <code>IO.select</code> before <code>IO#readpartial</code> works well in usual.\nHowever it is not the best way to use <code>IO.select</code>.\n\nThe writability notified by select(2) doesn't show\nhow many bytes writable.\n<code>IO#write</code> method blocks until given whole string is written.\nSo, <code>IO#write(two or more bytes)</code> can block after writability is notified by <code>IO.select</code>.\n<code>IO#write_nonblock</code> is required to avoid the blocking.\n\nBlocking write (<code>write</code>) can be emulated using\n<code>write_nonblock</code> and <code>IO.select</code> as follows:\nIO::WaitReadable should also be rescued for SSL renegotiation in <code>OpenSSL::SSL::SSLSocket</code>.\n\n  while 0 < string.bytesize\n    begin\n      written = io_like.write_nonblock(string)\n    rescue IO::WaitReadable\n      IO.select([io_like])\n      retry\n    rescue IO::WaitWritable\n      IO.select(nil, [io_like])\n      retry\n    end\n    string = string.byteslice(written..-1)\n  end\n\n=== Parameters\nread_array:: an array of <code>IO</code> objects that wait until ready for read\nwrite_array:: an array of <code>IO</code> objects that wait until ready for write\nerror_array:: an array of <code>IO</code> objects that wait for exceptions\ntimeout:: a numeric value in second\n\n=== Example\n\n    rp, wp = IO.pipe\n    mesg = \"ping \"\n    100.times {\n      # IO.select follows IO#read.  Not the best way to use IO.select.\n      rs, ws, = IO.select([rp], [wp])\n      if r = rs[0]\n        ret = r.read(5)\n        print ret\n        case ret\n        when /ping/\n          mesg = \"pong\\n\"\n        when /pong/\n          mesg = \"ping \"\n        end\n      end\n      if w = ws[0]\n        w.write(mesg)\n      end\n    }\n\n<em>produces:</em>\n\n    ping pong\n    ping pong\n    ping pong\n    (snipped)\n    ping",
  "pipe": "IO.pipe(...) {|read_io, write_io| ... }\n\nCreates a pair of pipe endpoints (connected to each other) and\nreturns them as a two-element array of <code>IO</code> objects:\n<code>[</code> <i>read_io</i>, <i>write_io</i> <code>]</code>.\n\nIf a block is given, the block is called and\nreturns the value of the block.\n<i>read_io</i> and <i>write_io</i> are sent to the block as arguments.\nIf read_io and write_io are not closed when the block exits, they are closed.\ni.e. closing read_io and/or write_io doesn't cause an error.\n\nNot available on all platforms.\n\nIf an encoding (encoding name or encoding object) is specified as an optional argument,\nread string from pipe is tagged with the encoding specified.\nIf the argument is a colon separated two encoding names \"A:B\",\nthe read string is converted from encoding A (external encoding)\nto encoding B (internal encoding), then tagged with B.\nIf two optional arguments are specified, those must be\nencoding objects or encoding names,\nand the first one is the external encoding,\nand the second one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.\n\nIn the example below, the two processes close the ends of the pipe\nthat they are not using. This is not just a cosmetic nicety. The\nread end of a pipe will not generate an end of file condition if\nthere are any writers with the pipe still open. In the case of the\nparent process, the <code>rd.read</code> will never return if it\ndoes not first issue a <code>wr.close</code>.\n\n   rd, wr = IO.pipe\n\n   if fork\n     wr.close\n     puts \"Parent got: <#{rd.read}>\"\n     rd.close\n     Process.wait\n   else\n     rd.close\n     puts \"Sending message to parent\"\n     wr.write \"Hi Dad\"\n     wr.close\n   end\n\n<em>produces:</em>\n\n   Sending message to parent\n   Parent got: <Hi Dad>",
  "try_convert": "Try to convert <i>obj</i> into an IO, using to_io method.\nReturns converted IO or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   IO.try_convert(STDOUT)     #=> STDOUT\n   IO.try_convert(\"STDOUT\")   #=> nil\n\n   require 'zlib'\n   f = open(\"/tmp/zz.gz\")       #=> #<File:/tmp/zz.gz>\n   z = Zlib::GzipReader.open(f) #=> #<Zlib::GzipReader:0x81d8744>\n   IO.try_convert(z)            #=> #<File:/tmp/zz.gz>",
  "copy_stream": "IO.copy_stream copies <i>src</i> to <i>dst</i>.\n<i>src</i> and <i>dst</i> is either a filename or an IO.\n\nThis method returns the number of bytes copied.\n\nIf optional arguments are not given,\nthe start position of the copy is\nthe beginning of the filename or\nthe current file offset of the IO.\nThe end position of the copy is the end of file.\n\nIf <i>copy_length</i> is given,\nNo more than <i>copy_length</i> bytes are copied.\n\nIf <i>src_offset</i> is given,\nit specifies the start position of the copy.\n\nWhen <i>src_offset</i> is specified and\n<i>src</i> is an IO,\nIO.copy_stream doesn't move the current file offset.",
  "initialize": "Returns a new IO object (a stream) for the given integer file descriptor\n+fd+ and +mode+ string.  +opt+ may be used to specify parts of +mode+ in a\nmore readable fashion.  See also IO.sysopen and IO.for_fd.\n\nIO.new is called by various File and IO opening methods such as IO::open,\nKernel#open, and File::open.\n\n=== Open Mode\n\nWhen +mode+ is an integer it must be combination of the modes defined in\nFile::Constants (+File::RDONLY+, +File::WRONLY | File::CREAT+).  See the\nopen(2) man page for more information.\n\nWhen +mode+ is a string it must be in one of the following forms:\n\n  fmode\n  fmode \":\" ext_enc\n  fmode \":\" ext_enc \":\" int_enc\n  fmode \":\" \"BOM|UTF-*\"\n\n+fmode+ is an IO open mode string, +ext_enc+ is the external encoding for\nthe IO and +int_enc+ is the internal encoding.\n\n==== IO Open Mode\n\nRuby allows the following open modes:\n\n\t\"r\"  Read-only, starts at beginning of file  (default mode).\n\n\t\"r+\" Read-write, starts at beginning of file.\n\n\t\"w\"  Write-only, truncates existing file\n\t     to zero length or creates a new file for writing.\n\n\t\"w+\" Read-write, truncates existing file to zero length\n\t     or creates a new file for reading and writing.\n\n\t\"a\"  Write-only, starts at end of file if file exists,\n\t     otherwise creates a new file for writing.\n\n\t\"a+\" Read-write, starts at end of file if file exists,\n    otherwise creates a new file for reading and\n\t     writing.\n\nThe following modes must be used separately, and along with one or more of\nthe modes seen above.\n\n\t\"b\"  Binary file mode\n\t     Suppresses EOL <-> CRLF conversion on Windows. And\n\t     sets external encoding to ASCII-8BIT unless explicitly\n\t     specified.\n\n\t\"t\"  Text file mode\n\nWhen the open mode of original IO is read only, the mode cannot be\nchanged to be writable.  Similarly, the open mode cannot be changed from\nwrite only to readable.\n\nWhen such a change is attempted the error is raised in different locations\naccording to the platform.\n\n=== IO Encoding\n\nWhen +ext_enc+ is specified, strings read will be tagged by the encoding\nwhen reading, and strings output will be converted to the specified\nencoding when writing.\n\nWhen +ext_enc+ and +int_enc+ are specified read strings will be converted\nfrom +ext_enc+ to +int_enc+ upon input, and written strings will be\nconverted from +int_enc+ to +ext_enc+ upon output.  See Encoding for\nfurther details of transcoding on input and output.\n\nIf \"BOM|UTF-8\", \"BOM|UTF-16LE\" or \"BOM|UTF16-BE\" are used, ruby checks for\na Unicode BOM in the input document to help determine the encoding.  For\nUTF-16 encodings the file open mode must be binary.  When present, the BOM\nis stripped and the external encoding from the BOM is used.  When the BOM\nis missing the given Unicode encoding is used as +ext_enc+.  (The BOM-set\nencoding option is case insensitive, so \"bom|utf-8\" is also valid.)\n\n=== Options\n\n+opt+ can be used instead of +mode+ for improved readability.  The\nfollowing keys are supported:\n\n:mode ::\n  Same as +mode+ parameter\n\n:\\external_encoding ::\n  External encoding for the IO.  \"-\" is a synonym for the default external\n  encoding.\n\n:\\internal_encoding ::\n  Internal encoding for the IO.  \"-\" is a synonym for the default internal\n  encoding.\n\n  If the value is nil no conversion occurs.\n\n:encoding ::\n  Specifies external and internal encodings as \"extern:intern\".\n\n:textmode ::\n  If the value is truth value, same as \"t\" in argument +mode+.\n\n:binmode ::\n  If the value is truth value, same as \"b\" in argument +mode+.\n\n:autoclose ::\n  If the value is +false+, the +fd+ will be kept open after this IO\n  instance gets finalized.\n\nAlso, +opt+ can have same keys in String#encode for controlling conversion\nbetween the external encoding and the internal encoding.\n\n=== Example 1\n\n  fd = IO.sysopen(\"/dev/tty\", \"w\")\n  a = IO.new(fd,\"w\")\n  $stderr.puts \"Hello\"\n  a.puts \"World\"\n\nProduces:\n\n  Hello\n  World\n\n=== Example 2\n\n  require 'fcntl'\n\n  fd = STDERR.fcntl(Fcntl::F_DUPFD)\n  io = IO.new(fd, mode: 'w:UTF-16LE', cr_newline: true)\n  io.puts \"Hello, World!\"\n\n  fd = STDERR.fcntl(Fcntl::F_DUPFD)\n  io = IO.new(fd, mode: 'w', cr_newline: true,\n              external_encoding: Encoding::UTF_16LE)\n  io.puts \"Hello, World!\"\n\nBoth of above print \"Hello, World!\" in UTF-16LE to standard error output\nwith converting EOL generated by <code>puts</code> to CR.",
  "initialize_copy": ":nodoc:",
  "reopen": "Reassociates <em>ios</em> with the I/O stream given in\n<i>other_IO</i> or to a new stream opened on <i>path</i>. This may\ndynamically change the actual class of this stream.\n\n   f1 = File.new(\"testfile\")\n   f2 = File.new(\"testfile\")\n   f2.readlines[0]   #=> \"This is line one\\n\"\n   f2.reopen(f1)     #=> #<File:testfile>\n   f2.readlines[0]   #=> \"This is line one\\n\"",
  "print": "Writes the given object(s) to <em>ios</em>. The stream must be\nopened for writing. If the output field separator (<code>$,</code>)\nis not <code>nil</code>, it will be inserted between each object.\nIf the output record separator (<code>$\\\\</code>)\nis not <code>nil</code>, it will be appended to the output. If no\narguments are given, prints <code>$_</code>. Objects that aren't\nstrings will be converted by calling their <code>to_s</code> method.\nWith no argument, prints the contents of the variable <code>$_</code>.\nReturns <code>nil</code>.\n\n   $stdout.print(\"This is \", 100, \" percent.\\n\")\n\n<em>produces:</em>\n\n   This is 100 percent.",
  "putc": "If <i>obj</i> is <code>Numeric</code>, write the character whose code is\nthe least-significant byte of <i>obj</i>, otherwise write the first byte\nof the string representation of <i>obj</i> to <em>ios</em>. Note: This\nmethod is not safe for use with multi-byte characters as it will truncate\nthem.\n\n   $stdout.putc \"A\"\n   $stdout.putc 65\n\n<em>produces:</em>\n\n   AA",
  "puts": "Writes the given objects to <em>ios</em> as with\n<code>IO#print</code>. Writes a record separator (typically a\nnewline) after any that do not already end with a newline sequence.\nIf called with an array argument, writes each element on a new line.\nIf called without arguments, outputs a single record separator.\n\n   $stdout.puts(\"this\", \"is\", \"a\", \"test\")\n\n<em>produces:</em>\n\n   this\n   is\n   a\n   test",
  "printf": "Formats and writes to <em>ios</em>, converting parameters under\ncontrol of the format string. See <code>Kernel#sprintf</code>\nfor details.",
  "each": "ios.each_line(sep=$/) {|line| block }    -> ios\n   ios.each_line(limit) {|line| block }     -> ios\n   ios.each_line(sep,limit) {|line| block } -> ios\n   ios.each_line(...)                       -> an_enumerator\n\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an <code>IOError</code> will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new(\"testfile\")\n   f.each {|line| puts \"#{f.lineno}: #{line}\" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...",
  "each_line": "ios.each_line(sep=$/) {|line| block }    -> ios\n   ios.each_line(limit) {|line| block }     -> ios\n   ios.each_line(sep,limit) {|line| block } -> ios\n   ios.each_line(...)                       -> an_enumerator\n\nExecutes the block for every line in <em>ios</em>, where lines are\nseparated by <i>sep</i>. <em>ios</em> must be opened for\nreading or an <code>IOError</code> will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new(\"testfile\")\n   f.each {|line| puts \"#{f.lineno}: #{line}\" }\n\n<em>produces:</em>\n\n   1: This is line one\n   2: This is line two\n   3: This is line three\n   4: And so on...",
  "each_byte": "Calls the given block once for each byte (0..255) in <em>ios</em>,\npassing the byte as an argument. The stream must be opened for\nreading or an <code>IOError</code> will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new(\"testfile\")\n   checksum = 0\n   f.each_byte {|x| checksum ^= x }   #=> #<File:testfile>\n   checksum                           #=> 12",
  "each_char": "Calls the given block once for each character in <em>ios</em>,\npassing the character as an argument. The stream must be opened for\nreading or an <code>IOError</code> will be raised.\n\nIf no block is given, an enumerator is returned instead.\n\n   f = File.new(\"testfile\")\n   f.each_char {|c| print c, ' ' }   #=> #<File:testfile>",
  "each_codepoint": "Passes the <code>Integer</code> ordinal of each character in <i>ios</i>,\npassing the codepoint as an argument. The stream must be opened for\nreading or an <code>IOError</code> will be raised.\n\nIf no block is given, an enumerator is returned instead.",
  "lines": "This is a deprecated alias for <code>each_line</code>.",
  "bytes": "This is a deprecated alias for <code>each_byte</code>.",
  "chars": "This is a deprecated alias for <code>each_char</code>.",
  "codepoints": "This is a deprecated alias for <code>each_codepoint</code>.",
  "syswrite": "Writes the given string to <em>ios</em> using a low-level write.\nReturns the number of bytes written. Do not mix with other methods\nthat write to <em>ios</em> or you may get unpredictable results.\nRaises <code>SystemCallError</code> on error.\n\n   f = File.new(\"out\", \"w\")\n   f.syswrite(\"ABCDEF\")   #=> 6",
  "sysread": "Reads <i>maxlen</i> bytes from <em>ios</em> using a low-level\nread and returns them as a string.  Do not mix with other methods\nthat read from <em>ios</em> or you may get unpredictable results.\nIf the optional <i>outbuf</i> argument is present, it must reference\na String, which will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\nRaises <code>SystemCallError</code> on error and\n<code>EOFError</code> at end of file.\n\n   f = File.new(\"testfile\")\n   f.sysread(16)   #=> \"This is line one\"",
  "fileno": "Returns an integer representing the numeric file descriptor for\n<em>ios</em>.\n\n   $stdin.fileno    #=> 0\n   $stdout.fileno   #=> 1",
  "to_i": "Returns an integer representing the numeric file descriptor for\n<em>ios</em>.\n\n   $stdin.fileno    #=> 0\n   $stdout.fileno   #=> 1",
  "to_io": "Returns <em>ios</em>.",
  "fsync": "Immediately writes all buffered data in <em>ios</em> to disk.\nNote that <code>fsync</code> differs from\nusing <code>IO#sync=</code>. The latter ensures that data is flushed\nfrom Ruby's buffers, but does not guarantee that the underlying\noperating system actually writes it to disk.\n\n<code>NotImplementedError</code> is raised\nif the underlying operating system does not support <em>fsync(2)</em>.",
  "fdatasync": "Immediately writes all buffered data in <em>ios</em> to disk.\n\nIf the underlying operating system does not support <em>fdatasync(2)</em>,\n<code>IO#fsync</code> is called instead (which might raise a\n<code>NotImplementedError</code>).",
  "sync": "Returns the current ``sync mode'' of <em>ios</em>. When sync mode is\ntrue, all output is immediately flushed to the underlying operating\nsystem and is not buffered by Ruby internally. See also\n<code>IO#fsync</code>.\n\n   f = File.new(\"testfile\")\n   f.sync   #=> false",
  "sync=": "",
  "lineno": "Returns the current line number in <em>ios</em>.  The stream must be\nopened for reading. <code>lineno</code> counts the number of times\n#gets is called rather than the number of newlines encountered.  The two\nvalues will differ if #gets is called with a separator other than newline.\n\nMethods that use <code>$/</code> like #each, #lines and #readline will\nalso increment <code>lineno</code>.\n\nSee also the <code>$.</code> variable.\n\n   f = File.new(\"testfile\")\n   f.lineno   #=> 0\n   f.gets     #=> \"This is line one\\n\"\n   f.lineno   #=> 1\n   f.gets     #=> \"This is line two\\n\"\n   f.lineno   #=> 2",
  "lineno=": "Manually sets the current line number to the given value.\n<code>$.</code> is updated only on the next read.\n\n   f = File.new(\"testfile\")\n   f.gets                     #=> \"This is line one\\n\"\n   $.                         #=> 1\n   f.lineno = 1000\n   f.lineno                   #=> 1000\n   $.                         #=> 1         # lineno of last read\n   f.gets                     #=> \"This is line two\\n\"\n   $.                         #=> 1001      # lineno of last read",
  "read_nonblock": "Reads at most <i>maxlen</i> bytes from <em>ios</em> using\nthe read(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\n\nread_nonblock just calls the read(2) system call.\nIt causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc.\nThe caller should care such errors.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying read_nonblock.\n\nread_nonblock causes EOFError on EOF.\n\nIf the read byte buffer is not empty,\nread_nonblock reads from the buffer like readpartial.\nIn this case, the read(2) system call is not called.\n\nWhen read_nonblock raises an exception kind of IO::WaitReadable,\nread_nonblock should not be called\nuntil io is readable for avoiding busy loop.\nThis can be done as follows.\n\n  # emulates blocking read (readpartial).\n  begin\n    result = io.read_nonblock(maxlen)\n  rescue IO::WaitReadable\n    IO.select([io])\n    retry\n  end\n\nAlthough IO#read_nonblock doesn't raise IO::WaitWritable.\nOpenSSL::Buffering#read_nonblock can raise IO::WaitWritable.\nIf IO and SSL should be used polymorphically,\nIO::WaitWritable should be rescued too.\nSee the document of OpenSSL::Buffering#read_nonblock for sample code.\n\nNote that this method is identical to readpartial\nexcept the non-blocking flag is set.",
  "write_nonblock": "Writes the given string to <em>ios</em> using\nthe write(2) system call after O_NONBLOCK is set for\nthe underlying file descriptor.\n\nIt returns the number of bytes written.\n\nwrite_nonblock just calls the write(2) system call.\nIt causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc.\nThe result may also be smaller than string.length (partial write).\nThe caller should care such errors and partial write.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitWritable.\nSo IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock.\n\n  # Creates a pipe.\n  r, w = IO.pipe\n\n  # write_nonblock writes only 65536 bytes and return 65536.\n  # (The pipe size is 65536 bytes on this environment.)\n  s = \"a\" * 100000\n  p w.write_nonblock(s)     #=> 65536\n\n  # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).\n  p w.write_nonblock(\"b\")   # Resource temporarily unavailable (Errno::EAGAIN)\n\nIf the write buffer is not empty, it is flushed at first.\n\nWhen write_nonblock raises an exception kind of IO::WaitWritable,\nwrite_nonblock should not be called\nuntil io is writable for avoiding busy loop.\nThis can be done as follows.\n\n  begin\n    result = io.write_nonblock(string)\n  rescue IO::WaitWritable, Errno::EINTR\n    IO.select(nil, [io])\n    retry\n  end\n\nNote that this doesn't guarantee to write all data in string.\nThe length written is reported as result and it should be checked later.\n\nOn some platforms such as Windows, write_nonblock is not supported\naccording to the kind of the IO object.\nIn such cases, write_nonblock raises <code>Errno::EBADF</code>.\n\nBy specifying `exception: false`, the options hash allows you to indicate\nthat write_nonblock should not raise an IO::WaitWritable exception, but\nreturn the symbol :wait_writable instead.",
  "readpartial": "Reads at most <i>maxlen</i> bytes from the I/O stream.\nIt blocks only if <em>ios</em> has no data immediately available.\nIt doesn't block if some data available.\nIf the optional <i>outbuf</i> argument is present,\nit must reference a String, which will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\nIt raises <code>EOFError</code> on end of file.\n\nreadpartial is designed for streams such as pipe, socket, tty, etc.\nIt blocks only when no data immediately available.\nThis means that it blocks only when following all conditions hold.\n* the byte buffer in the IO object is empty.\n* the content of the stream is empty.\n* the stream is not reached to EOF.\n\nWhen readpartial blocks, it waits data or EOF on the stream.\nIf some data is reached, readpartial returns with the data.\nIf EOF is reached, readpartial raises EOFError.\n\nWhen readpartial doesn't blocks, it returns or raises immediately.\nIf the byte buffer is not empty, it returns the data in the buffer.\nOtherwise if the stream has some content,\nit returns the data in the stream.\nOtherwise if the stream is reached to EOF, it raises EOFError.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\"               #               \"\"              \"abc\".\n   r.readpartial(4096)      #=> \"abc\"       \"\"              \"\"\n   r.readpartial(4096)      # blocks because buffer and pipe is empty.\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\"               #               \"\"              \"abc\"\n   w.close                  #               \"\"              \"abc\" EOF\n   r.readpartial(4096)      #=> \"abc\"       \"\"              EOF\n   r.readpartial(4096)      # raises EOFError\n\n   r, w = IO.pipe           #               buffer          pipe content\n   w << \"abc\\ndef\\n\"        #               \"\"              \"abc\\ndef\\n\"\n   r.gets                   #=> \"abc\\n\"     \"def\\n\"         \"\"\n   w << \"ghi\\n\"             #               \"def\\n\"         \"ghi\\n\"\n   r.readpartial(4096)      #=> \"def\\n\"     \"\"              \"ghi\\n\"\n   r.readpartial(4096)      #=> \"ghi\\n\"     \"\"              \"\"\n\nNote that readpartial behaves similar to sysread.\nThe differences are:\n* If the byte buffer is not empty, read from the byte buffer instead of \"sysread for buffered IO (IOError)\".\n* It doesn't cause Errno::EWOULDBLOCK and Errno::EINTR.  When readpartial meets EWOULDBLOCK and EINTR by read system call, readpartial retry the system call.\n\nThe later means that readpartial is nonblocking-flag insensitive.\nIt blocks on the situation IO#sysread causes Errno::EWOULDBLOCK as if the fd is blocking mode.",
  "gets": "Reads the next ``line'' from the I/O stream; lines are separated by\n<i>sep</i>. A separator of <code>nil</code> reads the entire\ncontents, and a zero-length separator reads the input a paragraph at\na time (two successive newlines in the input separate paragraphs).\nThe stream must be opened for reading or an <code>IOError</code>\nwill be raised. The line read in will be returned and also assigned\nto <code>$_</code>. Returns <code>nil</code> if called at end of\nfile.  If the first argument is an integer, or optional second\nargument is given, the returning string would not be longer than the\ngiven value in bytes.\n\n   File.new(\"testfile\").gets   #=> \"This is line one\\n\"\n   $_                          #=> \"This is line one\\n\"",
  "readline": "Reads a line as with <code>IO#gets</code>, but raises an\n<code>EOFError</code> on end of file.",
  "getc": "Reads a one-character string from <em>ios</em>. Returns\n<code>nil</code> if called at end of file.\n\n   f = File.new(\"testfile\")\n   f.getc   #=> \"h\"\n   f.getc   #=> \"e\"",
  "getbyte": "Gets the next 8-bit byte (0..255) from <em>ios</em>. Returns\n<code>nil</code> if called at end of file.\n\n   f = File.new(\"testfile\")\n   f.getbyte   #=> 84\n   f.getbyte   #=> 104",
  "readchar": "Reads a one-character string from <em>ios</em>. Raises an\n<code>EOFError</code> on end of file.\n\n   f = File.new(\"testfile\")\n   f.readchar   #=> \"h\"\n   f.readchar   #=> \"e\"",
  "readbyte": "Reads a byte as with <code>IO#getbyte</code>, but raises an\n<code>EOFError</code> on end of file.",
  "ungetbyte": "Pushes back bytes (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered read will return it. Only one byte\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several bytes that have been pushed\nback). Has no effect with unbuffered reads (such as <code>IO#sysread</code>).\n\n   f = File.new(\"testfile\")   #=> #<File:testfile>\n   b = f.getbyte              #=> 0x38\n   f.ungetbyte(b)             #=> nil\n   f.getbyte                  #=> 0x38",
  "ungetc": "Pushes back one character (passed as a parameter) onto <em>ios</em>,\nsuch that a subsequent buffered character read will return it. Only one character\nmay be pushed back before a subsequent read operation (that is,\nyou will be able to read only the last of several characters that have been pushed\nback). Has no effect with unbuffered reads (such as <code>IO#sysread</code>).\n\n   f = File.new(\"testfile\")   #=> #<File:testfile>\n   c = f.getc                 #=> \"8\"\n   f.ungetc(c)                #=> nil\n   f.getc                     #=> \"8\"",
  "<<": "String Output---Writes <i>obj</i> to <em>ios</em>.\n<i>obj</i> will be converted to a string using\n<code>to_s</code>.\n\n   $stdout << \"Hello \" << \"world!\\n\"\n\n<em>produces:</em>\n\n   Hello world!",
  "flush": "Flushes any buffered data within <em>ios</em> to the underlying\noperating system (note that this is Ruby internal buffering only;\nthe OS may buffer the data as well).\n\n   $stdout.print \"no newline\"\n   $stdout.flush\n\n<em>produces:</em>\n\n   no newline",
  "tell": "Returns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new(\"testfile\")\n   f.pos    #=> 0\n   f.gets   #=> \"This is line one\\n\"\n   f.pos    #=> 17",
  "seek": "Seeks to a given offset <i>anInteger</i> in the stream according to\nthe value of <i>whence</i>:\n\n  :CUR or IO::SEEK_CUR  | Seeks to _amount_ plus current position\n  ----------------------+--------------------------------------------------\n  :END or IO::SEEK_END  | Seeks to _amount_ plus end of stream (you\n                        | probably want a negative value for _amount_)\n  ----------------------+--------------------------------------------------\n  :SET or IO::SEEK_SET  | Seeks to the absolute location given by _amount_\n\nExample:\n\n   f = File.new(\"testfile\")\n   f.seek(-13, IO::SEEK_END)   #=> 0\n   f.readline                  #=> \"And so on...\\n\"",
  "SEEK_SET": "Set I/O position from the beginning",
  "SEEK_CUR": "Set I/O position from the current position",
  "SEEK_END": "Set I/O position from the end",
  "SEEK_DATA": "Set I/O position to the next location containing data",
  "SEEK_HOLE": "Set I/O position to the next hole",
  "rewind": "Positions <em>ios</em> to the beginning of input, resetting\n<code>lineno</code> to zero.\n\n   f = File.new(\"testfile\")\n   f.readline   #=> \"This is line one\\n\"\n   f.rewind     #=> 0\n   f.lineno     #=> 0\n   f.readline   #=> \"This is line one\\n\"\n\nNote that it cannot be used with streams such as pipes, ttys, and sockets.",
  "pos": "Returns the current offset (in bytes) of <em>ios</em>.\n\n   f = File.new(\"testfile\")\n   f.pos    #=> 0\n   f.gets   #=> \"This is line one\\n\"\n   f.pos    #=> 17",
  "pos=": "Seeks to the given position (in bytes) in <em>ios</em>.\nIt is not guaranteed that seeking to the right position when <em>ios</em>\nis textmode.\n\n   f = File.new(\"testfile\")\n   f.pos = 17\n   f.gets   #=> \"This is line two\\n\"",
  "eof": "Returns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an <code>IOError</code> will be\nraised.\n\n   f = File.new(\"testfile\")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, <code>IO#eof?</code>\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts \"a\" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that <code>IO#eof?</code> reads data to the input byte buffer.\nSo <code>IO#sysread</code> may not behave as you intend with\n<code>IO#eof?</code>, unless you call <code>IO#rewind</code>\nfirst (which is not available for some streams).",
  "eof?": "Returns true if <em>ios</em> is at end of file that means\nthere are no more data to read.\nThe stream must be opened for reading or an <code>IOError</code> will be\nraised.\n\n   f = File.new(\"testfile\")\n   dummy = f.readlines\n   f.eof   #=> true\n\nIf <em>ios</em> is a stream such as pipe or socket, <code>IO#eof?</code>\nblocks until the other end sends some data or closes it.\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.close }\n   r.eof?  #=> true after 1 second blocking\n\n   r, w = IO.pipe\n   Thread.new { sleep 1; w.puts \"a\" }\n   r.eof?  #=> false after 1 second blocking\n\n   r, w = IO.pipe\n   r.eof?  # blocks forever\n\nNote that <code>IO#eof?</code> reads data to the input byte buffer.\nSo <code>IO#sysread</code> may not behave as you intend with\n<code>IO#eof?</code>, unless you call <code>IO#rewind</code>\nfirst (which is not available for some streams).",
  "close_on_exec?": "Returns <code>true</code> if <em>ios</em> will be closed on exec.\n\n   f = open(\"/dev/null\")\n   f.close_on_exec?                 #=> false\n   f.close_on_exec = true\n   f.close_on_exec?                 #=> true\n   f.close_on_exec = false\n   f.close_on_exec?                 #=> false",
  "close_on_exec=": "Sets a close-on-exec flag.\n\n   f = open(\"/dev/null\")\n   f.close_on_exec = true\n   system(\"cat\", \"/proc/self/fd/#{f.fileno}\") # cat: /proc/self/fd/3: No such file or directory\n   f.closed?                #=> false\n\nRuby sets close-on-exec flags of all file descriptors by default\nsince Ruby 2.0.0.\nSo you don't need to set by yourself.\nAlso, unsetting a close-on-exec flag can cause file descriptor leak\nif another thread use fork() and exec() (via system() method for example).\nIf you really needs file descriptor inheritance to child process,\nuse spawn()'s argument such as fd=>fd.",
  "close": "Closes <em>ios</em> and flushes any pending writes to the operating\nsystem. The stream is unavailable for any further data operations;\nan <code>IOError</code> is raised if such an attempt is made. I/O\nstreams are automatically closed when they are claimed by the\ngarbage collector.\n\nIf <em>ios</em> is opened by <code>IO.popen</code>,\n<code>close</code> sets <code>$?</code>.",
  "closed?": "Returns <code>true</code> if <em>ios</em> is completely closed (for\nduplex streams, both reader and writer), <code>false</code>\notherwise.\n\n   f = File.new(\"testfile\")\n   f.close         #=> nil\n   f.closed?       #=> true\n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_write   #=> nil\n   f.closed?       #=> false\n   f.close_read    #=> nil\n   f.closed?       #=> true",
  "close_read": "Closes the read end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n<code>IOError</code> if the stream is not duplexed.\n\n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_read\n   f.readlines\n\n<em>produces:</em>\n\n   prog.rb:3:in `readlines': not opened for reading (IOError)\n   \tfrom prog.rb:3",
  "close_write": "Closes the write end of a duplex I/O stream (i.e., one that contains\nboth a read and a write stream, such as a pipe). Will raise an\n<code>IOError</code> if the stream is not duplexed.\n\n   f = IO.popen(\"/bin/sh\",\"r+\")\n   f.close_write\n   f.print \"nowhere\"\n\n<em>produces:</em>\n\n   prog.rb:3:in `write': not opened for writing (IOError)\n   \tfrom prog.rb:3:in `print'\n   \tfrom prog.rb:3",
  "isatty": "Returns <code>true</code> if <em>ios</em> is associated with a\nterminal device (tty), <code>false</code> otherwise.\n\n   File.new(\"testfile\").isatty   #=> false\n   File.new(\"/dev/tty\").isatty   #=> true",
  "tty?": "Returns <code>true</code> if <em>ios</em> is associated with a\nterminal device (tty), <code>false</code> otherwise.\n\n   File.new(\"testfile\").isatty   #=> false\n   File.new(\"/dev/tty\").isatty   #=> true",
  "binmode": "Puts <em>ios</em> into binary mode.\nOnce a stream is in binary mode, it cannot be reset to nonbinary mode.\n\n- newline conversion disabled\n- encoding conversion disabled\n- content is treated as ASCII-8BIT",
  "binmode?": "Returns <code>true</code> if <em>ios</em> is binmode.",
  "sysseek": "Seeks to a given <i>offset</i> in the stream according to the value\nof <i>whence</i> (see <code>IO#seek</code> for values of\n<i>whence</i>). Returns the new offset into the file.\n\n   f = File.new(\"testfile\")\n   f.sysseek(-13, IO::SEEK_END)   #=> 53\n   f.sysread(10)                  #=> \"And so on.\"",
  "advise": "Announce an intention to access data from the current file in a\nspecific pattern. On platforms that do not support the\n<em>posix_fadvise(2)</em> system call, this method is a no-op.\n\n_advice_ is one of the following symbols:\n\n:normal::     No advice to give; the default assumption for an open file.\n:sequential:: The data will be accessed sequentially\n              with lower offsets read before higher ones.\n:random::     The data will be accessed in random order.\n:willneed::   The data will be accessed in the near future.\n:dontneed::   The data will not be accessed in the near future.\n:noreuse::    The data will only be accessed once.\n\nThe semantics of a piece of advice are platform-dependent. See\n<em>man 2 posix_fadvise</em> for details.\n\n\"data\" means the region of the current file that begins at\n_offset_ and extends for _len_ bytes. If _len_ is 0, the region\nends at the last byte of the file. By default, both _offset_ and\n_len_ are 0, meaning that the advice applies to the entire file.\n\nIf an error occurs, one of the following exceptions will be raised:\n\n<code>IOError</code>:: The <code>IO</code> stream is closed.\n<code>Errno::EBADF</code>::\n  The file descriptor of the current file is invalid.\n<code>Errno::EINVAL</code>:: An invalid value for _advice_ was given.\n<code>Errno::ESPIPE</code>::\n  The file descriptor of the current file refers to a FIFO or\n  pipe. (Linux raises <code>Errno::EINVAL</code> in this case).\n<code>TypeError</code>::\n  Either _advice_ was not a Symbol, or one of the\n  other arguments was not an <code>Integer</code>.\n<code>RangeError</code>:: One of the arguments given was too big/small.\n\nThis list is not exhaustive; other Errno:: exceptions are also possible.",
  "ioctl": "Provides a mechanism for issuing low-level commands to control or\nquery I/O devices. Arguments and results are platform dependent. If\n<i>arg</i> is a number, its value is passed directly. If it is a\nstring, it is interpreted as a binary sequence of bytes. On Unix\nplatforms, see <code>ioctl(2)</code> for details. Not implemented on\nall platforms.",
  "fcntl": "Provides a mechanism for issuing low-level commands to control or\nquery file-oriented I/O streams. Arguments and results are platform\ndependent. If <i>arg</i> is a number, its value is passed\ndirectly. If it is a string, it is interpreted as a binary sequence\nof bytes (<code>Array#pack</code> might be a useful way to build this\nstring). On Unix platforms, see <code>fcntl(2)</code> for details.\nNot implemented on all platforms.",
  "pid": "Returns the process ID of a child process associated with\n<em>ios</em>. This will be set by <code>IO.popen</code>.\n\n   pipe = IO.popen(\"-\")\n   if pipe\n     $stderr.puts \"In parent, child pid is #{pipe.pid}\"\n   else\n     $stderr.puts \"In child, pid is #{$$}\"\n   end\n\n<em>produces:</em>\n\n   In child, pid is 26209\n   In parent, child pid is 26209",
  "inspect": "Return a string describing this IO object.",
  "external_encoding": "Returns the Encoding object that represents the encoding of the file.\nIf io is write mode and no encoding is specified, returns <code>nil</code>.",
  "internal_encoding": "Returns the Encoding of the internal string if conversion is\nspecified.  Otherwise returns nil.",
  "set_encoding": "If single argument is specified, read string from io is tagged\nwith the encoding specified.  If encoding is a colon separated two\nencoding names \"A:B\", the read string is converted from encoding A\n(external encoding) to encoding B (internal encoding), then tagged\nwith B.  If two arguments are specified, those must be encoding\nobjects or encoding names, and the first one is the external encoding, and the\nsecond one is the internal encoding.\nIf the external encoding and the internal encoding is specified,\noptional hash argument specify the conversion option.",
  "autoclose?": "Returns +true+ if the underlying file descriptor of _ios_ will be\nclosed automatically at its finalization, otherwise +false+.",
  "autoclose=": "Sets auto-close flag.\n\n   f = open(\"/dev/null\")\n   IO.for_fd(f.fileno)\n   # ...\n   f.gets # may cause IOError\n\n   f = open(\"/dev/null\")\n   IO.for_fd(f.fileno).autoclose = true\n   # ...\n   f.gets # won't cause IOError"
}