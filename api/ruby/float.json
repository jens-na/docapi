{
  "ROUNDS": "-1::\tIndeterminable\n0::\tRounding towards zero\n1::\tRounding to the nearest number\n2::\tRounding towards positive infinity\n3::\tRounding towards negative infinity",
  "RADIX": "The base of the floating point, or number of unique digits used to\nrepresent the number.\n\n Usually defaults to 2 on most systems, which would represent a base-10 decimal.",
  "MANT_DIG": "The number of base digits for the +double+ data type.\n\nUsually defaults to 53.",
  "DIG": "The number of decimal digits in a double-precision floating point.\n\nUsually defaults to 15.",
  "MIN_EXP": "The smallest posable exponent value in a double-precision floating\npoint.\n\nUsually defaults to -1021.",
  "MAX_EXP": "The largest possible exponent value in a double-precision floating\npoint.\n\nUsually defaults to 1024.",
  "MIN_10_EXP": "The smallest negative exponent in a double-precision floating point\nwhere 10 raised to this power minus 1.\n\nUsually defaults to -307.",
  "MAX_10_EXP": "The largest positive exponent in a double-precision floating point where\n10 raised to this power minus 1.\n\nUsually defaults to 308.",
  "MIN": "The smallest positive integer in a double-precision floating point.\n\nUsually defaults to 2.2250738585072014e-308.",
  "MAX": "The largest possible integer in a double-precision floating point number.\n\nUsually defaults to 1.7976931348623157e+308.",
  "EPSILON": "The difference between 1 and the smallest double-precision floating\npoint number.\n\nUsually defaults to 2.2204460492503131e-16.",
  "INFINITY": "An expression representing positive infinity.",
  "NAN": "An expression representing a value which is \"not a number\".",
  "to_s": "Returns a string containing a representation of self. As well as a fixed or\nexponential form of the +float+, the call may return +NaN+, +Infinity+, and\n+-Infinity+.",
  "inspect": "Returns a string containing a representation of self. As well as a fixed or\nexponential form of the +float+, the call may return +NaN+, +Infinity+, and\n+-Infinity+.",
  "coerce": "Returns an array with both a +numeric+ and a +float+ represented as Float\nobjects.\n\nThis is achieved by converting a +numeric+ to a Float.\n\n   1.2.coerce(3)       #=> [3.0, 1.2]\n   2.5.coerce(1.1)     #=> [1.1, 2.5]",
  "-@": "Returns float, negated.",
  "+": "Returns a new float which is the sum of +float+ and +other+.",
  "-": "Returns a new float which is the difference of +float+ and +other+.",
  "*": "Returns a new float which is the product of +float+ and +other+.",
  "/": "Returns a new float which is the result of dividing +float+ by +other+.",
  "quo": "Returns <code>float / numeric</code>, same as Float#/.",
  "fdiv": "Returns <code>float / numeric</code>, same as Float#/.",
  "%": "Return the modulo after division of +float+ by +other+.\n\n   6543.21.modulo(137)      #=> 104.21\n   6543.21.modulo(137.24)   #=> 92.9299999999996",
  "modulo": "Return the modulo after division of +float+ by +other+.\n\n   6543.21.modulo(137)      #=> 104.21\n   6543.21.modulo(137.24)   #=> 92.9299999999996",
  "divmod": "See Numeric#divmod.\n\n    42.0.divmod 6 #=> [7, 0.0]\n    42.0.divmod 5 #=> [8, 2.0]",
  "**": "Raises +float+ to the power of +other+.\n\n   2.0**3      #=> 8.0",
  "==": "Returns +true+ only if +obj+ has the same value as +float+. Contrast this\nwith Float#eql?, which requires obj to be a Float.\n\nThe result of <code>NaN == NaN</code> is undefined, so the\nimplementation-dependent value is returned.\n\n   1.0 == 1   #=> true",
  "===": "Returns +true+ only if +obj+ has the same value as +float+. Contrast this\nwith Float#eql?, which requires obj to be a Float.\n\nThe result of <code>NaN == NaN</code> is undefined, so the\nimplementation-dependent value is returned.\n\n   1.0 == 1   #=> true",
  "<=>": "Returns -1, 0, +1 or nil depending on whether +float+ is less than, equal\nto, or greater than +real+. This is the basis for the tests in Comparable.\n\nThe result of <code>NaN <=> NaN</code> is undefined, so the\nimplementation-dependent value is returned.\n\n+nil+ is returned if the two values are incomparable.",
  ">": "Returns +true+ if +float+ is greater than +real+.\n\nThe result of <code>NaN > NaN</code> is undefined, so the\nimplementation-dependent value is returned.",
  ">=": "Returns +true+ if +float+ is greater than or equal to +real+.\n\nThe result of <code>NaN >= NaN</code> is undefined, so the\nimplementation-dependent value is returned.",
  "<": "Returns +true+ if +float+ is less than +real+.\n\nThe result of <code>NaN < NaN</code> is undefined, so the\nimplementation-dependent value is returned.",
  "<=": "Returns +true+ if +float+ is less than or equal to +real+.\n\nThe result of <code>NaN <= NaN</code> is undefined, so the\nimplementation-dependent value is returned.",
  "eql?": "Returns +true+ only if +obj+ is a Float with the same value as +float+.\nContrast this with Float#==, which performs type conversions.\n\nThe result of <code>NaN.eql?(NaN)</code> is undefined, so the\nimplementation-dependent value is returned.\n\n   1.0.eql?(1)   #=> false",
  "hash": "Returns a hash code for this float.",
  "to_f": "Since +float+ is already a float, returns +self+.",
  "abs": "Returns the absolute value of +float+.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56",
  "magnitude": "Returns the absolute value of +float+.\n\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56",
  "zero?": "Returns +true+ if +float+ is 0.0.",
  "to_i": "Returns the +float+ truncated to an Integer.\n\nSynonyms are #to_i, #to_int, and #truncate.",
  "to_int": "Returns the +float+ truncated to an Integer.\n\nSynonyms are #to_i, #to_int, and #truncate.",
  "floor": "Returns the largest integer less than or equal to +float+.\n\n   1.2.floor      #=> 1\n   2.0.floor      #=> 2\n   (-1.2).floor   #=> -2\n   (-2.0).floor   #=> -2",
  "ceil": "Returns the smallest Integer greater than or equal to +float+.\n\n   1.2.ceil      #=> 2\n   2.0.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-2.0).ceil   #=> -2",
  "round": "Rounds +float+ to a given precision in decimal digits (default 0 digits).\n\nPrecision may be negative.  Returns a floating point number when +ndigits+\nis more than zero.\n\n   1.4.round      #=> 1\n   1.5.round      #=> 2\n   1.6.round      #=> 2\n   (-1.5).round   #=> -2\n\n   1.234567.round(2)  #=> 1.23\n   1.234567.round(3)  #=> 1.235\n   1.234567.round(4)  #=> 1.2346\n   1.234567.round(5)  #=> 1.23457\n\n   34567.89.round(-5) #=> 0\n   34567.89.round(-4) #=> 30000\n   34567.89.round(-3) #=> 35000\n   34567.89.round(-2) #=> 34600\n   34567.89.round(-1) #=> 34570\n   34567.89.round(0)  #=> 34568\n   34567.89.round(1)  #=> 34567.9\n   34567.89.round(2)  #=> 34567.89\n   34567.89.round(3)  #=> 34567.89",
  "truncate": "Returns the +float+ truncated to an Integer.\n\nSynonyms are #to_i, #to_int, and #truncate.",
  "nan?": "Returns +true+ if +float+ is an invalid IEEE floating point number.\n\n   a = -1.0      #=> -1.0\n   a.nan?        #=> false\n   a = 0.0/0.0   #=> NaN\n   a.nan?        #=> true",
  "infinite?": "Return values corresponding to the value of +float+:\n\n+finite+::\t    +nil+\n+-Infinity+::   +-1+\n++Infinity+::   +1+\n\nFor example:\n\n   (0.0).infinite?        #=> nil\n   (-1.0/0.0).infinite?   #=> -1\n   (+1.0/0.0).infinite?   #=> 1",
  "finite?": "Returns +true+ if +float+ is a valid IEEE floating point number (it is not\ninfinite, and Float#nan? is +false+).",
  "arg": "Returns 0 if the value is positive, pi otherwise.",
  "angle": "Returns 0 if the value is positive, pi otherwise.",
  "phase": "Returns 0 if the value is positive, pi otherwise.",
  "numerator": "Returns the numerator.  The result is machine dependent.\n\n   n = 0.3.numerator    #=> 5404319552844595\n   d = 0.3.denominator  #=> 18014398509481984\n   n.fdiv(d)            #=> 0.3",
  "denominator": "Returns the denominator (always positive).  The result is machine\ndependent.\n\nSee numerator.",
  "to_r": "Returns the value as a rational.\n\nNOTE: 0.3.to_r isn't the same as '0.3'.to_r.  The latter is\nequivalent to '3/10'.to_r, but the former isn't so.\n\n   2.0.to_r    #=> (2/1)\n   2.5.to_r    #=> (5/2)\n   -0.75.to_r  #=> (-3/4)\n   0.0.to_r    #=> (0/1)\n\nSee rationalize.",
  "rationalize": "Returns a simpler approximation of the value (flt-|eps| <= result\n<= flt+|eps|).  if the optional eps is not given, it will be chosen\nautomatically.\n\n   0.3.rationalize          #=> (3/10)\n   1.333.rationalize        #=> (1333/1000)\n   1.333.rationalize(0.01)  #=> (4/3)\n\nSee to_r."
}