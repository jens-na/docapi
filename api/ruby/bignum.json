{
  "to_s": "Returns a string containing the representation of <i>big</i> radix\n<i>base</i> (2 through 36).\n\n   12345654321.to_s         #=> \"12345654321\"\n   12345654321.to_s(2)      #=> \"1011011111110110111011110000110001\"\n   12345654321.to_s(8)      #=> \"133766736061\"\n   12345654321.to_s(16)     #=> \"2dfdbbc31\"\n   78546939656932.to_s(36)  #=> \"rubyrules\"",
  "inspect": "Returns a string containing the representation of <i>big</i> radix\n<i>base</i> (2 through 36).\n\n   12345654321.to_s         #=> \"12345654321\"\n   12345654321.to_s(2)      #=> \"1011011111110110111011110000110001\"\n   12345654321.to_s(8)      #=> \"133766736061\"\n   12345654321.to_s(16)     #=> \"2dfdbbc31\"\n   78546939656932.to_s(36)  #=> \"rubyrules\"",
  "coerce": "Returns an array with both a +numeric+ and a +big+ represented as Bignum\nobjects.\n\nThis is achieved by converting +numeric+ to a Bignum.\n\nA TypeError is raised if the +numeric+ is not a Fixnum or Bignum type.\n\n    (0x3FFFFFFFFFFFFFFF+1).coerce(42)   #=> [42, 4611686018427387904]",
  "-@": "Unary minus (returns an integer whose value is 0-big)",
  "+": "Adds big and other, returning the result.",
  "-": "Subtracts other from big, returning the result.",
  "*": "Multiplies big and other, returning the result.",
  "/": "Performs division: the class of the resulting object depends on\nthe class of <code>numeric</code> and on the magnitude of the\nresult.",
  "%": "Returns big modulo other. See Numeric.divmod for more\ninformation.",
  "div": "Performs integer division: returns integer value.",
  "divmod": "See <code>Numeric#divmod</code>.",
  "modulo": "Returns big modulo other. See Numeric.divmod for more\ninformation.",
  "remainder": "Returns the remainder after dividing <i>big</i> by <i>numeric</i>.\n\n   -1234567890987654321.remainder(13731)      #=> -6966\n   -1234567890987654321.remainder(13731.24)   #=> -9906.22531493148",
  "fdiv": "Returns the floating point result of dividing <i>big</i> by\n<i>numeric</i>.\n\n   -1234567890987654321.fdiv(13731)      #=> -89910996357705.5\n   -1234567890987654321.fdiv(13731.24)   #=> -89909424858035.7",
  "**": "Raises _big_ to the _exponent_ power (which may be an integer, float,\nor anything that will coerce to a number). The result may be\na Fixnum, Bignum, or Float\n\n  123456789 ** 2      #=> 15241578750190521\n  123456789 ** 1.2    #=> 5126464716.09932\n  123456789 ** -2     #=> 6.5610001194102e-17",
  "&": "Performs bitwise +and+ between _big_ and _numeric_.",
  "|": "Performs bitwise +or+ between _big_ and _numeric_.",
  "^": "Performs bitwise +exclusive or+ between _big_ and _numeric_.",
  "~": "Inverts the bits in big. As Bignums are conceptually infinite\nlength, the result acts as if it had an infinite number of one\nbits to the left. In hex representations, this is displayed\nas two periods to the left of the digits.\n\n  sprintf(\"%X\", ~0x1122334455)    #=> \"..FEEDDCCBBAA\"",
  "<<": "Shifts big left _numeric_ positions (right if _numeric_ is negative).",
  ">>": "Shifts big right _numeric_ positions (left if _numeric_ is negative).",
  "[]": "Bit Reference---Returns the <em>n</em>th bit in the (assumed) binary\nrepresentation of <i>big</i>, where <i>big</i>[0] is the least\nsignificant bit.\n\n   a = 9**15\n   50.downto(0) do |n|\n     print a[n]\n   end\n\n<em>produces:</em>\n\n   000101110110100000111000011110010100111100010111001",
  "<=>": "Comparison---Returns -1, 0, or +1 depending on whether +big+ is\nless than, equal to, or greater than +numeric+. This is the\nbasis for the tests in Comparable.\n\n+nil+ is returned if the two values are incomparable.",
  "==": "Returns <code>true</code> only if <i>obj</i> has the same value\nas <i>big</i>. Contrast this with <code>Bignum#eql?</code>, which\nrequires <i>obj</i> to be a <code>Bignum</code>.\n\n   68719476736 == 68719476736.0   #=> true",
  ">": "Returns <code>true</code> if the value of <code>big</code> is\ngreater than that of <code>real</code>.",
  ">=": "Returns <code>true</code> if the value of <code>big</code> is\ngreater than or equal to that of <code>real</code>.",
  "<": "Returns <code>true</code> if the value of <code>big</code> is\nless than that of <code>real</code>.",
  "<=": "Returns <code>true</code> if the value of <code>big</code> is\nless than or equal to that of <code>real</code>.",
  "===": "Returns <code>true</code> only if <i>obj</i> has the same value\nas <i>big</i>. Contrast this with <code>Bignum#eql?</code>, which\nrequires <i>obj</i> to be a <code>Bignum</code>.\n\n   68719476736 == 68719476736.0   #=> true",
  "eql?": "Returns <code>true</code> only if <i>obj</i> is a\n<code>Bignum</code> with the same value as <i>big</i>. Contrast this\nwith <code>Bignum#==</code>, which performs type conversions.\n\n   68719476736.eql?(68719476736.0)   #=> false",
  "hash": "Compute a hash based on the value of _big_.",
  "to_f": "Converts <i>big</i> to a <code>Float</code>. If <i>big</i> doesn't\nfit in a <code>Float</code>, the result is infinity.",
  "abs": "Returns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321",
  "magnitude": "Returns the absolute value of <i>big</i>.\n\n   -1234567890987654321.abs   #=> 1234567890987654321",
  "size": "Returns the number of bytes in the machine representation of\n<i>big</i>.\n\n   (256**10 - 1).size   #=> 12\n   (256**20 - 1).size   #=> 20\n   (256**40 - 1).size   #=> 40",
  "bit_length": "Returns the number of bits of the value of <i>int</i>.\n\n\"the number of bits\" means that\nthe bit position of the highest bit which is different to the sign bit.\n(The bit position of the bit 2**n is n+1.)\nIf there is no such bit (zero or minus one), zero is returned.\n\nI.e. This method returns ceil(log2(int < 0 ? -int : int+1)).\n\n   (-2**10000-1).bit_length  #=> 10001\n   (-2**10000).bit_length    #=> 10000\n   (-2**10000+1).bit_length  #=> 10000\n\n   (-2**1000-1).bit_length   #=> 1001\n   (-2**1000).bit_length     #=> 1000\n   (-2**1000+1).bit_length   #=> 1000\n\n   (2**1000-1).bit_length    #=> 1000\n   (2**1000).bit_length      #=> 1001\n   (2**1000+1).bit_length    #=> 1001\n\n   (2**10000-1).bit_length   #=> 10000\n   (2**10000).bit_length     #=> 10001\n   (2**10000+1).bit_length   #=> 10001",
  "odd?": "Returns <code>true</code> if <i>big</i> is an odd number.",
  "even?": "Returns <code>true</code> if <i>big</i> is an even number.",
  "GMP_VERSION": "",
  "SIZEOF_BDIGITS": "",
  "BITSPERDIG": ""
}