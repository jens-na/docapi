{
  "singleton_method_added": "Trap attempts to add methods to Numeric objects. Always raises a TypeError.\n\nNumerics should be values; singleton_methods should not be added to them.",
  "initialize_copy": "Numerics are immutable values, which should not be copied.\n\nAny attempt to use this method on a Numeric will raise a TypeError.",
  "coerce": "If a +numeric is the same type as +num+, returns an array containing\n+numeric+ and +num+. Otherwise, returns an array with both a +numeric+ and\n+num+ represented as Float objects.\n\nThis coercion mechanism is used by Ruby to handle mixed-type numeric\noperations: it is intended to find a compatible common type between the two\noperands of the operator.\n\n   1.coerce(2.5)   #=> [2.5, 1.0]\n   1.2.coerce(3)   #=> [3.0, 1.2]\n   1.coerce(2)     #=> [2, 1]",
  "i": "Returns the corresponding imaginary number.\nNot available for complex numbers.",
  "+@": "Unary Plus---Returns the receiver's value.",
  "-@": "Unary Minus---Returns the receiver's value, negated.",
  "<=>": "Returns zero if +number+ equals +other+, otherwise +nil+ is returned if the\ntwo values are incomparable.",
  "eql?": "Returns +true+ if +num+ and +numeric+ are the same type and have equal\nvalues.\n\n   1 == 1.0          #=> true\n   1.eql?(1.0)       #=> false\n   (1.0).eql?(1.0)   #=> true",
  "fdiv": "Returns float division.",
  "div": "Uses +/+ to perform division, then converts the result to an integer.\n+numeric+ does not define the +/+ operator; this is left to subclasses.\n\nEquivalent to <code>num.divmod(numeric)[0]</code>.\n\nSee Numeric#divmod.",
  "divmod": "Returns an array containing the quotient and modulus obtained by dividing\n+num+ by +numeric+.\n\nIf <code>q, r = * x.divmod(y)</code>, then\n\n    q = floor(x/y)\n    x = q*y+r\n\nThe quotient is rounded toward -infinity, as shown in the following table:\n\n   a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)\n  ------+-----+---------------+---------+-------------+---------------\n   13   |  4  |   3,    1     |   3     |    1        |     1\n  ------+-----+---------------+---------+-------------+---------------\n   13   | -4  |  -4,   -3     |  -4     |   -3        |     1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   |  4  |  -4,    3     |  -4     |    3        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n  -13   | -4  |   3,   -1     |   3     |   -1        |    -1\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 |  4  |   2,    3.5   |   2.875 |    3.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n   11.5 | -4  |  -3,   -0.5   |  -2.875 |   -0.5      |     3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 |  4  |  -3,    0.5   |  -2.875 |    0.5      |    -3.5\n  ------+-----+---------------+---------+-------------+---------------\n  -11.5 | -4  |   2,   -3.5   |   2.875 |   -3.5      |    -3.5\n\n\nExamples\n\n   11.divmod(3)         #=> [3, 2]\n   11.divmod(-3)        #=> [-4, -1]\n   11.divmod(3.5)       #=> [3, 0.5]\n   (-11).divmod(3.5)    #=> [-4, 3.0]\n   (11.5).divmod(3.5)   #=> [3, 1.0]",
  "%": "x.modulo(y) means x-y*(x/y).floor\n\nEquivalent to <code>num.divmod(numeric)[1]</code>.\n\nSee Numeric#divmod.",
  "modulo": "x.modulo(y) means x-y*(x/y).floor\n\nEquivalent to <code>num.divmod(numeric)[1]</code>.\n\nSee Numeric#divmod.",
  "remainder": "x.remainder(y) means x-y*(x/y).truncate\n\nSee Numeric#divmod.",
  "abs": "Returns the absolute value of +num+.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n\nNumeric#magnitude is an alias of Numeric#abs.",
  "magnitude": "Returns the absolute value of +num+.\n\n   12.abs         #=> 12\n   (-34.56).abs   #=> 34.56\n   -34.56.abs     #=> 34.56\n\nNumeric#magnitude is an alias of Numeric#abs.",
  "to_int": "Invokes the child class's +to_i+ method to convert +num+ to an integer.\n\n    1.0.class => Float\n    1.0.to_int.class => Fixnum\n    1.0.to_i.class => Fixnum",
  "real?": "Returns +true+ if +num+ is a Real number. (i.e. not Complex).",
  "integer?": "Returns +true+ if +num+ is an Integer (including Fixnum and Bignum).\n\n    (1.0).integer? #=> false\n    (1).integer?   #=> true",
  "zero?": "Returns +true+ if +num+ has a zero value.",
  "nonzero?": "Returns +self+ if +num+ is not zero, +nil+ otherwise.\n\nThis behavior is useful when chaining comparisons:\n\n   a = %w( z Bb bB bb BB a aA Aa AA A )\n   b = a.sort {|a,b| (a.downcase <=> b.downcase).nonzero? || a <=> b }\n   b   #=> [\"A\", \"a\", \"AA\", \"Aa\", \"aA\", \"BB\", \"Bb\", \"bB\", \"bb\", \"z\"]",
  "floor": "Returns the largest integer less than or equal to +num+.\n\nNumeric implements this by converting an Integer to a Float and invoking\nFloat#floor.\n\n   1.floor      #=> 1\n   (-1).floor   #=> -1",
  "ceil": "Returns the smallest possible Integer that is greater than or equal to\n+num+.\n\nNumeric achieves this by converting itself to a Float then invoking\nFloat#ceil.\n\n   1.ceil        #=> 1\n   1.2.ceil      #=> 2\n   (-1.2).ceil   #=> -1\n   (-1.0).ceil   #=> -1",
  "round": "Rounds +num+ to a given precision in decimal digits (default 0 digits).\n\nPrecision may be negative.  Returns a floating point number when +ndigits+\nis more than zero.\n\nNumeric implements this by converting itself to a Float and invoking\nFloat#round.",
  "truncate": "Returns +num+ truncated to an Integer.\n\nNumeric implements this by converting its value to a Float and invoking\nFloat#truncate.",
  "step": "Invokes the given block with the sequence of numbers starting at +num+,\nincremented by +step+ (defaulted to +1+) on each call.\n\nThe loop finishes when the value to be passed to the block is greater than\n+limit+ (if +step+ is positive) or less than +limit+ (if +step+ is\nnegative), where <i>limit</i> is defaulted to infinity.\n\nIn the recommended keyword argument style, either or both of\n+step+ and +limit+ (default infinity) can be omitted.  In the\nfixed position argument style, integer zero as a step\n(i.e. num.step(limit, 0)) is not allowed for historical\ncompatibility reasons.\n\nIf all the arguments are integers, the loop operates using an integer\ncounter.\n\nIf any of the arguments are floating point numbers, all are converted to floats, and the loop is executed the following expression:\n\nfloor(n + n*epsilon)+ 1\n\nWhere the +n+ is the following:\n\nn = (limit - num)/step\n\nOtherwise, the loop starts at +num+, uses either the less-than (<) or\ngreater-than (>) operator to compare the counter against +limit+, and\nincrements itself using the <code>+</code> operator.\n\nIf no block is given, an Enumerator is returned instead.\n\nFor example:\n\n   p 1.step.take(4)\n   p 10.step(by: -1).take(4)\n   3.step(to: 5) { |i| print i, \" \" }\n   1.step(10, 2) { |i| print i, \" \" }\n   Math::E.step(to: Math::PI, by: 0.2) { |f| print f, \" \" }\n\nWill produce:\n\n   [1, 2, 3, 4]\n   [10, 9, 8, 7]\n   3 4 5\n   1 3 5 7 9\n   2.71828182845905 2.91828182845905 3.11828182845905",
  "to_c": "Returns the value as a complex.",
  "real": "Returns self.",
  "imaginary": "Returns zero.",
  "imag": "Returns zero.",
  "abs2": "Returns square of self.",
  "arg": "Returns 0 if the value is positive, pi otherwise.",
  "angle": "Returns 0 if the value is positive, pi otherwise.",
  "phase": "Returns 0 if the value is positive, pi otherwise.",
  "rectangular": "Returns an array; [num, 0].",
  "rect": "Returns an array; [num, 0].",
  "polar": "Returns an array; [num.abs, num.arg].",
  "conjugate": "Returns self.",
  "conj": "Returns self.",
  "numerator": "Returns the numerator.",
  "denominator": "Returns the denominator (always positive).",
  "quo": "Returns most exact division (rational for integers, float for floats)."
}