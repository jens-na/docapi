{
  "initialize": "Creates a new UDPSocket object.\n\n_address_family_ should be an integer, a string or a symbol:\nSocket::AF_INET, \"AF_INET\", :INET, etc.\n\n  UDPSocket.new                   #=> #<UDPSocket:fd 3>\n  UDPSocket.new(Socket::AF_INET6) #=> #<UDPSocket:fd 4>",
  "connect": "Connects _udpsocket_ to _host_:_port_.\n\nThis makes possible to send without destination address.\n\n  u1 = UDPSocket.new\n  u1.bind(\"127.0.0.1\", 4913)\n  u2 = UDPSocket.new\n  u2.connect(\"127.0.0.1\", 4913)\n  u2.send \"uuuu\", 0\n  p u1.recvfrom(10) #=> [\"uuuu\", [\"AF_INET\", 33230, \"localhost\", \"127.0.0.1\"]]",
  "bind": "Binds _udpsocket_ to _host_:_port_.\n\n  u1 = UDPSocket.new\n  u1.bind(\"127.0.0.1\", 4913)\n  u1.send \"message-to-self\", 0, \"127.0.0.1\", 4913\n  p u1.recvfrom(10) #=> [\"message-to\", [\"AF_INET\", 4913, \"localhost\", \"127.0.0.1\"]]",
  "send": "Sends _mesg_ via _udpsocket_.\n\n_flags_ should be a bitwise OR of Socket::MSG_* constants.\n\n  u1 = UDPSocket.new\n  u1.bind(\"127.0.0.1\", 4913)\n\n  u2 = UDPSocket.new\n  u2.send \"hi\", 0, \"127.0.0.1\", 4913\n\n  mesg, addr = u1.recvfrom(10)\n  u1.send mesg, 0, addr[3], addr[1]\n\n  p u2.recv(100) #=> \"hi\"",
  "recvfrom_nonblock": "Receives up to _maxlen_ bytes from +udpsocket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIf _maxlen_ is omitted, its default value is 65536.\n_flags_ is zero or more of the +MSG_+ options.\nThe first element of the results, _mesg_, is the data received.\nThe second element, _sender_inet_addr_, is an array to represent the sender address.\n\nWhen recvfrom(2) returns 0,\nSocket#recvfrom_nonblock returns an empty string as data.\nIt means an empty packet.\n\n=== Parameters\n* +maxlen+ - the number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n\trequire 'socket'\n\ts1 = UDPSocket.new\n\ts1.bind(\"127.0.0.1\", 0)\n\ts2 = UDPSocket.new\n\ts2.bind(\"127.0.0.1\", 0)\n\ts2.connect(*s1.addr.values_at(3,1))\n\ts1.connect(*s2.addr.values_at(3,1))\n\ts1.send \"aaa\", 0\n\tbegin # emulate blocking recvfrom\n\t  p s2.recvfrom_nonblock(10)  #=> [\"aaa\", [\"AF_INET\", 33302, \"localhost.localdomain\", \"127.0.0.1\"]]\n\trescue IO::WaitReadable\n\t  IO.select([s2])\n\t  retry\n\tend\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recvfrom_nonblock_ fails.\n\nUDPSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying recvfrom_nonblock.\n\n=== See\n* Socket#recvfrom"
}