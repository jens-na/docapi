{
  "nil?": "Only the object <i>nil</i> responds <code>true</code> to <code>nil?</code>.",
  "===": "Case Equality -- For class Object, effectively the same as calling\n<code>#==</code>, but typically overridden by descendants to provide\nmeaningful semantics in +case+ statements.",
  "=~": "Pattern Match---Overridden by descendants (notably\n<code>Regexp</code> and <code>String</code>) to provide meaningful\npattern-match semantics.",
  "!~": "Returns true if two objects do not match (using the <i>=~</i>\nmethod), otherwise false.",
  "eql?": "Equality --- At the <code>Object</code> level, <code>==</code> returns\n<code>true</code> only if +obj+ and +other+ are the same object.\nTypically, this method is overridden in descendant classes to provide\nclass-specific meaning.\n\nUnlike <code>==</code>, the <code>equal?</code> method should never be\noverridden by subclasses as it is used to determine object identity\n(that is, <code>a.equal?(b)</code> if and only if <code>a</code> is the\nsame object as <code>b</code>):\n\n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n\nThe <code>eql?</code> method returns <code>true</code> if +obj+ and\n+other+ refer to the same hash key.  This is used by Hash to test members\nfor equality.  For objects of class <code>Object</code>, <code>eql?</code>\nis synonymous with <code>==</code>.  Subclasses normally continue this\ntradition by aliasing <code>eql?</code> to their overridden <code>==</code>\nmethod, but there are exceptions.  <code>Numeric</code> types, for\nexample, perform type conversion across <code>==</code>, but not across\n<code>eql?</code>, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false",
  "hash": "Generates a Fixnum hash value for this object.  This function must have the\nproperty that <code>a.eql?(b)</code> implies <code>a.hash == b.hash</code>.\n\nThe hash value is used along with #eql? by the Hash class to determine if\ntwo objects reference the same hash key.  Any hash value that exceeds the\ncapacity of a Fixnum will be truncated before being used.\n\nThe hash value for an object may not be identical across invocations or\nimplementations of ruby.  If you need a stable identifier across ruby\ninvocations and implementations you will need to generate one with a custom\nmethod.",
  "<=>": "Returns 0 if +obj+ and +other+ are the same object\nor <code>obj == other</code>, otherwise nil.\n\nThe <=> is used by various methods to compare objects, for example\nEnumerable#sort, Enumerable#max etc.\n\nYour implementation of <=> should return one of the following values: -1, 0,\n1 or nil. -1 means self is smaller than other. 0 means self is equal to other.\n1 means self is bigger than other. Nil means the two values could not be\ncompared.\n\nWhen you define <=>, you can include Comparable to gain the methods <=, <,\n==, >=, > and between?.",
  "class": "Returns the class of <i>obj</i>. This method must always be\ncalled with an explicit receiver, as <code>class</code> is also a\nreserved word in Ruby.\n\n   1.class      #=> Fixnum\n   self.class   #=> Object",
  "singleton_class": "Returns the singleton class of <i>obj</i>.  This method creates\na new singleton class if <i>obj</i> does not have it.\n\nIf <i>obj</i> is <code>nil</code>, <code>true</code>, or\n<code>false</code>, it returns NilClass, TrueClass, or FalseClass,\nrespectively.\nIf <i>obj</i> is a Fixnum or a Symbol, it raises a TypeError.\n\n   Object.new.singleton_class  #=> #<Class:#<Object:0xb7ce1e24>>\n   String.singleton_class      #=> #<Class:String>\n   nil.singleton_class         #=> NilClass",
  "clone": "Produces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference. Copies\nthe frozen and tainted state of <i>obj</i>. See also the discussion\nunder <code>Object#dup</code>.\n\n   class Klass\n      attr_accessor :str\n   end\n   s1 = Klass.new      #=> #<Klass:0x401b3a38>\n   s1.str = \"Hello\"    #=> \"Hello\"\n   s2 = s1.clone       #=> #<Klass:0x401b3998 @str=\"Hello\">\n   s2.str[1,4] = \"i\"   #=> \"i\"\n   s1.inspect          #=> \"#<Klass:0x401b3a38 @str=\\\"Hi\\\">\"\n   s2.inspect          #=> \"#<Klass:0x401b3998 @str=\\\"Hi\\\">\"\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.",
  "dup": "Produces a shallow copy of <i>obj</i>---the instance variables of\n<i>obj</i> are copied, but not the objects they reference. <code>dup</code>\ncopies the tainted state of <i>obj</i>.\n\nThis method may have class-specific behavior.  If so, that\nbehavior will be documented under the #+initialize_copy+ method of\nthe class.\n\n=== on dup vs clone\n\nIn general, <code>clone</code> and <code>dup</code> may have different\nsemantics in descendant classes. While <code>clone</code> is used to\nduplicate an object, including its internal state, <code>dup</code>\ntypically uses the class of the descendant object to create the new\ninstance.\n\nWhen using #dup any modules that the object has been extended with will not\nbe copied.\n\nclass Klass\n attr_accessor :str\nend\n\nmodule Foo\n def foo; 'foo'; end\nend\n\ns1 = Klass.new #=> #<Klass:0x401b3a38>\ns1.extend(Foo) #=> #<Klass:0x401b3a38>\ns1.foo #=> \"foo\"\n\ns2 = s1.clone #=> #<Klass:0x401b3a38>\ns2.foo #=> \"foo\"\n\ns3 = s1.dup #=> #<Klass:0x401b3a38>\ns3.foo #=> NoMethodError: undefined method `foo' for #<Klass:0x401b3a38>",
  "initialize_copy": ":nodoc:",
  "initialize_dup": ":nodoc:",
  "initialize_clone": ":nodoc:",
  "taint": "Mark the object as tainted.\n\nObjects that are marked as tainted will be restricted from various built-in\nmethods. This is to prevent insecure data, such as command-line arguments\nor strings read from Kernel#gets, from inadvertently compromising the users\nsystem.\n\nTo check whether an object is tainted, use #tainted?\n\nYou should only untaint a tainted object if your code has inspected it and\ndetermined that it is safe. To do so use #untaint\n\nIn $SAFE level 3, all newly created objects are tainted and you can't untaint\nobjects.",
  "tainted?": "Returns true if the object is tainted.\n\nSee #taint for more information.",
  "untaint": "Removes the tainted mark from the object.\n\nSee #taint for more information.",
  "untrust": "Deprecated method that is equivalent to #taint.",
  "untrusted?": "Deprecated method that is equivalent to #tainted?.",
  "trust": "Deprecated method that is equivalent to #untaint.",
  "freeze": "Prevents further modifications to <i>obj</i>. A\n<code>RuntimeError</code> will be raised if modification is attempted.\nThere is no way to unfreeze a frozen object. See also\n<code>Object#frozen?</code>.\n\nThis method returns self.\n\n   a = [ \"a\", \"b\", \"c\" ]\n   a.freeze\n   a << \"z\"\n\n<em>produces:</em>\n\n   prog.rb:3:in `<<': can't modify frozen array (RuntimeError)\n   \tfrom prog.rb:3",
  "frozen?": "Returns the freeze status of <i>obj</i>.\n\n   a = [ \"a\", \"b\", \"c\" ]\n   a.freeze    #=> [\"a\", \"b\", \"c\"]\n   a.frozen?   #=> true",
  "to_s": "Returns a string representing <i>obj</i>. The default\n<code>to_s</code> prints the object's class and an encoding of the\nobject id. As a special case, the top-level object that is the\ninitial execution context of Ruby programs returns ``main.''",
  "inspect": "Returns a string containing a human-readable representation of <i>obj</i>.\nBy default, show the class name and the list of the instance variables and\ntheir values (by calling #inspect on each of them).\nUser defined classes should override this method to make better\nrepresentation of <i>obj</i>.  When overriding this method, it should\nreturn a string whose encoding is compatible with the default external\nencoding.\n\n   [ 1, 2, 3..4, 'five' ].inspect   #=> \"[1, 2, 3..4, \\\"five\\\"]\"\n   Time.new.inspect                 #=> \"2008-03-08 19:43:39 +0900\"\n\n   class Foo\n   end\n   Foo.new.inspect                  #=> \"#<Foo:0x0300c868>\"\n\n   class Bar\n     def initialize\n       @bar = 1\n     end\n   end\n   Bar.new.inspect                  #=> \"#<Bar:0x0300c868 @bar=1>\"\n\n   class Baz\n     def to_s\n       \"baz\"\n     end\n   end\n   Baz.new.inspect                  #=> \"#<Baz:0x0300c868>\"",
  "methods": "Returns a list of the names of public and protected methods of\n<i>obj</i>. This will include all the methods accessible in\n<i>obj</i>'s ancestors.\nIf the <i>regular</i> parameter is set to <code>false</code>,\nReturns an array of obj's public and protected singleton methods,\nthe array will not include methods in modules included in <i>obj</i>.\n\n   class Klass\n     def klass_method()\n     end\n   end\n   k = Klass.new\n   k.methods[0..9]    #=> [:klass_method, :nil?, :===,\n                      #    :==~, :!, :eql?\n                      #    :hash, :<=>, :class, :singleton_class]\n   k.methods.length   #=> 57\n\n   k.methods(false)   #=> []\n   def k.singleton_method; end\n   k.methods(false)   #=> [:singleton_method]\n\n   module M123; def m123; end end\n   k.extend M123\n   k.methods(false)   #=> [:singleton_method]",
  "singleton_methods": "Returns an array of the names of singleton methods for <i>obj</i>.\nIf the optional <i>all</i> parameter is true, the list will include\nmethods in modules included in <i>obj</i>.\nOnly public and protected singleton methods are returned.\n\n   module Other\n     def three() end\n   end\n\n   class Single\n     def Single.four() end\n   end\n\n   a = Single.new\n\n   def a.one()\n   end\n\n   class << a\n     include Other\n     def two()\n     end\n   end\n\n   Single.singleton_methods    #=> [:four]\n   a.singleton_methods(false)  #=> [:two, :one]\n   a.singleton_methods         #=> [:two, :one, :three]",
  "protected_methods": "Returns the list of protected methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to <code>false</code>, only those methods\nin the receiver will be listed.",
  "private_methods": "Returns the list of private methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to <code>false</code>, only those methods\nin the receiver will be listed.",
  "public_methods": "Returns the list of public methods accessible to <i>obj</i>. If\nthe <i>all</i> parameter is set to <code>false</code>, only those methods\nin the receiver will be listed.",
  "instance_variables": "",
  "instance_variable_get": "Returns the value of the given instance variable, or nil if the\ninstance variable is not set. The <code>@</code> part of the\nvariable name should be included for regular instance\nvariables. Throws a <code>NameError</code> exception if the\nsupplied symbol is not valid as an instance variable name.\nString arguments are converted to symbols.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_get(:@a)    #=> \"cat\"\n   fred.instance_variable_get(\"@b\")   #=> 99",
  "instance_variable_set": "Sets the instance variable names by <i>symbol</i> to\n<i>object</i>, thereby frustrating the efforts of the class's\nauthor to attempt to provide proper encapsulation. The variable\ndid not have to exist prior to this call.\nIf the instance variable name is passed as a string, that string\nis converted to a symbol.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_set(:@a, 'dog')   #=> \"dog\"\n   fred.instance_variable_set(:@c, 'cat')   #=> \"cat\"\n   fred.inspect                             #=> \"#<Fred:0x401b3da8 @a=\\\"dog\\\", @b=99, @c=\\\"cat\\\">\"",
  "instance_variable_defined?": "Returns <code>true</code> if the given instance variable is\ndefined in <i>obj</i>.\nString arguments are converted to symbols.\n\n   class Fred\n     def initialize(p1, p2)\n       @a, @b = p1, p2\n     end\n   end\n   fred = Fred.new('cat', 99)\n   fred.instance_variable_defined?(:@a)    #=> true\n   fred.instance_variable_defined?(\"@b\")   #=> true\n   fred.instance_variable_defined?(\"@c\")   #=> false",
  "remove_instance_variable": "",
  "instance_of?": "Returns <code>true</code> if <i>obj</i> is an instance of the given\nclass. See also <code>Object#kind_of?</code>.\n\n   class A;     end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.instance_of? A   #=> false\n   b.instance_of? B   #=> true\n   b.instance_of? C   #=> false",
  "kind_of?": "Returns <code>true</code> if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true",
  "is_a?": "Returns <code>true</code> if <i>class</i> is the class of\n<i>obj</i>, or if <i>class</i> is one of the superclasses of\n<i>obj</i> or modules included in <i>obj</i>.\n\n   module M;    end\n   class A\n     include M\n   end\n   class B < A; end\n   class C < B; end\n\n   b = B.new\n   b.is_a? A          #=> true\n   b.is_a? B          #=> true\n   b.is_a? C          #=> false\n   b.is_a? M          #=> true\n\n   b.kind_of? A       #=> true\n   b.kind_of? B       #=> true\n   b.kind_of? C       #=> false\n   b.kind_of? M       #=> true",
  "tap": "Yields <code>x</code> to the block, and then returns <code>x</code>.\nThe primary purpose of this method is to \"tap into\" a method chain,\nin order to perform operations on intermediate results within the chain.\n\n(1..10)                .tap {|x| puts \"original: #{x.inspect}\"}\n .to_a                .tap {|x| puts \"array: #{x.inspect}\"}\n .select {|x| x%2==0} .tap {|x| puts \"evens: #{x.inspect}\"}\n .map { |x| x*x }     .tap {|x| puts \"squares: #{x.inspect}\"}",
  "send": "Invokes the method identified by _symbol_, passing it any\n arguments specified. You can use <code>__send__</code> if the name\n +send+ clashes with an existing method in _obj_.\n When the method is identified by a string, the string is converted\n to a symbol.\n\n    class Klass\n      def hello(*args)\n        \"Hello \" + args.join(' ')\n      end\n    end\n    k = Klass.new\n    k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"",
  "public_send": "Invokes the method identified by _symbol_, passing it any\narguments specified. Unlike send, public_send calls public\nmethods only.\nWhen the method is identified by a string, the string is converted\nto a symbol.\n\n   1.public_send(:puts, \"hello\")  # causes NoMethodError",
  "respond_to?": "Returns +true+ if _obj_ responds to the given method.  Private and\nprotected methods are included in the search only if the optional\nsecond parameter evaluates to +true+.\n\nIf the method is not implemented,\nas Process.fork on Windows, File.lchmod on GNU/Linux, etc.,\nfalse is returned.\n\nIf the method is not defined, <code>respond_to_missing?</code>\nmethod is called and the result is returned.\n\nWhen the method name parameter is given as a string, the string is\nconverted to a symbol.",
  "respond_to_missing?": "DO NOT USE THIS DIRECTLY.\n\nHook method to return whether the _obj_ can respond to _id_ method\nor not.\n\nWhen the method name parameter is given as a string, the string is\nconverted to a symbol.\n\nSee #respond_to?, and the example of BasicObject.",
  "to_enum": "Creates a new Enumerator which will enumerate by calling +method+ on\n+obj+, passing +args+ if any.\n\nIf a block is given, it will be used to calculate the size of\nthe enumerator without the need to iterate it (see Enumerator#size).\n\n=== Examples\n\n  str = \"xyz\"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n  # => 120\n  # => 121\n  # => 122\n\n  # protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n\nIt is typical to call to_enum when defining methods for\na generic Enumerable, in case no block is passed.\n\nHere is such an example, with parameter passing and a sizing block:\n\n  module Enumerable\n    # a generic method to repeat the values of any enumerable\n    def repeat(n)\n      raise ArgumentError, \"#{n} is negative!\" if n < 0\n      unless block_given?\n        return to_enum(__method__, n) do # __method__ is :repeat here\n          sz = size     # Call size and multiply by n...\n          sz * n if sz  # but return nil if size itself is nil\n        end\n      end\n      each do |*val|\n        n.times { yield *val }\n      end\n    end\n  end\n\n  %i[hello world].repeat(2) { |w| puts w }\n    # => Prints 'hello', 'hello', 'world', 'world'\n  enum = (1..14).repeat(3)\n    # => returns an Enumerator when called without a block\n  enum.first(4) # => [1, 1, 1, 2]\n  enum.size # => 42",
  "enum_for": "Creates a new Enumerator which will enumerate by calling +method+ on\n+obj+, passing +args+ if any.\n\nIf a block is given, it will be used to calculate the size of\nthe enumerator without the need to iterate it (see Enumerator#size).\n\n=== Examples\n\n  str = \"xyz\"\n\n  enum = str.enum_for(:each_byte)\n  enum.each { |b| puts b }\n  # => 120\n  # => 121\n  # => 122\n\n  # protect an array from being modified by some_method\n  a = [1, 2, 3]\n  some_method(a.to_enum)\n\nIt is typical to call to_enum when defining methods for\na generic Enumerable, in case no block is passed.\n\nHere is such an example, with parameter passing and a sizing block:\n\n  module Enumerable\n    # a generic method to repeat the values of any enumerable\n    def repeat(n)\n      raise ArgumentError, \"#{n} is negative!\" if n < 0\n      unless block_given?\n        return to_enum(__method__, n) do # __method__ is :repeat here\n          sz = size     # Call size and multiply by n...\n          sz * n if sz  # but return nil if size itself is nil\n        end\n      end\n      each do |*val|\n        n.times { yield *val }\n      end\n    end\n  end\n\n  %i[hello world].repeat(2) { |w| puts w }\n    # => Prints 'hello', 'hello', 'world', 'world'\n  enum = (1..14).repeat(3)\n    # => returns an Enumerator when called without a block\n  enum.first(4) # => [1, 1, 1, 2]\n  enum.size # => 42",
  "assert_Qundef": ":nodoc:",
  "rawVALUE": ":nodoc:",
  "validate_object": ":nodoc:",
  "rb_fatal": "",
  "RB_WAITFD_IN": "",
  "RB_WAITFD_OUT": "",
  "RB_WAITFD_PRI": "",
  "extend": "Adds to _obj_ the instance methods from each module given as a\nparameter.\n\n   module Mod\n     def hello\n       \"Hello from Mod.\\n\"\n     end\n   end\n\n   class Klass\n     def hello\n       \"Hello from Klass.\\n\"\n     end\n   end\n\n   k = Klass.new\n   k.hello         #=> \"Hello from Klass.\\n\"\n   k.extend(Mod)   #=> #<Klass:0x401b3bc8>\n   k.hello         #=> \"Hello from Mod.\\n\"",
  "method": "Looks up the named method as a receiver in <i>obj</i>, returning a\n<code>Method</code> object (or raising <code>NameError</code>). The\n<code>Method</code> object acts as a closure in <i>obj</i>'s object\ninstance, so instance variables and the value of <code>self</code>\nremain available.\n\n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       \"Hello, @iv = #{@iv}\"\n     end\n   end\n\n   k = Demo.new(99)\n   m = k.method(:hello)\n   m.call   #=> \"Hello, @iv = 99\"\n\n   l = Demo.new('Fred')\n   m = l.method(\"hello\")\n   m.call   #=> \"Hello, @iv = Fred\"",
  "public_method": "Similar to _method_, searches public method only.",
  "singleton_method": "Similar to _method_, searches singleton method only.\n\n   class Demo\n     def initialize(n)\n       @iv = n\n     end\n     def hello()\n       \"Hello, @iv = #{@iv}\"\n     end\n   end\n\n   k = Demo.new(99)\n   def k.hi\n     \"Hi, @iv = #{@iv}\"\n   end\n   m = k.singleton_method(:hi)\n   m.call   #=> \"Hi, @iv = 99\"\n   m = k.singleton_method(:hello) #=> NameError",
  "define_singleton_method": "Defines a singleton method in the receiver. The _method_\nparameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object.\nIf a block is specified, it is used as the method body.\n\n   class A\n     class << self\n       def class_name\n         to_s\n       end\n     end\n   end\n   A.define_singleton_method(:who_am_i) do\n     \"I am: #{class_name}\"\n   end\n   A.who_am_i   # ==> \"I am: A\"\n\n   guy = \"Bob\"\n   guy.define_singleton_method(:hello) { \"#{self}: Hello there!\" }\n   guy.hello    #=>  \"Bob: Hello there!\"",
  "object_id": "Generates a Fixnum hash value for this object.\n\nThis function must have the property that <code>a.eql?(b)</code> implies\n<code>a.hash == b.hash</code>.\n\nThe hash value is used by Hash class.\n\nAny hash value that exceeds the capacity of a Fixnum will be truncated\nbefore being used.",
  "display": "Prints <i>obj</i> on the given port (default <code>$></code>).\nEquivalent to:\n\n   def display(port=$>)\n     port.write self\n   end\n\nFor example:\n\n   1.display\n   \"cat\".display\n   [ 4, 5, 6 ].display\n   puts\n\n<em>produces:</em>\n\n   1cat456"
}