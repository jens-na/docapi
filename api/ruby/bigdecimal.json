{
  "mode": "BigDecimal.mode(mode, value)\n\nControls handling of arithmetic exceptions and rounding. If no value\nis supplied, the current value is returned.\n\nSix values of the mode parameter control the handling of arithmetic\nexceptions:\n\nBigDecimal::EXCEPTION_NaN\nBigDecimal::EXCEPTION_INFINITY\nBigDecimal::EXCEPTION_UNDERFLOW\nBigDecimal::EXCEPTION_OVERFLOW\nBigDecimal::EXCEPTION_ZERODIVIDE\nBigDecimal::EXCEPTION_ALL\n\nFor each mode parameter above, if the value set is false, computation\ncontinues after an arithmetic exception of the appropriate type.\nWhen computation continues, results are as follows:\n\nEXCEPTION_NaN:: NaN\nEXCEPTION_INFINITY:: +Infinity or -Infinity\nEXCEPTION_UNDERFLOW:: 0\nEXCEPTION_OVERFLOW:: +Infinity or -Infinity\nEXCEPTION_ZERODIVIDE:: +Infinity or -Infinity\n\nOne value of the mode parameter controls the rounding of numeric values:\nBigDecimal::ROUND_MODE. The values it can take are:\n\nROUND_UP, :up:: round away from zero\nROUND_DOWN, :down, :truncate:: round towards zero (truncate)\nROUND_HALF_UP, :half_up, :default:: round towards the nearest neighbor, unless both neighbors are equidistant, in which case round away from zero. (default)\nROUND_HALF_DOWN, :half_down:: round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards zero.\nROUND_HALF_EVEN, :half_even, :banker:: round towards the nearest neighbor, unless both neighbors are equidistant, in which case round towards the even neighbor (Banker's rounding)\nROUND_CEILING, :ceiling, :ceil:: round towards positive infinity (ceil)\nROUND_FLOOR, :floor:: round towards negative infinity (floor)",
  "limit": "BigDecimal.limit(digits)\n\nLimit the number of significant digits in newly created BigDecimal\nnumbers to the specified value. Rounding is performed as necessary,\nas specified by BigDecimal.mode.\n\nA limit of 0, the default, means no upper limit.\n\nThe limit specified by this method takes less priority over any limit\nspecified to instance methods such as ceil, floor, truncate, or round.",
  "double_fig": "BigDecimal.double_fig\n\nThe BigDecimal.double_fig class method returns the number of digits a\nFloat number is allowed to have. The result depends upon the CPU and OS\nin use.",
  "_load": "Internal method used to provide marshalling support. See the Marshal module.",
  "ver": "Returns the BigDecimal version number.",
  "save_exception_mode": "Execute the provided block, but preserve the exception mode\n\n    BigDecimal.save_exception_mode do\n      BigDecimal.mode(BigDecimal::EXCEPTION_OVERFLOW, false)\n      BigDecimal.mode(BigDecimal::EXCEPTION_NaN, false)\n\n      BigDecimal.new(BigDecimal('Infinity'))\n      BigDecimal.new(BigDecimal('-Infinity'))\n      BigDecimal(BigDecimal.new('NaN'))\n    end\n\nFor use with the BigDecimal::EXCEPTION_*\n\nSee BigDecimal.mode",
  "save_rounding_mode": "Execute the provided block, but preserve the rounding mode\n\n    BigDecimal.save_rounding_mode do\n      BigDecimal.mode(BigDecimal::ROUND_MODE, :up)\n      puts BigDecimal.mode(BigDecimal::ROUND_MODE)\n    end\n\nFor use with the BigDecimal::ROUND_*\n\nSee BigDecimal.mode",
  "save_limit": "Execute the provided block, but preserve the precision limit\n\n     BigDecimal.limit(100)\n     puts BigDecimal.limit\n     BigDecimal.save_limit do\n         BigDecimal.limit(200)\n         puts BigDecimal.limit\n     end\n     puts BigDecimal.limit",
  "BASE": "Base value used in internal calculations.  On a 32 bit system, BASE\nis 10000, indicating that calculation is done in groups of 4 digits.\n(If it were larger, BASE**2 wouldn't fit in 32 bits, so you couldn't\nguarantee that two groups could always be multiplied together without\noverflow.)",
  "EXCEPTION_ALL": "Determines whether overflow, underflow or zero divide result in\nan exception being thrown. See BigDecimal.mode.",
  "EXCEPTION_NaN": "Determines what happens when the result of a computation is not a\nnumber (NaN). See BigDecimal.mode.",
  "EXCEPTION_INFINITY": "Determines what happens when the result of a computation is\ninfinity.  See BigDecimal.mode.",
  "EXCEPTION_UNDERFLOW": "Determines what happens when the result of a computation is an\nunderflow (a result too small to be represented). See BigDecimal.mode.",
  "EXCEPTION_OVERFLOW": "Determines what happens when the result of a computation is an\noverflow (a result too large to be represented). See BigDecimal.mode.",
  "EXCEPTION_ZERODIVIDE": "Determines what happens when a division by zero is performed.\nSee BigDecimal.mode.",
  "ROUND_MODE": "Determines what happens when a result must be rounded in order to\nfit in the appropriate number of significant digits. See\nBigDecimal.mode.",
  "ROUND_UP": "Indicates that values should be rounded away from zero. See\nBigDecimal.mode.",
  "ROUND_DOWN": "Indicates that values should be rounded towards zero. See\nBigDecimal.mode.",
  "ROUND_HALF_UP": "Indicates that digits >= 5 should be rounded up, others rounded down.\nSee BigDecimal.mode.",
  "ROUND_HALF_DOWN": "Indicates that digits >= 6 should be rounded up, others rounded down.\nSee BigDecimal.mode.",
  "ROUND_CEILING": "Round towards +Infinity. See BigDecimal.mode.",
  "ROUND_FLOOR": "Round towards -Infinity. See BigDecimal.mode.",
  "ROUND_HALF_EVEN": "Round towards the even neighbor. See BigDecimal.mode.",
  "SIGN_NaN": "Indicates that a value is not a number. See BigDecimal.sign.",
  "SIGN_POSITIVE_ZERO": "Indicates that a value is +0. See BigDecimal.sign.",
  "SIGN_NEGATIVE_ZERO": "Indicates that a value is -0. See BigDecimal.sign.",
  "SIGN_POSITIVE_FINITE": "Indicates that a value is positive and finite. See BigDecimal.sign.",
  "SIGN_NEGATIVE_FINITE": "Indicates that a value is negative and finite. See BigDecimal.sign.",
  "SIGN_POSITIVE_INFINITE": "Indicates that a value is positive and infinite. See BigDecimal.sign.",
  "SIGN_NEGATIVE_INFINITE": "Indicates that a value is negative and infinite. See BigDecimal.sign.",
  "INFINITY": "Positive infinity value.",
  "NAN": "'Not a Number' value.",
  "initialize": "Create a new BigDecimal object.\n\ninitial:: The initial value, as an Integer, a Float, a Rational,\n          a BigDecimal, or a String.\n\n          If it is a String, spaces are ignored and unrecognized characters\n          terminate the value.\n\ndigits:: The number of significant digits, as a Fixnum. If omitted or 0,\n         the number of significant digits is determined from the initial\n         value.\n\nThe actual number of significant digits used in computation is usually\nlarger than the specified number.",
  "initialize_copy": ":nodoc:\n\nprivate method to dup and clone the provided BigDecimal +other+",
  "precs": "precs\n\nReturns an Array of two Integer values.\n\nThe first value is the current number of significant digits in the\nBigDecimal. The second value is the maximum number of significant digits\nfor the BigDecimal.",
  "add": "call-seq:\nadd(value, digits)\n\nAdd the specified value.\n\ne.g.\n  c = a.add(b,n)\n  c = a + b\n\ndigits:: If specified and less than the number of significant digits of the\nresult, the result is rounded to that number of digits, according to\nBigDecimal.mode.",
  "sub": "sub(value, digits)  -> bigdecimal\n\nSubtract the specified value.\n\ne.g.\n  c = a.sub(b,n)\n\ndigits:: If specified and less than the number of significant digits of the\nresult, the result is rounded to that number of digits, according to\nBigDecimal.mode.",
  "mult": "call-seq: mult(value, digits)\n\nMultiply by the specified value.\n\ne.g.\n  c = a.mult(b,n)\n  c = a * b\n\ndigits:: If specified and less than the number of significant digits of the\nresult, the result is rounded to that number of digits, according to\nBigDecimal.mode.",
  "div": "",
  "hash": "Creates a hash for this BigDecimal.\n\nTwo BigDecimals with equal sign,\nfractional part and exponent have the same hash.",
  "to_s": "to_s(s)\n\nConverts the value to a string.\n\nThe default format looks like  0.xxxxEnn.\n\nThe optional parameter s consists of either an integer; or an optional '+'\nor ' ', followed by an optional number, followed by an optional 'E' or 'F'.\n\nIf there is a '+' at the start of s, positive values are returned with\na leading '+'.\n\nA space at the start of s returns positive values with a leading space.\n\nIf s contains a number, a space is inserted after each group of that many\nfractional digits.\n\nIf s ends with an 'E', engineering notation (0.xxxxEnn) is used.\n\nIf s ends with an 'F', conventional floating point notation is used.\n\nExamples:\n\nBigDecimal.new('-123.45678901234567890').to_s('5F')\n    #=> '-123.45678 90123 45678 9'\n\nBigDecimal.new('123.45678901234567890').to_s('+8F')\n    #=> '+123.45678901 23456789'\n\nBigDecimal.new('123.45678901234567890').to_s(' F')\n    #=> ' 123.4567890123456789'",
  "to_i": "Returns the value as an integer (Fixnum or Bignum).\n\nIf the BigNumber is infinity or NaN, raises FloatDomainError.",
  "to_int": "Returns the value as an integer (Fixnum or Bignum).\n\nIf the BigNumber is infinity or NaN, raises FloatDomainError.",
  "to_r": "Converts a BigDecimal to a Rational.",
  "split": "Splits a BigDecimal number into four parts, returned as an array of values.\n\nThe first value represents the sign of the BigDecimal, and is -1 or 1, or 0\nif the BigDecimal is Not a Number.\n\nThe second value is a string representing the significant digits of the\nBigDecimal, with no leading zeros.\n\nThe third value is the base used for arithmetic (currently always 10) as an\nInteger.\n\nThe fourth value is an Integer exponent.\n\nIf the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the\nstring of significant digits with no leading zeros, and n is the exponent.\n\nFrom these values, you can translate a BigDecimal to a float as follows:\n\n  sign, significant_digits, base, exponent = a.split\n  f = sign * \"0.#{significant_digits}\".to_f * (base ** exponent)\n\n(Note that the to_f method is provided as a more convenient way to translate\na BigDecimal to a Float.)",
  "+": "call-seq:\nadd(value, digits)\n\nAdd the specified value.\n\ne.g.\n  c = a.add(b,n)\n  c = a + b\n\ndigits:: If specified and less than the number of significant digits of the\nresult, the result is rounded to that number of digits, according to\nBigDecimal.mode.",
  "-": "value - digits   -> bigdecimal\n\nSubtract the specified value.\n\ne.g.\n  c = a - b\n\nThe precision of the result value depends on the type of +b+.\n\nIf +b+ is a Float, the precision of the result is Float::DIG+1.\n\nIf +b+ is a BigDecimal, the precision of the result is +b+'s precision of\ninternal representation from platform. So, it's return value is platform\ndependent.",
  "+@": "Return self.\n\ne.g.\n  b = +a  # b == a",
  "-@": "Return the negation of self.\n\ne.g.\n  b = -a\n  b == a * -1",
  "*": "call-seq: mult(value, digits)\n\nMultiply by the specified value.\n\ne.g.\n  c = a.mult(b,n)\n  c = a * b\n\ndigits:: If specified and less than the number of significant digits of the\nresult, the result is rounded to that number of digits, according to\nBigDecimal.mode.",
  "/": "For c = self/r: with round operation",
  "quo": "For c = self/r: with round operation",
  "%": "%: a%b = a - (a.to_f/b).floor * b",
  "modulo": "%: a%b = a - (a.to_f/b).floor * b",
  "remainder": "remainder",
  "divmod": "Divides by the specified value, and returns the quotient and modulus\nas BigDecimal numbers. The quotient is rounded towards negative infinity.\n\nFor example:\n\nrequire 'bigdecimal'\n\na = BigDecimal.new(\"42\")\nb = BigDecimal.new(\"9\")\n\nq,m = a.divmod(b)\n\nc = q * b + m\n\na == c  -> true\n\nThe quotient q is (a/b).floor, and the modulus is the amount that must be\nadded to q * b to get a.",
  "to_f": "Returns a new Float object having approximately the same value as the\nBigDecimal number. Normal accuracy limits and built-in errors of binary\nFloat arithmetic apply.",
  "abs": "Returns the absolute value.\n\nBigDecimal('5').abs -> 5\n\nBigDecimal('-3').abs -> 3",
  "sqrt": "sqrt(n)\n\nReturns the square root of the value.\n\nResult has at least n significant digits.",
  "fix": "Return the integer part of the number.",
  "round": "round(n, mode)\n\nRound to the nearest 1 (by default), returning the result as a BigDecimal.\n\nBigDecimal('3.14159').round #=> 3\nBigDecimal('8.7').round #=> 9\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that many digits to the left of the\ndecimal point will be 0 in the result.\n\nBigDecimal('3.14159').round(3) #=> 3.142\nBigDecimal('13345.234').round(-2) #=> 13300.0\n\nThe value of the optional mode argument can be used to determine how\nrounding is performed; see BigDecimal.mode.",
  "frac": "Return the fractional part of the number.",
  "floor": "floor(n)\n\nReturn the largest integer less than or equal to the value, as a BigDecimal.\n\nBigDecimal('3.14159').floor #=> 3\nBigDecimal('-9.1').floor #=> -10\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that\nmany digits to the left of the decimal point will be 0 in the result.\n\nBigDecimal('3.14159').floor(3) #=> 3.141\nBigDecimal('13345.234').floor(-2) #=> 13300.0",
  "ceil": "ceil(n)\n\nReturn the smallest integer greater than or equal to the value, as a BigDecimal.\n\nBigDecimal('3.14159').ceil #=> 4\nBigDecimal('-9.1').ceil #=> -9\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that\nmany digits to the left of the decimal point will be 0 in the result.\n\nBigDecimal('3.14159').ceil(3) #=> 3.142\nBigDecimal('13345.234').ceil(-2) #=> 13400.0",
  "power": "power(n)\npower(n, prec)\n\nReturns the value raised to the power of n.\n\nNote that n must be an Integer.\n\nAlso available as the operator **",
  "**": "It is a synonym of BigDecimal#power(exp).",
  "<=>": "The comparison operator.\na <=> b is 0 if a == b, 1 if a > b, -1 if a < b.",
  "==": "Tests for value equality; returns true if the values are equal.\n\nThe == and === operators and the eql? method have the same implementation\nfor BigDecimal.\n\nValues may be coerced to perform the comparison:\n\nBigDecimal.new('1.0') == 1.0  -> true",
  "===": "Tests for value equality; returns true if the values are equal.\n\nThe == and === operators and the eql? method have the same implementation\nfor BigDecimal.\n\nValues may be coerced to perform the comparison:\n\nBigDecimal.new('1.0') == 1.0  -> true",
  "eql?": "Tests for value equality; returns true if the values are equal.\n\nThe == and === operators and the eql? method have the same implementation\nfor BigDecimal.\n\nValues may be coerced to perform the comparison:\n\nBigDecimal.new('1.0') == 1.0  -> true",
  "<": "a < b\n\nReturns true if a is less than b.\n\nValues may be coerced to perform the comparison (see ==, BigDecimal#coerce).",
  "<=": "a <= b\n\nReturns true if a is less than or equal to b.\n\nValues may be coerced to perform the comparison (see ==, BigDecimal#coerce).",
  ">": "a > b\n\nReturns true if a is greater than b.\n\nValues may be coerced to perform the comparison (see ==, BigDecimal#coerce).",
  ">=": "a >= b\n\nReturns true if a is greater than or equal to b.\n\nValues may be coerced to perform the comparison (see ==, BigDecimal#coerce)",
  "zero?": "Returns True if the value is zero.",
  "nonzero?": "Returns self if the value is non-zero, nil otherwise.",
  "coerce": "The coerce method provides support for Ruby type coercion. It is not\nenabled by default.\n\nThis means that binary operations like + * / or - can often be performed\non a BigDecimal and an object of another type, if the other object can\nbe coerced into a BigDecimal value.\n\ne.g.\na = BigDecimal.new(\"1.0\")\nb = a / 2.0  -> 0.5\n\nNote that coercing a String to a BigDecimal is not supported by default;\nit requires a special compile-time option when building Ruby.",
  "inspect": "Returns debugging information about the value as a string of comma-separated\nvalues in angle brackets with a leading #:\n\nBigDecimal.new(\"1234.5678\").inspect ->\n\"#<BigDecimal:b7ea1130,'0.12345678E4',8(12)>\"\n\nThe first part is the address, the second is the value as a string, and\nthe final part ss(mm) is the current number of significant digits and the\nmaximum number of significant digits, respectively.",
  "exponent": "Returns the exponent of the BigDecimal number, as an Integer.\n\nIf the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string\nof digits with no leading zeros, then n is the exponent.",
  "sign": "Returns the sign of the value.\n\nReturns a positive value if > 0, a negative value if < 0, and a\nzero if == 0.\n\nThe specific value returned indicates the type and sign of the BigDecimal,\nas follows:\n\nBigDecimal::SIGN_NaN:: value is Not a Number\nBigDecimal::SIGN_POSITIVE_ZERO:: value is +0\nBigDecimal::SIGN_NEGATIVE_ZERO:: value is -0\nBigDecimal::SIGN_POSITIVE_INFINITE:: value is +Infinity\nBigDecimal::SIGN_NEGATIVE_INFINITE:: value is -Infinity\nBigDecimal::SIGN_POSITIVE_FINITE:: value is positive\nBigDecimal::SIGN_NEGATIVE_FINITE:: value is negative",
  "nan?": "Returns True if the value is Not a Number",
  "infinite?": "Returns nil, -1, or +1 depending on whether the value is finite,\n-Infinity, or +Infinity.",
  "finite?": "Returns True if the value is finite (not NaN or infinite)",
  "truncate": "truncate(n)\n\nTruncate to the nearest 1, returning the result as a BigDecimal.\n\nBigDecimal('3.14159').truncate #=> 3\nBigDecimal('8.7').truncate #=> 8\n\nIf n is specified and positive, the fractional part of the result has no\nmore than that many digits.\n\nIf n is specified and negative, at least that many digits to the left of the\ndecimal point will be 0 in the result.\n\nBigDecimal('3.14159').truncate(3) #=> 3.141\nBigDecimal('13345.234').truncate(-2) #=> 13300.0",
  "_dump": "Method used to provide marshalling support.\n\n     inf = BigDecimal.new('Infinity')\n     => #<BigDecimal:1e16fa8,'Infinity',9(9)>\n     BigDecimal._load(inf._dump)\n     => #<BigDecimal:1df8dc8,'Infinity',9(9)>\n\nSee the Marshal module."
}