{
  "to_s": "Returns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> \"UTF-8\"",
  "inspect": "Returns a string which represents the encoding for programmers.\n\n  Encoding::UTF_8.inspect       #=> \"#<Encoding:UTF-8>\"\n  Encoding::ISO_2022_JP.inspect #=> \"#<Encoding:ISO-2022-JP (dummy)>\"",
  "name": "Returns the name of the encoding.\n\n  Encoding::UTF_8.name      #=> \"UTF-8\"",
  "names": "Returns the list of name and aliases of the encoding.\n\n  Encoding::WINDOWS_31J.names  #=> [\"Windows-31J\", \"CP932\", \"csWindows31J\"]",
  "dummy?": "Returns true for dummy encodings.\nA dummy encoding is an encoding for which character handling is not properly\nimplemented.\nIt is used for stateful encodings.\n\n  Encoding::ISO_2022_JP.dummy?       #=> true\n  Encoding::UTF_8.dummy?             #=> false",
  "ascii_compatible?": "Returns whether ASCII-compatible or not.\n\n  Encoding::UTF_8.ascii_compatible?     #=> true\n  Encoding::UTF_16BE.ascii_compatible?  #=> false",
  "replicate": "Returns a replicated encoding of _enc_ whose name is _name_.\nThe new encoding should have the same byte structure of _enc_.\nIf _name_ is used by another encoding, raise ArgumentError.",
  "list": "Returns the list of loaded encodings.\n\n  Encoding.list\n  #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n        #<Encoding:ISO-2022-JP (dummy)>]\n\n  Encoding.find(\"US-ASCII\")\n  #=> #<Encoding:US-ASCII>\n\n  Encoding.list\n  #=> [#<Encoding:ASCII-8BIT>, #<Encoding:UTF-8>,\n        #<Encoding:US-ASCII>, #<Encoding:ISO-2022-JP (dummy)>]",
  "name_list": "Returns the list of available encoding names.\n\n  Encoding.name_list\n  #=> [\"US-ASCII\", \"ASCII-8BIT\", \"UTF-8\",\n        \"ISO-8859-1\", \"Shift_JIS\", \"EUC-JP\",\n        \"Windows-31J\",\n        \"BINARY\", \"CP932\", \"eucJP\"]",
  "aliases": "Returns the hash of available encoding alias and original encoding name.\n\n  Encoding.aliases\n  #=> {\"BINARY\"=>\"ASCII-8BIT\", \"ASCII\"=>\"US-ASCII\", \"ANSI_X3.4-1986\"=>\"US-ASCII\",\n        \"SJIS\"=>\"Shift_JIS\", \"eucJP\"=>\"EUC-JP\", \"CP932\"=>\"Windows-31J\"}",
  "find": "Search the encoding with specified <i>name</i>.\n<i>name</i> should be a string or symbol.\n\n  Encoding.find(\"US-ASCII\")  #=> #<Encoding:US-ASCII>\n  Encoding.find(:Shift_JIS)  #=> #<Encoding:Shift_JIS>\n\nNames which this method accept are encoding names and aliases\nincluding following special aliases\n\n\"external\"::   default external encoding\n\"internal\"::   default internal encoding\n\"locale\"::     locale encoding\n\"filesystem\":: filesystem encoding\n\nAn ArgumentError is raised when no encoding with <i>name</i>.\nOnly <code>Encoding.find(\"internal\")</code> however returns nil\nwhen no encoding named \"internal\", in other words, when Ruby has no\ndefault internal encoding.",
  "compatible?": "Checks the compatibility of two objects.\n\nIf the objects are both strings they are compatible when they are\nconcatenatable.  The encoding of the concatenated string will be returned\nif they are compatible, nil if they are not.\n\n  Encoding.compatible?(\"\\xa1\".force_encoding(\"iso-8859-1\"), \"b\")\n  #=> #<Encoding:ISO-8859-1>\n\n  Encoding.compatible?(\n    \"\\xa1\".force_encoding(\"iso-8859-1\"),\n    \"\\xa1\\xa1\".force_encoding(\"euc-jp\"))\n  #=> nil\n\nIf the objects are non-strings their encodings are compatible when they\nhave an encoding and:\n* Either encoding is US-ASCII compatible\n* One of the encodings is a 7-bit encoding",
  "_dump": ":nodoc:",
  "_load": ":nodoc:",
  "default_external": "Returns default external encoding.\n\nThe default external encoding is used by default for strings created from\nthe following locations:\n\n* CSV\n* File data read from disk\n* SDBM\n* StringIO\n* Zlib::GzipReader\n* Zlib::GzipWriter\n* String#inspect\n* Regexp#inspect\n\nWhile strings created from these locations will have this encoding, the\nencoding may not be valid.  Be sure to check String#valid_encoding?.\n\nFile data written to disk will be transcoded to the default external\nencoding when written.\n\nThe default external encoding is initialized by the locale or -E option.",
  "default_external=": "Sets default external encoding.  You should not set\nEncoding::default_external in ruby code as strings created before changing\nthe value may have a different encoding from strings created after the value\nwas changed., instead you should use <tt>ruby -E</tt> to invoke ruby with\nthe correct default_external.\n\nSee Encoding::default_external for information on how the default external\nencoding is used.",
  "default_internal": "Returns default internal encoding.  Strings will be transcoded to the\ndefault internal encoding in the following places if the default internal\nencoding is not nil:\n\n* CSV\n* Etc.sysconfdir and Etc.systmpdir\n* File data read from disk\n* File names from Dir\n* Integer#chr\n* String#inspect and Regexp#inspect\n* Strings returned from Readline\n* Strings returned from SDBM\n* Time#zone\n* Values from ENV\n* Values in ARGV including $PROGRAM_NAME\n* __FILE__\n\nAdditionally String#encode and String#encode! use the default internal\nencoding if no encoding is given.\n\nThe locale encoding (__ENCODING__), not default_internal, is used as the\nencoding of created strings.\n\nEncoding::default_internal is initialized by the source file's\ninternal_encoding or -E option.",
  "default_internal=": "Sets default internal encoding or removes default internal encoding when\npassed nil.  You should not set Encoding::default_internal in ruby code as\nstrings created before changing the value may have a different encoding\nfrom strings created after the change.  Instead you should use\n<tt>ruby -E</tt> to invoke ruby with the correct default_internal.\n\nSee Encoding::default_internal for information on how the default internal\nencoding is used.",
  "locale_charmap": "Returns the locale charmap name.\nIt returns nil if no appropriate information.\n\n  Debian GNU/Linux\n    LANG=C\n      Encoding.locale_charmap  #=> \"ANSI_X3.4-1968\"\n    LANG=ja_JP.EUC-JP\n      Encoding.locale_charmap  #=> \"EUC-JP\"\n\n  SunOS 5\n    LANG=C\n      Encoding.locale_charmap  #=> \"646\"\n    LANG=ja\n      Encoding.locale_charmap  #=> \"eucJP\"\n\nThe result is highly platform dependent.\nSo Encoding.find(Encoding.locale_charmap) may cause an error.\nIf you need some encoding object even for unknown locale,\nEncoding.find(\"locale\") can be used.",
  "UndefinedConversionError": "Raised by Encoding and String methods when a transcoding operation\nfails.",
  "InvalidByteSequenceError": "Raised by Encoding and String methods when the string being\ntranscoded contains a byte invalid for the either the source or\ntarget encoding.",
  "ConverterNotFoundError": "Raised by transcoding methods when a named encoding does not\ncorrespond with a known converter.",
  "Converter": "",
  "CompatibilityError": "Raised by Encoding and String methods when the source encoding is\nincompatible with the target encoding."
}