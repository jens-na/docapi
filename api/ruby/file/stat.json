{
  "initialize": "Create a File::Stat object for the given file name (raising an\nexception if the file doesn't exist).",
  "initialize_copy": ":nodoc:",
  "<=>": "Compares File::Stat objects by comparing their respective modification\ntimes.\n\n+nil+ is returned if the two values are incomparable.\n\n   f1 = File.new(\"f1\", \"w\")\n   sleep 1\n   f2 = File.new(\"f2\", \"w\")\n   f1.stat <=> f2.stat   #=> -1",
  "dev": "Returns an integer representing the device on which <i>stat</i>\nresides.\n\n   File.stat(\"testfile\").dev   #=> 774",
  "dev_major": "Returns the major part of <code>File_Stat#dev</code> or\n<code>nil</code>.\n\n   File.stat(\"/dev/fd1\").dev_major   #=> 2\n   File.stat(\"/dev/tty\").dev_major   #=> 5",
  "dev_minor": "Returns the minor part of <code>File_Stat#dev</code> or\n<code>nil</code>.\n\n   File.stat(\"/dev/fd1\").dev_minor   #=> 1\n   File.stat(\"/dev/tty\").dev_minor   #=> 0",
  "ino": "Returns the inode number for <i>stat</i>.\n\n   File.stat(\"testfile\").ino   #=> 1083669",
  "mode": "Returns an integer representing the permission bits of\n<i>stat</i>. The meaning of the bits is platform dependent; on\nUnix systems, see <code>stat(2)</code>.\n\n   File.chmod(0644, \"testfile\")   #=> 1\n   s = File.stat(\"testfile\")\n   sprintf(\"%o\", s.mode)          #=> \"100644\"",
  "nlink": "Returns the number of hard links to <i>stat</i>.\n\n   File.stat(\"testfile\").nlink             #=> 1\n   File.link(\"testfile\", \"testfile.bak\")   #=> 0\n   File.stat(\"testfile\").nlink             #=> 2",
  "uid": "Returns the numeric user id of the owner of <i>stat</i>.\n\n   File.stat(\"testfile\").uid   #=> 501",
  "gid": "Returns the numeric group id of the owner of <i>stat</i>.\n\n   File.stat(\"testfile\").gid   #=> 500",
  "rdev": "Returns an integer representing the device type on which\n<i>stat</i> resides. Returns <code>nil</code> if the operating\nsystem doesn't support this feature.\n\n   File.stat(\"/dev/fd1\").rdev   #=> 513\n   File.stat(\"/dev/tty\").rdev   #=> 1280",
  "rdev_major": "Returns the major part of <code>File_Stat#rdev</code> or\n<code>nil</code>.\n\n   File.stat(\"/dev/fd1\").rdev_major   #=> 2\n   File.stat(\"/dev/tty\").rdev_major   #=> 5",
  "rdev_minor": "Returns the minor part of <code>File_Stat#rdev</code> or\n<code>nil</code>.\n\n   File.stat(\"/dev/fd1\").rdev_minor   #=> 1\n   File.stat(\"/dev/tty\").rdev_minor   #=> 0",
  "size": "Returns the size of <i>stat</i> in bytes.\n\n   File.stat(\"testfile\").size   #=> 66",
  "blksize": "Returns the native file system's block size. Will return <code>nil</code>\non platforms that don't support this information.\n\n   File.stat(\"testfile\").blksize   #=> 4096",
  "blocks": "Returns the number of native file system blocks allocated for this\nfile, or <code>nil</code> if the operating system doesn't\nsupport this feature.\n\n   File.stat(\"testfile\").blocks   #=> 2",
  "atime": "Returns the last access time for this file as an object of class\n<code>Time</code>.\n\n   File.stat(\"testfile\").atime   #=> Wed Dec 31 18:00:00 CST 1969",
  "mtime": "Returns the modification time of <i>stat</i>.\n\n   File.stat(\"testfile\").mtime   #=> Wed Apr 09 08:53:14 CDT 2003",
  "ctime": "Returns the change time for <i>stat</i> (that is, the time\ndirectory information about the file was changed, not the file\nitself).\n\nNote that on Windows (NTFS), returns creation time (birth time).\n\n   File.stat(\"testfile\").ctime   #=> Wed Apr 09 08:53:14 CDT 2003",
  "inspect": "Produce a nicely formatted description of <i>stat</i>.\n\n  File.stat(\"/etc/passwd\").inspect\n     #=> \"#<File::Stat dev=0xe000005, ino=1078078, mode=0100644,\n     #    nlink=1, uid=0, gid=0, rdev=0x0, size=1374, blksize=4096,\n     #    blocks=8, atime=Wed Dec 10 10:16:12 CST 2003,\n     #    mtime=Fri Sep 12 15:41:41 CDT 2003,\n     #    ctime=Mon Oct 27 11:20:27 CST 2003>\"",
  "ftype": "Identifies the type of <i>stat</i>. The return string is one of:\n``<code>file</code>'', ``<code>directory</code>'',\n``<code>characterSpecial</code>'', ``<code>blockSpecial</code>'',\n``<code>fifo</code>'', ``<code>link</code>'',\n``<code>socket</code>'', or ``<code>unknown</code>''.\n\n   File.stat(\"/dev/tty\").ftype   #=> \"characterSpecial\"",
  "directory?": "Returns <code>true</code> if <i>stat</i> is a directory,\n<code>false</code> otherwise.\n\n   File.stat(\"testfile\").directory?   #=> false\n   File.stat(\".\").directory?          #=> true",
  "readable?": "Returns <code>true</code> if <i>stat</i> is readable by the\neffective user id of this process.\n\n   File.stat(\"testfile\").readable?   #=> true",
  "readable_real?": "Returns <code>true</code> if <i>stat</i> is readable by the real\nuser id of this process.\n\n   File.stat(\"testfile\").readable_real?   #=> true",
  "world_readable?": "If <i>stat</i> is readable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n<code>nil</code> otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see <code>stat(2)</code>.\n\n   m = File.stat(\"/etc/passwd\").world_readable?  #=> 420\n   sprintf(\"%o\", m)\t\t\t\t    #=> \"644\"",
  "writable?": "Returns <code>true</code> if <i>stat</i> is writable by the\neffective user id of this process.\n\n   File.stat(\"testfile\").writable?   #=> true",
  "writable_real?": "Returns <code>true</code> if <i>stat</i> is writable by the real\nuser id of this process.\n\n   File.stat(\"testfile\").writable_real?   #=> true",
  "world_writable?": "If <i>stat</i> is writable by others, returns an integer\nrepresenting the file permission bits of <i>stat</i>. Returns\n<code>nil</code> otherwise. The meaning of the bits is platform\ndependent; on Unix systems, see <code>stat(2)</code>.\n\n   m = File.stat(\"/tmp\").world_writable?\t    #=> 511\n   sprintf(\"%o\", m)\t\t\t\t    #=> \"777\"",
  "executable?": "Returns <code>true</code> if <i>stat</i> is executable or if the\noperating system doesn't distinguish executable files from\nnonexecutable files. The tests are made using the effective owner of\nthe process.\n\n   File.stat(\"testfile\").executable?   #=> false",
  "executable_real?": "Same as <code>executable?</code>, but tests using the real owner of\nthe process.",
  "file?": "Returns <code>true</code> if <i>stat</i> is a regular file (not\na device file, pipe, socket, etc.).\n\n   File.stat(\"testfile\").file?   #=> true",
  "zero?": "Returns <code>true</code> if <i>stat</i> is a zero-length file;\n<code>false</code> otherwise.\n\n   File.stat(\"testfile\").zero?   #=> false",
  "size?": "Returns the size of <i>stat</i> in bytes.\n\n   File.stat(\"testfile\").size   #=> 66",
  "owned?": "Returns <code>true</code> if the effective user id of the process is\nthe same as the owner of <i>stat</i>.\n\n   File.stat(\"testfile\").owned?      #=> true\n   File.stat(\"/etc/passwd\").owned?   #=> false",
  "grpowned?": "Returns true if the effective group id of the process is the same as\nthe group id of <i>stat</i>. On Windows NT, returns <code>false</code>.\n\n   File.stat(\"testfile\").grpowned?      #=> true\n   File.stat(\"/etc/passwd\").grpowned?   #=> false",
  "pipe?": "Returns <code>true</code> if the operating system supports pipes and\n<i>stat</i> is a pipe; <code>false</code> otherwise.",
  "symlink?": "Returns <code>true</code> if <i>stat</i> is a symbolic link,\n<code>false</code> if it isn't or if the operating system doesn't\nsupport this feature. As <code>File::stat</code> automatically\nfollows symbolic links, <code>symlink?</code> will always be\n<code>false</code> for an object returned by\n<code>File::stat</code>.\n\n   File.symlink(\"testfile\", \"alink\")   #=> 0\n   File.stat(\"alink\").symlink?         #=> false\n   File.lstat(\"alink\").symlink?        #=> true",
  "socket?": "Returns <code>true</code> if <i>stat</i> is a socket,\n<code>false</code> if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat(\"testfile\").socket?   #=> false",
  "blockdev?": "Returns <code>true</code> if the file is a block device,\n<code>false</code> if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat(\"testfile\").blockdev?    #=> false\n   File.stat(\"/dev/hda1\").blockdev?   #=> true",
  "chardev?": "Returns <code>true</code> if the file is a character device,\n<code>false</code> if it isn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat(\"/dev/tty\").chardev?   #=> true",
  "setuid?": "Returns <code>true</code> if <i>stat</i> has the set-user-id\npermission bit set, <code>false</code> if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat(\"/bin/su\").setuid?   #=> true",
  "setgid?": "Returns <code>true</code> if <i>stat</i> has the set-group-id\npermission bit set, <code>false</code> if it doesn't or if the\noperating system doesn't support this feature.\n\n   File.stat(\"/usr/sbin/lpc\").setgid?   #=> true",
  "sticky?": "Returns <code>true</code> if <i>stat</i> has its sticky bit set,\n<code>false</code> if it doesn't or if the operating system doesn't\nsupport this feature.\n\n   File.stat(\"testfile\").sticky?   #=> false"
}