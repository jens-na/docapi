{
  "compile": "Synonym for <code>Regexp.new</code>",
  "quote": "Escapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n<code>Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i></code> will be true.\n\n   Regexp.escape('\\*?{}.')   #=> \\\\\\*\\?\\{\\}\\.",
  "escape": "Escapes any characters that would have special meaning in a regular\nexpression. Returns a new escaped string, or self if no characters are\nescaped.  For any string,\n<code>Regexp.new(Regexp.escape(<i>str</i>))=~<i>str</i></code> will be true.\n\n   Regexp.escape('\\*?{}.')   #=> \\\\\\*\\?\\{\\}\\.",
  "union": "Return a <code>Regexp</code> object that is the union of the given\n<em>pattern</em>s, i.e., will match any of its parts. The <em>pattern</em>s\ncan be Regexp objects, in which case their options will be preserved, or\nStrings. If no patterns are given, returns <code>/(?!)/</code>.\nThe behavior is unspecified if any given <em>pattern</em> contains capture.\n\n   Regexp.union                         #=> /(?!)/\n   Regexp.union(\"penzance\")             #=> /penzance/\n   Regexp.union(\"a+b*c\")                #=> /a\\+b\\*c/\n   Regexp.union(\"skiing\", \"sledding\")   #=> /skiing|sledding/\n   Regexp.union([\"skiing\", \"sledding\"]) #=> /skiing|sledding/\n   Regexp.union(/dogs/, /cats/i)        #=> /(?-mix:dogs)|(?i-mx:cats)/\n\nNote: the arguments for ::union will try to be converted into a regular\nexpression literal via #to_regexp.",
  "last_match": "The first form returns the MatchData object generated by the\nlast successful pattern match.  Equivalent to reading the special global\nvariable <code>$~</code> (see Special global variables in Regexp for\ndetails).\n\nThe second form returns the <i>n</i>th field in this MatchData object.\n_n_ can be a string or symbol to reference a named capture.\n\nNote that the last_match is local to the thread and method scope of the\nmethod that did the pattern match.\n\n   /c(.)t/ =~ 'cat'        #=> 0\n   Regexp.last_match       #=> #<MatchData \"cat\" 1:\"a\">\n   Regexp.last_match(0)    #=> \"cat\"\n   Regexp.last_match(1)    #=> \"a\"\n   Regexp.last_match(2)    #=> nil\n\n   /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/ =~ \"var = val\"\n   Regexp.last_match       #=> #<MatchData \"var = val\" lhs:\"var\" rhs:\"val\">\n   Regexp.last_match(:lhs) #=> \"var\"\n   Regexp.last_match(:rhs) #=> \"val\"",
  "try_convert": "Try to convert <i>obj</i> into a Regexp, using to_regexp method.\nReturns converted regexp or nil if <i>obj</i> cannot be converted\nfor any reason.\n\n   Regexp.try_convert(/re/)         #=> /re/\n   Regexp.try_convert(\"re\")         #=> nil\n\n   o = Object.new\n   Regexp.try_convert(o)            #=> nil\n   def o.to_regexp() /foo/ end\n   Regexp.try_convert(o)            #=> /foo/",
  "initialize": "Constructs a new regular expression from +pattern+, which can be either a\nString or a Regexp (in which case that regexp's options are propagated),\nand new options may not be specified (a change as of Ruby 1.8).\n\nIf +options+ is a Fixnum, it should be one or more of the constants\nRegexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE,\n<em>or</em>-ed together.  Otherwise, if +options+ is not\n+nil+ or +false+, the regexp will be case insensitive.\n\nWhen the +kcode+ parameter is `n' or `N' sets the regexp no encoding.\nIt means that the regexp is for binary strings.\n\n  r1 = Regexp.new('^a-z+:\\\\s+\\w+') #=> /^a-z+:\\s+\\w+/\n  r2 = Regexp.new('cat', true)     #=> /cat/i\n  r3 = Regexp.new(r2)              #=> /cat/i\n  r4 = Regexp.new('dog', Regexp::EXTENDED | Regexp::IGNORECASE) #=> /dog/ix",
  "initialize_copy": ":nodoc:",
  "hash": "Produce a hash based on the text and options of this regular expression.",
  "eql?": "Equality---Two regexps are equal if their patterns are identical, they have\nthe same character set code, and their <code>casefold?</code> values are the\nsame.\n\n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/u   #=> false\n   /abc/u == /abc/n   #=> false",
  "==": "Equality---Two regexps are equal if their patterns are identical, they have\nthe same character set code, and their <code>casefold?</code> values are the\nsame.\n\n   /abc/  == /abc/x   #=> false\n   /abc/  == /abc/i   #=> false\n   /abc/  == /abc/u   #=> false\n   /abc/u == /abc/n   #=> false",
  "=~": "Match---Matches <i>rxp</i> against <i>str</i>.\n\n   /at/ =~ \"input data\"   #=> 7\n   /ax/ =~ \"input data\"   #=> nil\n\nIf <code>=~</code> is used with a regexp literal with named captures,\ncaptured strings (or nil) is assigned to local variables named by\nthe capture names.\n\n   /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/ =~ \"  x = y  \"\n   p lhs    #=> \"x\"\n   p rhs    #=> \"y\"\n\nIf it is not matched, nil is assigned for the variables.\n\n   /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/ =~ \"  x = \"\n   p lhs    #=> nil\n   p rhs    #=> nil\n\nThis assignment is implemented in the Ruby parser.\nThe parser detects 'regexp-literal =~ expression' for the assignment.\nThe regexp must be a literal without interpolation and placed at left hand side.\n\nThe assignment does not occur if the regexp is not a literal.\n\n   re = /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/\n   re =~ \"  x = y  \"\n   p lhs    # undefined local variable\n   p rhs    # undefined local variable\n\nA regexp interpolation, <code>#{}</code>, also disables\nthe assignment.\n\n   rhs_pat = /(?<rhs>\\w+)/\n   /(?<lhs>\\w+)\\s*=\\s*#{rhs_pat}/ =~ \"x = y\"\n   p lhs    # undefined local variable\n\nThe assignment does not occur if the regexp is placed at the right hand side.\n\n  \"  x = y  \" =~ /(?<lhs>\\w+)\\s*=\\s*(?<rhs>\\w+)/\n  p lhs, rhs # undefined local variable",
  "===": "Case Equality---Used in case statements.\n\n   a = \"HELLO\"\n   case a\n   when /^[a-z]*$/; print \"Lower case\\n\"\n   when /^[A-Z]*$/; print \"Upper case\\n\"\n   else;            print \"Mixed case\\n\"\n   end\n   #=> \"Upper case\"\n\nFollowing a regular expression literal with the #=== operator allows you to\ncompare against a String.\n\n/^[a-z]*$/ === \"HELLO\" #=> false\n/^[A-Z]*$/ === \"HELLO\" #=> true",
  "~": "Match---Matches <i>rxp</i> against the contents of <code>$_</code>.\nEquivalent to <code><i>rxp</i> =~ $_</code>.\n\n   $_ = \"input data\"\n   ~ /at/   #=> 7",
  "match": "Returns a <code>MatchData</code> object describing the match, or\n<code>nil</code> if there was no match. This is equivalent to retrieving the\nvalue of the special variable <code>$~</code> following a normal match.\nIf the second parameter is present, it specifies the position in the string\nto begin the search.\n\n   /(.)(.)(.)/.match(\"abc\")[2]   #=> \"b\"\n   /(.)(.)/.match(\"abc\", 1)[2]   #=> \"c\"\n\nIf a block is given, invoke the block with MatchData if match succeed, so\nthat you can write\n\n   pat.match(str) {|m| ...}\n\ninstead of\n\n   if m = pat.match(str)\n     ...\n   end\n\nThe return value is a value from block execution in this case.",
  "to_s": "Returns a string containing the regular expression and its options (using the\n<code>(?opts:source)</code> notation. This string can be fed back in to\n<code>Regexp::new</code> to a regular expression with the same semantics as\nthe original. (However, <code>Regexp#==</code> may not return true when\ncomparing the two, as the source of the regular expression itself may\ndiffer, as the example shows).  <code>Regexp#inspect</code> produces a\ngenerally more readable version of <i>rxp</i>.\n\n    r1 = /ab+c/ix           #=> /ab+c/ix\n    s1 = r1.to_s            #=> \"(?ix-m:ab+c)\"\n    r2 = Regexp.new(s1)     #=> /(?ix-m:ab+c)/\n    r1 == r2                #=> false\n    r1.source               #=> \"ab+c\"\n    r2.source               #=> \"(?ix-m:ab+c)\"",
  "inspect": "Produce a nicely formatted string-version of _rxp_. Perhaps surprisingly,\n<code>#inspect</code> actually produces the more natural version of\nthe string than <code>#to_s</code>.\n\n     /ab+c/ix.inspect        #=> \"/ab+c/ix\"",
  "source": "Returns the original string of the pattern.\n\n    /ab+c/ix.source #=> \"ab+c\"\n\nNote that escape sequences are retained as is.\n\n   /\\x20\\+/.source  #=> \"\\\\x20\\\\+\"",
  "casefold?": "Returns the value of the case-insensitive flag.\n\n    /a/.casefold?           #=> false\n    /a/i.casefold?          #=> true\n    /(?i:a)/.casefold?      #=> false",
  "options": "Returns the set of bits corresponding to the options used when creating this\nRegexp (see <code>Regexp::new</code> for details. Note that additional bits\nmay be set in the returned options: these are used internally by the regular\nexpression code. These extra bits are ignored if the options are passed to\n<code>Regexp::new</code>.\n\n   Regexp::IGNORECASE                  #=> 1\n   Regexp::EXTENDED                    #=> 2\n   Regexp::MULTILINE                   #=> 4\n\n   /cat/.options                       #=> 0\n   /cat/ix.options                     #=> 3\n   Regexp.new('cat', true).options     #=> 1\n   /\\xa1\\xa2/e.options                 #=> 16\n\n   r = /cat/ix\n   Regexp.new(r.source, r.options)     #=> /cat/ix",
  "encoding": "",
  "fixed_encoding?": "Returns false if rxp is applicable to\na string with any ASCII compatible encoding.\nReturns true otherwise.\n\n    r = /a/\n    r.fixed_encoding?                               #=> false\n    r =~ \"\\u{6666} a\"                               #=> 2\n    r =~ \"\\xa1\\xa2 a\".force_encoding(\"euc-jp\")      #=> 2\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> 0\n\n    r = /a/u\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ \"\\u{6666} a\"                               #=> 2\n    r =~ \"\\xa1\\xa2\".force_encoding(\"euc-jp\")        #=> ArgumentError\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> 0\n\n    r = /\\u{6666}/\n    r.fixed_encoding?                               #=> true\n    r.encoding                                      #=> #<Encoding:UTF-8>\n    r =~ \"\\u{6666} a\"                               #=> 0\n    r =~ \"\\xa1\\xa2\".force_encoding(\"euc-jp\")        #=> ArgumentError\n    r =~ \"abc\".force_encoding(\"euc-jp\")             #=> nil",
  "names": "Returns a list of names of captures as an array of strings.\n\n    /(?<foo>.)(?<bar>.)(?<baz>.)/.names\n    #=> [\"foo\", \"bar\", \"baz\"]\n\n    /(?<foo>.)(?<foo>.)/.names\n    #=> [\"foo\"]\n\n    /(.)(.)/.names\n    #=> []",
  "named_captures": "Returns a hash representing information about named captures of <i>rxp</i>.\n\nA key of the hash is a name of the named captures.\nA value of the hash is an array which is list of indexes of corresponding\nnamed captures.\n\n   /(?<foo>.)(?<bar>.)/.named_captures\n   #=> {\"foo\"=>[1], \"bar\"=>[2]}\n\n   /(?<foo>.)(?<foo>.)/.named_captures\n   #=> {\"foo\"=>[1, 2]}\n\nIf there are no named captures, an empty hash is returned.\n\n   /(.)(.)/.named_captures\n   #=> {}",
  "IGNORECASE": "see Regexp.options and Regexp.new",
  "EXTENDED": "see Regexp.options and Regexp.new",
  "MULTILINE": "see Regexp.options and Regexp.new",
  "FIXEDENCODING": "see Regexp.options and Regexp.new",
  "NOENCODING": "see Regexp.options and Regexp.new"
}