{
  "new": "Thread.new(*args, &proc)\t\t-> thread\n Thread.new(*args) { |args| ... }\t-> thread\n\n Creates a new thread executing the given block.\n\n Any +args+ given to ::new will be passed to the block:\n\narr = []\na, b, c = 1, 2, 3\nThread.new(a,b,c) { |d,e,f| arr << d << e << f }.join\narr #=> [1, 2, 3]\n\n A ThreadError exception is raised if ::new is called without a block.\n\n If you're going to subclass Thread, be sure to call super in your\n +initialize+ method, otherwise a ThreadError will be raised.",
  "start": "Basically the same as ::new. However, if class Thread is subclassed, then\ncalling +start+ in that subclass will not invoke the subclass's\n+initialize+ method.",
  "fork": "Basically the same as ::new. However, if class Thread is subclassed, then\ncalling +start+ in that subclass will not invoke the subclass's\n+initialize+ method.",
  "main": "Returns the main thread.",
  "current": "Returns the currently executing thread.\n\n   Thread.current   #=> #<Thread:0x401bdf4c run>",
  "stop": "Stops execution of the current thread, putting it into a ``sleep'' state,\nand schedules execution of another thread.\n\n   a = Thread.new { print \"a\"; Thread.stop; print \"c\" }\n   sleep 0.1 while a.status!='sleep'\n   print \"b\"\n   a.run\n   a.join\n   #=> \"abc\"",
  "kill": "Terminates +thr+ and schedules another thread to be run.\n\nIf this thread is already marked to be killed, #exit returns the Thread.\n\nIf this is the main thread, or the last thread, exits the process.",
  "exit": "Terminates +thr+ and schedules another thread to be run.\n\nIf this thread is already marked to be killed, #exit returns the Thread.\n\nIf this is the main thread, or the last thread, exits the process.",
  "pass": "Give the thread scheduler a hint to pass execution to another thread.\nA running thread may or may not switch, it depends on OS and processor.",
  "list": "Returns an array of Thread objects for all threads that are either runnable\nor stopped.\n\n   Thread.new { sleep(200) }\n   Thread.new { 1000000.times {|i| i*i } }\n   Thread.new { Thread.stop }\n   Thread.list.each {|t| p t}\n\nThis will produce:\n\n   #<Thread:0x401b3e84 sleep>\n   #<Thread:0x401b3f38 run>\n   #<Thread:0x401b3fb0 sleep>\n   #<Thread:0x401bdf4c run>",
  "abort_on_exception": "Returns the status of the thread-local ``abort on exception'' condition for\nthis +thr+.\n\nThe default is +false+.\n\nSee also #abort_on_exception=.\n\nThere is also a class level method to set this for all threads, see\n::abort_on_exception.",
  "abort_on_exception=": "When set to +true+, all threads (including the main program) will abort if\nan exception is raised in this +thr+.\n\nThe process will effectively <code>exit(0)</code>.\n\nSee also #abort_on_exception.\n\nThere is also a class level method to set this for all threads, see\n::abort_on_exception=.",
  "DEBUG": "Returns the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.",
  "DEBUG=": "Sets the thread debug level.  Available only if compiled with\nTHREAD_DEBUG=-1.",
  "handle_interrupt": "Changes asynchronous interrupt timing.\n\n_interrupt_ means asynchronous event and corresponding procedure\nby Thread#raise, Thread#kill, signal trap (not supported yet)\nand main thread termination (if main thread terminates, then all\nother thread will be killed).\n\nThe given +hash+ has pairs like <code>ExceptionClass =>\n:TimingSymbol</code>. Where the ExceptionClass is the interrupt handled by\nthe given block. The TimingSymbol can be one of the following symbols:\n\n[+:immediate+]   Invoke interrupts immediately.\n[+:on_blocking+] Invoke interrupts while _BlockingOperation_.\n[+:never+]       Never invoke all interrupts.\n\n_BlockingOperation_ means that the operation will block the calling thread,\nsuch as read and write.  On CRuby implementation, _BlockingOperation_ is any\noperation executed without GVL.\n\nMasked asynchronous interrupts are delayed until they are enabled.\nThis method is similar to sigprocmask(3).\n\n=== NOTE\n\nAsynchronous interrupts are difficult to use.\n\nIf you need to communicate between threads, please consider to use another way such as Queue.\n\nOr use them with deep understanding about this method.\n\n=== Usage\n\nIn this example, we can guard from Thread#raise exceptions.\n\nUsing the +:never+ TimingSymbol the RuntimeError exception will always be\nignored in the first block of the main thread. In the second\n::handle_interrupt block we can purposefully handle RuntimeError exceptions.\n\n  th = Thread.new do\n    Thread.handle_interrupt(RuntimeError => :never) {\n      begin\n        # You can write resource allocation code safely.\n        Thread.handle_interrupt(RuntimeError => :immediate) {\n     # ...\n        }\n      ensure\n        # You can write resource deallocation code safely.\n      end\n    }\n  end\n  Thread.pass\n  # ...\n  th.raise \"stop\"\n\nWhile we are ignoring the RuntimeError exception, it's safe to write our\nresource allocation code. Then, the ensure block is where we can safely\ndeallocate your resources.\n\n==== Guarding from TimeoutError\n\nIn the next example, we will guard from the TimeoutError exception. This\nwill help prevent from leaking resources when TimeoutError exceptions occur\nduring normal ensure clause. For this example we use the help of the\nstandard library Timeout, from lib/timeout.rb\n\n  require 'timeout'\n  Thread.handle_interrupt(TimeoutError => :never) {\n    timeout(10){\n      # TimeoutError doesn't occur here\n      Thread.handle_interrupt(TimeoutError => :on_blocking) {\n        # possible to be killed by TimeoutError\n        # while blocking operation\n      }\n      # TimeoutError doesn't occur here\n    }\n  }\n\nIn the first part of the +timeout+ block, we can rely on TimeoutError being\nignored. Then in the <code>TimeoutError => :on_blocking</code> block, any\noperation that will block the calling thread is susceptible to a\nTimeoutError exception being raised.\n\n==== Stack control settings\n\nIt's possible to stack multiple levels of ::handle_interrupt blocks in order\nto control more than one ExceptionClass and TimingSymbol at a time.\n\n  Thread.handle_interrupt(FooError => :never) {\n    Thread.handle_interrupt(BarError => :never) {\n       # FooError and BarError are prohibited.\n    }\n  }\n\n==== Inheritance with ExceptionClass\n\nAll exceptions inherited from the ExceptionClass parameter will be considered.\n\n  Thread.handle_interrupt(Exception => :never) {\n    # all exceptions inherited from Exception are prohibited.\n  }",
  "pending_interrupt?": "Returns whether or not the asynchronous queue is empty for the target thread.\n\nIf +error+ is given, then check only for +error+ type deferred events.\n\nSee ::pending_interrupt? for more information.",
  "initialize": ":nodoc:",
  "raise": "Raises an exception from the given thread. The caller does not have to be\n+thr+. See Kernel#raise for more information.\n\n   Thread.abort_on_exception = true\n   a = Thread.new { sleep(200) }\n   a.raise(\"Gotcha\")\n\nThis will produce:\n\n   prog.rb:3: Gotcha (RuntimeError)\n   \tfrom prog.rb:2:in `initialize'\n   \tfrom prog.rb:2:in `new'\n   \tfrom prog.rb:2",
  "join": "The calling thread will suspend execution and run this +thr+.\n\nDoes not return until +thr+ exits or until the given +limit+ seconds have\npassed.\n\nIf the time limit expires, +nil+ will be returned, otherwise +thr+ is\nreturned.\n\nAny threads not joined will be killed when the main program exits.\n\nIf +thr+ had previously raised an exception and the ::abort_on_exception or\n$DEBUG flags are not set, (so the exception has not yet been processed), it\nwill be processed at this time.\n\n   a = Thread.new { print \"a\"; sleep(10); print \"b\"; print \"c\" }\n   x = Thread.new { print \"x\"; Thread.pass; print \"y\"; print \"z\" }\n   x.join # Let thread x finish, thread a will be killed on exit.\n   #=> \"axyz\"\n\nThe following example illustrates the +limit+ parameter.\n\n   y = Thread.new { 4.times { sleep 0.1; puts 'tick... ' }}\n   puts \"Waiting\" until y.join(0.15)\n\nThis will produce:\n\n   tick...\n   Waiting\n   tick...\n   Waiting\n   tick...\n   tick...",
  "value": "Waits for +thr+ to complete, using #join, and returns its value.\n\n   a = Thread.new { 2 + 2 }\n   a.value   #=> 4",
  "terminate": "Terminates +thr+ and schedules another thread to be run.\n\nIf this thread is already marked to be killed, #exit returns the Thread.\n\nIf this is the main thread, or the last thread, exits the process.",
  "run": "Wakes up +thr+, making it eligible for scheduling.\n\n   a = Thread.new { puts \"a\"; Thread.stop; puts \"c\" }\n   sleep 0.1 while a.status!='sleep'\n   puts \"Got here\"\n   a.run\n   a.join\n\nThis will produce:\n\n   a\n   Got here\n   c\n\nSee also the instance method #wakeup.",
  "wakeup": "Marks a given thread as eligible for scheduling, however it may still\nremain blocked on I/O.\n\n*Note:* This does not invoke the scheduler, see #run for more information.\n\n   c = Thread.new { Thread.stop; puts \"hey!\" }\n   sleep 0.1 while c.status!='sleep'\n   c.wakeup\n   c.join\n   #=> \"hey!\"",
  "[]": "Attribute Reference---Returns the value of a fiber-local variable (current thread's root fiber\nif not explicitly inside a Fiber), using either a symbol or a string name.\nIf the specified variable does not exist, returns +nil+.\n\n   [\n     Thread.new { Thread.current[\"name\"] = \"A\" },\n     Thread.new { Thread.current[:name]  = \"B\" },\n     Thread.new { Thread.current[\"name\"] = \"C\" }\n   ].each do |th|\n     th.join\n     puts \"#{th.inspect}: #{th[:name]}\"\n   end\n\nThis will produce:\n\n   #<Thread:0x00000002a54220 dead>: A\n   #<Thread:0x00000002a541a8 dead>: B\n   #<Thread:0x00000002a54130 dead>: C\n\nThread#[] and Thread#[]= are not thread-local but fiber-local.\nThis confusion did not exist in Ruby 1.8 because\nfibers are only available since Ruby 1.9.\nRuby 1.9 chooses that the methods behaves fiber-local to save\nfollowing idiom for dynamic scope.\n\n  def meth(newvalue)\n    begin\n      oldvalue = Thread.current[:name]\n      Thread.current[:name] = newvalue\n      yield\n    ensure\n      Thread.current[:name] = oldvalue\n    end\n  end\n\nThe idiom may not work as dynamic scope if the methods are thread-local\nand a given block switches fiber.\n\n  f = Fiber.new {\n    meth(1) {\n      Fiber.yield\n    }\n  }\n  meth(2) {\n    f.resume\n  }\n  f.resume\n  p Thread.current[:name]\n  #=> nil if fiber-local\n  #=> 2 if thread-local (The value 2 is leaked to outside of meth method.)\n\nFor thread-local variables, please see #thread_variable_get and\n#thread_variable_set.",
  "[]=": "Attribute Assignment---Sets or creates the value of a fiber-local variable,\nusing either a symbol or a string.\n\nSee also Thread#[].\n\nFor thread-local variables, please see #thread_variable_set and\n#thread_variable_get.",
  "key?": "Returns +true+ if the given string (or symbol) exists as a fiber-local\nvariable.\n\n   me = Thread.current\n   me[:oliver] = \"a\"\n   me.key?(:oliver)    #=> true\n   me.key?(:stanley)   #=> false",
  "keys": "Returns an array of the names of the fiber-local variables (as Symbols).\n\n   thr = Thread.new do\n     Thread.current[:cat] = 'meow'\n     Thread.current[\"dog\"] = 'woof'\n   end\n   thr.join   #=> #<Thread:0x401b3f10 dead>\n   thr.keys   #=> [:dog, :cat]",
  "priority": "Returns the priority of <i>thr</i>. Default is inherited from the\ncurrent thread which creating the new thread, or zero for the\ninitial main thread; higher-priority thread will run more frequently\nthan lower-priority threads (but lower-priority threads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   Thread.current.priority   #=> 0",
  "priority=": "Sets the priority of <i>thr</i> to <i>integer</i>. Higher-priority threads\nwill run more frequently than lower-priority threads (but lower-priority\nthreads can also run).\n\nThis is just hint for Ruby thread scheduler.  It may be ignored on some\nplatform.\n\n   count1 = count2 = 0\n   a = Thread.new do\n         loop { count1 += 1 }\n       end\n   a.priority = -1\n\n   b = Thread.new do\n         loop { count2 += 1 }\n       end\n   b.priority = -2\n   sleep 1   #=> 1\n   count1    #=> 622504\n   count2    #=> 5832",
  "status": "Returns the status of +thr+.\n\n[<tt>\"sleep\"</tt>]\nReturned if this thread is sleeping or waiting on I/O\n[<tt>\"run\"</tt>]\nWhen this thread is executing\n[<tt>\"aborting\"</tt>]\nIf this thread is aborting\n[+false+]\nWhen this thread is terminated normally\n[+nil+]\nIf terminated with an exception.\n\n   a = Thread.new { raise(\"die now\") }\n   b = Thread.new { Thread.stop }\n   c = Thread.new { Thread.exit }\n   d = Thread.new { sleep }\n   d.kill                  #=> #<Thread:0x401b3678 aborting>\n   a.status                #=> nil\n   b.status                #=> \"sleep\"\n   c.status                #=> false\n   d.status                #=> \"aborting\"\n   Thread.current.status   #=> \"run\"\n\nSee also the instance methods #alive? and #stop?",
  "thread_variable_get": "Returns the value of a thread local variable that has been set.  Note that\nthese are different than fiber local values.  For fiber local values,\nplease see Thread#[] and Thread#[]=.\n\nThread local values are carried along with threads, and do not respect\nfibers.  For example:\n\n  Thread.new {\n    Thread.current.thread_variable_set(\"foo\", \"bar\") # set a thread local\n    Thread.current[\"foo\"] = \"bar\"                    # set a fiber local\n\n    Fiber.new {\n      Fiber.yield [\n        Thread.current.thread_variable_get(\"foo\"), # get the thread local\n        Thread.current[\"foo\"],                     # get the fiber local\n      ]\n    }.resume\n  }.join.value # => ['bar', nil]\n\nThe value \"bar\" is returned for the thread local, where nil is returned\nfor the fiber local.  The fiber is executed in the same thread, so the\nthread local values are available.",
  "thread_variable_set": "Sets a thread local with +key+ to +value+.  Note that these are local to\nthreads, and not to fibers.  Please see Thread#thread_variable_get and\nThread#[] for more information.",
  "thread_variables": "Returns an array of the names of the thread-local variables (as Symbols).\n\n   thr = Thread.new do\n     Thread.current.thread_variable_set(:cat, 'meow')\n     Thread.current.thread_variable_set(\"dog\", 'woof')\n   end\n   thr.join               #=> #<Thread:0x401b3f10 dead>\n   thr.thread_variables   #=> [:dog, :cat]\n\nNote that these are not fiber local variables.  Please see Thread#[] and\nThread#thread_variable_get for more details.",
  "thread_variable?": "Returns +true+ if the given string (or symbol) exists as a thread-local\nvariable.\n\n   me = Thread.current\n   me.thread_variable_set(:oliver, \"a\")\n   me.thread_variable?(:oliver)    #=> true\n   me.thread_variable?(:stanley)   #=> false\n\nNote that these are not fiber local variables.  Please see Thread#[] and\nThread#thread_variable_get for more details.",
  "alive?": "Returns +true+ if +thr+ is running or sleeping.\n\n   thr = Thread.new { }\n   thr.join                #=> #<Thread:0x401b3fb0 dead>\n   Thread.current.alive?   #=> true\n   thr.alive?              #=> false\n\nSee also #stop? and #status.",
  "stop?": "Returns +true+ if +thr+ is dead or sleeping.\n\n   a = Thread.new { Thread.stop }\n   b = Thread.current\n   a.stop?   #=> true\n   b.stop?   #=> false\n\nSee also #alive? and #status.",
  "safe_level": "Returns the safe level in effect for <i>thr</i>. Setting thread-local safe\nlevels can help when implementing sandboxes which run insecure code.\n\n   thr = Thread.new { $SAFE = 3; sleep }\n   Thread.current.safe_level   #=> 0\n   thr.safe_level              #=> 3",
  "group": "Returns the ThreadGroup which contains the given thread, or returns +nil+\nif +thr+ is not a member of any group.\n\n   Thread.main.group   #=> #<ThreadGroup:0x4029d914>",
  "backtrace": "Returns the current backtrace of the target thread.",
  "backtrace_locations": "Returns the execution stack for the target thread---an array containing\nbacktrace location objects.\n\nSee Thread::Backtrace::Location for more information.\n\nThis method behaves similarly to Kernel#caller_locations except it applies\nto a specific thread.",
  "inspect": "Dump the name, id, and status of _thr_ to a string.",
  "set_trace_func": "Establishes _proc_ on _thr_ as the handler for tracing, or\ndisables tracing if the parameter is +nil+.\n\nSee Kernel#set_trace_func.",
  "add_trace_func": "Adds _proc_ as a handler for tracing.\n\nSee Thread#set_trace_func and Kernel#set_trace_func.",
  "Backtrace": ""
}