{
  "stat": "Returns a <code>File::Stat</code> object for the named file (see\n<code>File::Stat</code>).\n\n   File.stat(\"testfile\").mtime   #=> Tue Apr 08 12:58:04 CDT 2003",
  "lstat": "Same as <code>IO#stat</code>, but does not follow the last symbolic\nlink. Instead, reports on the link itself.\n\n   File.symlink(\"testfile\", \"link2test\")   #=> 0\n   File.stat(\"testfile\").size              #=> 66\n   f = File.new(\"link2test\")\n   f.lstat.size                            #=> 8\n   f.stat.size                             #=> 66",
  "ftype": "Identifies the type of the named file; the return string is one of\n``<code>file</code>'', ``<code>directory</code>'',\n``<code>characterSpecial</code>'', ``<code>blockSpecial</code>'',\n``<code>fifo</code>'', ``<code>link</code>'',\n``<code>socket</code>'', or ``<code>unknown</code>''.\n\n   File.ftype(\"testfile\")            #=> \"file\"\n   File.ftype(\"/dev/tty\")            #=> \"characterSpecial\"\n   File.ftype(\"/tmp/.X11-unix/X0\")   #=> \"socket\"",
  "atime": "Returns the last access time (a <code>Time</code> object)\n for <i>file</i>, or epoch if <i>file</i> has not been accessed.\n\n   File.new(\"testfile\").atime   #=> Wed Dec 31 18:00:00 CST 1969",
  "mtime": "Returns the modification time for <i>file</i>.\n\n   File.new(\"testfile\").mtime   #=> Wed Apr 09 08:53:14 CDT 2003",
  "ctime": "Returns the change time for <i>file</i> (that is, the time directory\ninformation about the file was changed, not the file itself).\n\nNote that on Windows (NTFS), returns creation time (birth time).\n\n   File.new(\"testfile\").ctime   #=> Wed Apr 09 08:53:14 CDT 2003",
  "utime": "Sets the access and modification times of each\nnamed file to the first two arguments. Returns\nthe number of file names in the argument list.",
  "chmod": "Changes permission bits on <i>file</i> to the bit pattern\nrepresented by <i>mode_int</i>. Actual effects are platform\ndependent; on Unix systems, see <code>chmod(2)</code> for details.\nFollows symbolic links. Also see <code>File#lchmod</code>.\n\n   f = File.new(\"out\", \"w\");\n   f.chmod(0644)   #=> 0",
  "chown": "Changes the owner and group of <i>file</i> to the given numeric\nowner and group id's. Only a process with superuser privileges may\nchange the owner of a file. The current owner of a file may change\nthe file's group to any group to which the owner belongs. A\n<code>nil</code> or -1 owner or group id is ignored. Follows\nsymbolic links. See also <code>File#lchown</code>.\n\n   File.new(\"testfile\").chown(502, 1000)",
  "lchmod": "Equivalent to <code>File::chmod</code>, but does not follow symbolic\nlinks (so it will change the permissions associated with the link,\nnot the file referenced by the link). Often not available.",
  "lchown": "Equivalent to <code>File::chown</code>, but does not follow symbolic\nlinks (so it will change the owner associated with the link, not the\nfile referenced by the link). Often not available. Returns number\nof files in the argument list.",
  "link": "Creates a new name for an existing file using a hard link. Will not\noverwrite <i>new_name</i> if it already exists (raising a subclass\nof <code>SystemCallError</code>). Not available on all platforms.\n\n   File.link(\"testfile\", \".testfile\")   #=> 0\n   IO.readlines(\".testfile\")[0]         #=> \"This is line one\\n\"",
  "symlink": "Creates a symbolic link called <i>new_name</i> for the existing file\n<i>old_name</i>. Raises a <code>NotImplemented</code> exception on\nplatforms that do not support symbolic links.\n\n   File.symlink(\"testfile\", \"link2test\")   #=> 0",
  "readlink": "Returns the name of the file referenced by the given link.\nNot available on all platforms.\n\n   File.symlink(\"testfile\", \"link2test\")   #=> 0\n   File.readlink(\"link2test\")              #=> \"testfile\"",
  "unlink": "Deletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also <code>Dir::rmdir</code>.",
  "delete": "Deletes the named files, returning the number of names\npassed as arguments. Raises an exception on any error.\nSee also <code>Dir::rmdir</code>.",
  "rename": "Renames the given file to the new name. Raises a\n<code>SystemCallError</code> if the file cannot be renamed.\n\n   File.rename(\"afile\", \"afile.bak\")   #=> 0",
  "umask": "Returns the current umask value for this process. If the optional\nargument is given, set the umask to that value and return the\nprevious value. Umask values are <em>subtracted</em> from the\ndefault permissions, so a umask of <code>0222</code> would make a\nfile read-only for everyone.\n\n   File.umask(0006)   #=> 18\n   File.umask         #=> 6",
  "truncate": "Truncates <i>file</i> to at most <i>integer</i> bytes. The file\nmust be opened for writing. Not available on all platforms.\n\n   f = File.new(\"out\", \"w\")\n   f.syswrite(\"1234567890\")   #=> 10\n   f.truncate(5)              #=> 0\n   f.close()                  #=> nil\n   File.size(\"out\")           #=> 5",
  "expand_path": "Converts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n+dir_string+ is given, in which case it will be used as the\nstarting point. The given pathname may start with a\n``<code>~</code>'', which expands to the process owner's home\ndirectory (the environment variable +HOME+ must be set\ncorrectly). ``<code>~</code><i>user</i>'' expands to the named\nuser's home directory.\n\n   File.expand_path(\"~oracle/bin\")           #=> \"/home/oracle/bin\"\n\nA simple example of using +dir_string+ is as follows.\n   File.expand_path(\"ruby\", \"/usr/bin\")      #=> \"/usr/bin/ruby\"\n\nA more complex example which also resolves parent directory is as follows.\nSuppose we are in bin/mygem and want the absolute path of lib/mygem.rb.\n\n   File.expand_path(\"../../lib/mygem.rb\", __FILE__)\n   #=> \".../path/to/project/lib/mygem.rb\"\n\nSo first it resolves the parent of __FILE__, that is bin/, then go to the\nparent, the root of the project and appends +lib/mygem.rb+.",
  "absolute_path": "Converts a pathname to an absolute pathname. Relative paths are\nreferenced from the current working directory of the process unless\n<i>dir_string</i> is given, in which case it will be used as the\nstarting point. If the given pathname starts with a ``<code>~</code>''\nit is NOT expanded, it is treated as a normal directory name.\n\n   File.absolute_path(\"~oracle/bin\")       #=> \"<relative_path>/~oracle/bin\"",
  "realpath": "Returns the real (absolute) pathname of _pathname_ in the actual\n filesystem not containing symlinks or useless dots.\n\n If _dir_string_ is given, it is used as a base directory\n for interpreting relative pathname instead of the current directory.\n\n All components of the pathname must exist when this method is\n called.",
  "realdirpath": "Returns the real (absolute) pathname of _pathname_ in the actual filesystem.\n The real pathname doesn't contain symlinks or useless dots.\n\n If _dir_string_ is given, it is used as a base directory\n for interpreting relative pathname instead of the current directory.\n\n The last component of the real pathname can be nonexistent.",
  "basename": "Returns the last component of the filename given in <i>file_name</i>,\nwhich can be formed using both <code>File::SEPARATOR</code> and\n<code>File::ALT_SEPARATOR</code> as the separator when\n<code>File::ALT_SEPARATOR</code> is not <code>nil</code>. If\n<i>suffix</i> is given and present at the end of <i>file_name</i>,\nit is removed.\n\n   File.basename(\"/home/gumby/work/ruby.rb\")          #=> \"ruby.rb\"\n   File.basename(\"/home/gumby/work/ruby.rb\", \".rb\")   #=> \"ruby\"",
  "dirname": "Returns all components of the filename given in <i>file_name</i>\nexcept the last one. The filename can be formed using both\n<code>File::SEPARATOR</code> and <code>File::ALT_SEPARATOR</code> as the\nseparator when <code>File::ALT_SEPARATOR</code> is not <code>nil</code>.\n\n   File.dirname(\"/home/gumby/work/ruby.rb\")   #=> \"/home/gumby/work\"",
  "extname": "Returns the extension (the portion of file name in +path+\nstarting from the last period).\n\nIf +path+ is a dotfile, or starts with a period, then the starting\ndot is not dealt with the start of the extension.\n\nAn empty string will also be returned when the period is the last character\nin +path+.\n\n   File.extname(\"test.rb\")         #=> \".rb\"\n   File.extname(\"a/b/d/test.rb\")   #=> \".rb\"\n   File.extname(\"foo.\")\t       #=> \"\"\n   File.extname(\"test\")            #=> \"\"\n   File.extname(\".profile\")        #=> \"\"\n   File.extname(\".profile.sh\")     #=> \".sh\"",
  "path": "Returns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new(\"testfile\").path               #=> \"testfile\"\n   File.new(\"/tmp/../tmp/xxx\", \"w\").path   #=> \"/tmp/../tmp/xxx\"",
  "Separator": "separates directory parts in path",
  "SEPARATOR": "",
  "split": "Splits the given string into a directory and a file component and\nreturns them in a two-element array. See also\n<code>File::dirname</code> and <code>File::basename</code>.\n\n   File.split(\"/home/gumby/.profile\")   #=> [\"/home/gumby\", \".profile\"]",
  "join": "Returns a new string formed by joining the strings using\n<code>File::SEPARATOR</code>.\n\n   File.join(\"usr\", \"mail\", \"gumby\")   #=> \"usr/mail/gumby\"",
  "ALT_SEPARATOR": "platform specific alternative separator",
  "PATH_SEPARATOR": "path list separator",
  "size": "Returns the size of <i>file</i> in bytes.\n\n   File.new(\"testfile\").size   #=> 66",
  "flock": "Locks or unlocks a file according to <i>locking_constant</i> (a\nlogical <em>or</em> of the values in the table below).\nReturns <code>false</code> if <code>File::LOCK_NB</code> is\nspecified and the operation would otherwise have blocked. Not\navailable on all platforms.\n\nLocking constants (in class File):\n\n   LOCK_EX   | Exclusive lock. Only one process may hold an\n             | exclusive lock for a given file at a time.\n   ----------+------------------------------------------------\n   LOCK_NB   | Don't block when locking. May be combined\n             | with other lock options using logical or.\n   ----------+------------------------------------------------\n   LOCK_SH   | Shared lock. Multiple processes may each hold a\n             | shared lock for a given file at the same time.\n   ----------+------------------------------------------------\n   LOCK_UN   | Unlock.\n\nExample:\n\n   # update a counter using write lock\n   # don't use \"w\" because it truncates the file before lock.\n   File.open(\"counter\", File::RDWR|File::CREAT, 0644) {|f|\n     f.flock(File::LOCK_EX)\n     value = f.read.to_i + 1\n     f.rewind\n     f.write(\"#{value}\\n\")\n     f.flush\n     f.truncate(f.pos)\n   }\n\n   # read the counter using read lock\n   File.open(\"counter\", \"r\") {|f|\n     f.flock(File::LOCK_SH)\n     p f.read\n   }",
  "Constants": "File::Constants provides file-related constants.  All possible\nfile constants are listed in the documentation but they may not all\nbe present on your platform.\n\nIf the underlying platform doesn't define a constant the corresponding\nRuby constant is not defined.\n\nYour platform documentations (e.g. man open(2)) may describe more\ndetailed information.",
  "to_path": "Returns the pathname used to create <i>file</i> as a string. Does\nnot normalize the name.\n\n   File.new(\"testfile\").path               #=> \"testfile\"\n   File.new(\"/tmp/../tmp/xxx\", \"w\").path   #=> \"/tmp/../tmp/xxx\"",
  "Stat": "Objects of class <code>File::Stat</code> encapsulate common status\ninformation for <code>File</code> objects. The information is\nrecorded at the moment the <code>File::Stat</code> object is\ncreated; changes made to the file after that point will not be\nreflected. <code>File::Stat</code> objects are returned by\n<code>IO#stat</code>, <code>File::stat</code>,\n<code>File#lstat</code>, and <code>File::lstat</code>. Many of these\nmethods return platform-specific values, and not all values are\nmeaningful on all systems. See also <code>Kernel#test</code>.",
  "fnmatch": "Returns true if +path+ matches against +pattern+.  The pattern is not a\nregular expression; instead it follows rules similar to shell filename\nglobbing.  It may contain the following metacharacters:\n\n<code>*</code>::\n  Matches any file. Can be restricted by other values in the glob.\n  Equivalent to <code>/ .* /x</code> in regexp.\n\n  <code>*</code>::    Matches all files regular files\n  <code>c*</code>::   Matches all files beginning with <code>c</code>\n  <code>*c</code>::   Matches all files ending with <code>c</code>\n  <code>\\*c*</code>:: Matches all files that have <code>c</code> in them\n                      (including at the beginning or end).\n\n  To match hidden files (that start with a <code>.</code> set the\n  File::FNM_DOTMATCH flag.\n\n<code>**</code>::\n  Matches directories recursively or files expansively.\n\n<code>?</code>::\n  Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.\n\n<code>[set]</code>::\n  Matches any one character in +set+.  Behaves exactly like character sets\n  in Regexp, including set negation (<code>[^a-z]</code>).\n\n<code> \\ </code>::\n  Escapes the next metacharacter.\n\n<code>{a,b}</code>::\n  Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.\n  Behaves like a Regexp union (<code>(?:a|b)</code>).\n\n+flags+ is a bitwise OR of the <code>FNM_XXX</code> constants. The same\nglob pattern and flags are used by Dir::glob.\n\nExamples:\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial string\n\n   File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default\n   File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary\n   File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary\n   File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary\n   File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true",
  "fnmatch?": "Returns true if +path+ matches against +pattern+.  The pattern is not a\nregular expression; instead it follows rules similar to shell filename\nglobbing.  It may contain the following metacharacters:\n\n<code>*</code>::\n  Matches any file. Can be restricted by other values in the glob.\n  Equivalent to <code>/ .* /x</code> in regexp.\n\n  <code>*</code>::    Matches all files regular files\n  <code>c*</code>::   Matches all files beginning with <code>c</code>\n  <code>*c</code>::   Matches all files ending with <code>c</code>\n  <code>\\*c*</code>:: Matches all files that have <code>c</code> in them\n                      (including at the beginning or end).\n\n  To match hidden files (that start with a <code>.</code> set the\n  File::FNM_DOTMATCH flag.\n\n<code>**</code>::\n  Matches directories recursively or files expansively.\n\n<code>?</code>::\n  Matches any one character. Equivalent to <code>/.{1}/</code> in regexp.\n\n<code>[set]</code>::\n  Matches any one character in +set+.  Behaves exactly like character sets\n  in Regexp, including set negation (<code>[^a-z]</code>).\n\n<code> \\ </code>::\n  Escapes the next metacharacter.\n\n<code>{a,b}</code>::\n  Matches pattern a and pattern b if File::FNM_EXTGLOB flag is enabled.\n  Behaves like a Regexp union (<code>(?:a|b)</code>).\n\n+flags+ is a bitwise OR of the <code>FNM_XXX</code> constants. The same\nglob pattern and flags are used by Dir::glob.\n\nExamples:\n\n   File.fnmatch('cat',       'cat')        #=> true  # match entire string\n   File.fnmatch('cat',       'category')   #=> false # only match partial string\n\n   File.fnmatch('c{at,ub}s', 'cats')                    #=> false # { } isn't supported by default\n   File.fnmatch('c{at,ub}s', 'cats', File::FNM_EXTGLOB) #=> true  # { } is supported on FNM_EXTGLOB\n\n   File.fnmatch('c?t',     'cat')          #=> true  # '?' match only 1 character\n   File.fnmatch('c??t',    'cat')          #=> false # ditto\n   File.fnmatch('c*',      'cats')         #=> true  # '*' match 0 or more characters\n   File.fnmatch('c*t',     'c/a/b/t')      #=> true  # ditto\n   File.fnmatch('ca[a-z]', 'cat')          #=> true  # inclusive bracket expression\n   File.fnmatch('ca[^t]',  'cat')          #=> false # exclusive bracket expression ('^' or '!')\n\n   File.fnmatch('cat', 'CAT')                     #=> false # case sensitive\n   File.fnmatch('cat', 'CAT', File::FNM_CASEFOLD) #=> true  # case insensitive\n\n   File.fnmatch('?',   '/', File::FNM_PATHNAME)  #=> false # wildcard doesn't match '/' on FNM_PATHNAME\n   File.fnmatch('*',   '/', File::FNM_PATHNAME)  #=> false # ditto\n   File.fnmatch('[/]', '/', File::FNM_PATHNAME)  #=> false # ditto\n\n   File.fnmatch('\\?',   '?')                       #=> true  # escaped wildcard becomes ordinary\n   File.fnmatch('\\a',   'a')                       #=> true  # escaped ordinary remains ordinary\n   File.fnmatch('\\a',   '\\a', File::FNM_NOESCAPE)  #=> true  # FNM_NOESCAPE makes '\\' ordinary\n   File.fnmatch('[\\?]', '?')                       #=> true  # can escape inside bracket expression\n\n   File.fnmatch('*',   '.profile')                      #=> false # wildcard doesn't match leading\n   File.fnmatch('*',   '.profile', File::FNM_DOTMATCH)  #=> true  # period by default.\n   File.fnmatch('.*',  '.profile')                      #=> true\n\n   rbfiles = '**' '/' '*.rb' # you don't have to do like this. just write in single string.\n   File.fnmatch(rbfiles, 'main.rb')                    #=> false\n   File.fnmatch(rbfiles, './main.rb')                  #=> false\n   File.fnmatch(rbfiles, 'lib/song.rb')                #=> true\n   File.fnmatch('**.rb', 'main.rb')                    #=> true\n   File.fnmatch('**.rb', './main.rb')                  #=> false\n   File.fnmatch('**.rb', 'lib/song.rb')                #=> true\n   File.fnmatch('*',           'dave/.profile')                      #=> true\n\n   pattern = '*' '/' '*'\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME)  #=> false\n   File.fnmatch(pattern, 'dave/.profile', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true\n\n   pattern = '**' '/' 'foo'\n   File.fnmatch(pattern, 'a/b/c/foo', File::FNM_PATHNAME)     #=> true\n   File.fnmatch(pattern, '/a/b/c/foo', File::FNM_PATHNAME)    #=> true\n   File.fnmatch(pattern, 'c:/a/b/c/foo', File::FNM_PATHNAME)  #=> true\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME)    #=> false\n   File.fnmatch(pattern, 'a/.b/c/foo', File::FNM_PATHNAME | File::FNM_DOTMATCH) #=> true",
  "open": "call-seq:\n   IO.open(fd, mode=\"r\" [, opt])                -> io\n   IO.open(fd, mode=\"r\" [, opt]) { |io| block } -> obj\n\nWith no associated block, <code>IO.open</code> is a synonym for IO.new.  If\nthe optional code block is given, it will be passed +io+ as an argument,\nand the IO object will automatically be closed when the block terminates.\nIn this instance, IO.open returns the value of the block.\n\nSee IO.new for a description of the +fd+, +mode+ and +opt+ parameters.",
  "initialize": "Opens the file named by +filename+ according to the given +mode+ and\nreturns a new File object.\n\nSee IO.new for a description of +mode+ and +opt+.\n\nIf a file is being created, permission bits may be given in +perm+.  These\nmode and permission bits are platform dependent; on Unix systems, see\nopen(2) and chmod(2) man pages for details.\n\n=== Examples\n\n  f = File.new(\"testfile\", \"r\")\n  f = File.new(\"newfile\",  \"w+\")\n  f = File.new(\"newfile\", File::CREAT|File::TRUNC|File::RDWR, 0644)"
}