{
  "initialize": "_family_ should be an integer, a string or a symbol.\n- Socket::AF_INET, \"AF_INET\", \"INET\", :AF_INET, :INET\n- Socket::AF_UNIX, \"AF_UNIX\", \"UNIX\", :AF_UNIX, :UNIX\n- etc.\n\n_cmsg_level_ should be an integer, a string or a symbol.\n- Socket::SOL_SOCKET, \"SOL_SOCKET\", \"SOCKET\", :SOL_SOCKET and :SOCKET\n- Socket::IPPROTO_IP, \"IP\" and :IP\n- Socket::IPPROTO_IPV6, \"IPV6\" and :IPV6\n- Socket::IPPROTO_TCP, \"TCP\" and :TCP\n- etc.\n\n_cmsg_type_ should be an integer, a string or a symbol.\nIf a string/symbol is specified, it is interpreted depend on _cmsg_level_.\n- Socket::SCM_RIGHTS, \"SCM_RIGHTS\", \"RIGHTS\", :SCM_RIGHTS, :RIGHTS for SOL_SOCKET\n- Socket::IP_RECVTTL, \"RECVTTL\" and :RECVTTL for IPPROTO_IP\n- Socket::IPV6_PKTINFO, \"PKTINFO\" and :PKTINFO for IPPROTO_IPV6\n- etc.\n\n_cmsg_data_ should be a string.\n\n  p Socket::AncillaryData.new(:INET, :TCP, :NODELAY, \"\")\n  #=> #<Socket::AncillaryData: INET TCP NODELAY \"\">\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\")\n  #=> #<Socket::AncillaryData: INET6 IPV6 PKTINFO \"\">",
  "inspect": "returns a string which shows ancillarydata in human-readable form.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\").inspect\n  #=> \"#<Socket::AncillaryData: INET6 IPV6 PKTINFO \\\"\\\">\"",
  "family": "returns the socket family as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\").family\n  #=> 10",
  "level": "returns the cmsg level as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\").level\n  #=> 41",
  "type": "returns the cmsg type as an integer.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\").type\n  #=> 2",
  "data": "returns the cmsg data as a string.\n\n  p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\").data\n  #=> \"\"",
  "cmsg_is?": "tests the level and type of _ancillarydata_.\n\n  ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, \"\")\n  ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) #=> true\n  ancdata.cmsg_is?(:IPV6, :PKTINFO)       #=> true\n  ancdata.cmsg_is?(:IP, :PKTINFO)         #=> false\n  ancdata.cmsg_is?(:SOCKET, :RIGHTS)      #=> false",
  "int": "Returns the data in _ancillarydata_ as an int.\n\nThe size and endian is dependent on the host.\n\n  ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)\n  p ancdata.int #=> 2",
  "unix_rights": "returns the array of IO objects for SCM_RIGHTS control message in UNIX domain socket.\n\nThe class of the IO objects in the array is IO or Socket.\n\nThe array is attached to _ancillarydata_ when it is instantiated.\nFor example, BasicSocket#recvmsg attach the array when\nreceives a SCM_RIGHTS control message and :scm_rights=>true option is given.\n\n  # recvmsg needs :scm_rights=>true for unix_rights\n  s1, s2 = UNIXSocket.pair\n  p s1                                         #=> #<UNIXSocket:fd 3>\n  s1.sendmsg \"stdin and a socket\", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)\n  _, _, _, ctl = s2.recvmsg(:scm_rights=>true)\n  p ctl                                        #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>\n  p ctl.unix_rights                            #=> [#<IO:fd 6>, #<Socket:fd 7>]\n  p File.identical?(STDIN, ctl.unix_rights[0]) #=> true\n  p File.identical?(s1, ctl.unix_rights[1])    #=> true\n\n  # If :scm_rights=>true is not given, unix_rights returns nil\n  s1, s2 = UNIXSocket.pair\n  s1.sendmsg \"stdin and a socket\", 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)\n  _, _, _, ctl = s2.recvmsg\n  p ctl #=> #<Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7>\n  p ctl.unix_rights #=> nil",
  "timestamp": "returns the timestamp as a time object.\n\n_ancillarydata_ should be one of following type:\n- SOL_SOCKET/SCM_TIMESTAMP (microsecond) GNU/Linux, FreeBSD, NetBSD, OpenBSD, Solaris, MacOS X\n- SOL_SOCKET/SCM_TIMESTAMPNS (nanosecond) GNU/Linux\n- SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD\n\n  Addrinfo.udp(\"127.0.0.1\", 0).bind {|s1|\n    Addrinfo.udp(\"127.0.0.1\", 0).bind {|s2|\n      s1.setsockopt(:SOCKET, :TIMESTAMP, true)\n      s2.send \"a\", 0, s1.local_address\n      ctl = s1.recvmsg.last\n      p ctl    #=> #<Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581>\n      t = ctl.timestamp\n      p t      #=> 2009-02-24 17:35:46 +0900\n      p t.usec #=> 775581\n      p t.nsec #=> 775581000\n    }\n  }",
  "ip_pktinfo": "Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data.\n\nIP_PKTINFO is not standard.\n\nSupported platform: GNU/Linux\n\n  addr = Addrinfo.ip(\"127.0.0.1\")\n  ifindex = 0\n  spec_dest = Addrinfo.ip(\"127.0.0.1\")\n  ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)\n  p ancdata.ip_pktinfo\n  #=> [#<Addrinfo: 127.0.0.1>, 0, #<Addrinfo: 127.0.0.1>]",
  "ipv6_pktinfo": "Extracts addr and ifindex from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip(\"::1\")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo #=> [#<Addrinfo: ::1>, 0]",
  "ipv6_pktinfo_addr": "Extracts addr from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip(\"::1\")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo_addr #=> #<Addrinfo: ::1>",
  "ipv6_pktinfo_ifindex": "Extracts ifindex from IPV6_PKTINFO ancillary data.\n\nIPV6_PKTINFO is defined by RFC 3542.\n\n  addr = Addrinfo.ip(\"::1\")\n  ifindex = 0\n  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)\n  p ancdata.ipv6_pktinfo_ifindex #=> 0"
}