{
  "initialize": "Creates a new Enumerator object, which can be used as an\nEnumerable.\n\nIn the first form, iteration is defined by the given block, in\nwhich a \"yielder\" object, given as block parameter, can be used to\nyield a value by calling the +yield+ method (aliased as +<<+):\n\n  fib = Enumerator.new do |y|\n    a = b = 1\n    loop do\n      y << a\n      a, b = b, a + b\n    end\n  end\n\n  p fib.take(10) # => [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\nThe optional parameter can be used to specify how to calculate the size\nin a lazy fashion (see Enumerator#size). It can either be a value or\na callable object.\n\nIn the second, deprecated, form, a generated Enumerator iterates over the\ngiven object using the given method with the given arguments passed.\n\nUse of this form is discouraged.  Use Kernel#enum_for or Kernel#to_enum\ninstead.\n\n  e = Enumerator.new(ObjectSpace, :each_object)\n      #-> ObjectSpace.enum_for(:each_object)\n\n  e.select { |obj| obj.is_a?(Class) }  #=> array of all classes",
  "initialize_copy": ":nodoc:",
  "each": "Iterates over the block according to how this Enumerator was constructed.\nIf no block and no arguments are given, returns self.\n\n=== Examples\n\n  \"Hello, world!\".scan(/\\w+/)                     #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan, /\\w+/).to_a      #=> [\"Hello\", \"world\"]\n  \"Hello, world!\".to_enum(:scan).each(/\\w+/).to_a #=> [\"Hello\", \"world\"]\n\n  obj = Object.new\n\n  def obj.each_arg(a, b=:b, *rest)\n    yield a\n    yield b\n    yield rest\n    :method_returned\n  end\n\n  enum = obj.to_enum :each_arg, :a, :x\n\n  enum.each.to_a                  #=> [:a, :x, []]\n  enum.each.equal?(enum)          #=> true\n  enum.each { |elm| elm }         #=> :method_returned\n\n  enum.each(:y, :z).to_a          #=> [:a, :x, [:y, :z]]\n  enum.each(:y, :z).equal?(enum)  #=> false\n  enum.each(:y, :z) { |elm| elm } #=> :method_returned",
  "each_with_index": "Same as Enumerator#with_index(0), i.e. there is no starting offset.\n\nIf no block is given, a new Enumerator is returned that includes the index.",
  "each_with_object": "Iterates the given block for each element with an arbitrary object, +obj+,\nand returns +obj+\n\nIf no block is given, returns a new Enumerator.\n\n=== Example\n\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object(\"foo\")\n  to_three_with_string.each do |x,string|\n    puts \"#{string}: #{x}\"\n  end\n\n  # => foo:0\n  # => foo:1\n  # => foo:2",
  "with_index": "Iterates the given block for each element with an index, which\nstarts from +offset+.  If no block is given, returns a new Enumerator\nthat includes the index, starting from +offset+\n\n+offset+:: the starting index to use",
  "with_object": "Iterates the given block for each element with an arbitrary object, +obj+,\nand returns +obj+\n\nIf no block is given, returns a new Enumerator.\n\n=== Example\n\n  to_three = Enumerator.new do |y|\n    3.times do |x|\n      y << x\n    end\n  end\n\n  to_three_with_string = to_three.with_object(\"foo\")\n  to_three_with_string.each do |x,string|\n    puts \"#{string}: #{x}\"\n  end\n\n  # => foo:0\n  # => foo:1\n  # => foo:2",
  "next_values": "Returns the next object as an array in the enumerator, and move the\ninternal position forward.  When the position reached at the end,\nStopIteration is raised.\n\nThis method can be used to distinguish <code>yield</code> and <code>yield\nnil</code>.\n\n=== Example\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n    yield nil\n    yield [1, 2]\n  end\n  e = o.to_enum\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  p e.next_values\n  e = o.to_enum\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n  p e.next\n\n  ## yield args       next_values      next\n  #  yield            []               nil\n  #  yield 1          [1]              1\n  #  yield 1, 2       [1, 2]           [1, 2]\n  #  yield nil        [nil]            nil\n  #  yield [1, 2]     [[1, 2]]         [1, 2]\n\nNote that +next_values+ does not affect other non-external enumeration\nmethods unless underlying iteration method itself has side-effect, e.g.\nIO#each_line.",
  "peek_values": "Returns the next object as an array, similar to Enumerator#next_values, but\ndoesn't move the internal position forward.  If the position is already at\nthe end, StopIteration is raised.\n\n=== Example\n\n  o = Object.new\n  def o.each\n    yield\n    yield 1\n    yield 1, 2\n  end\n  e = o.to_enum\n  p e.peek_values    #=> []\n  e.next\n  p e.peek_values    #=> [1]\n  p e.peek_values    #=> [1]\n  e.next\n  p e.peek_values    #=> [1, 2]\n  e.next\n  p e.peek_values    # raises StopIteration",
  "next": "Returns the next object in the enumerator, and move the internal position\nforward.  When the position reached at the end, StopIteration is raised.\n\n=== Example\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration\n\nNote that enumeration sequence by +next+ does not affect other non-external\nenumeration methods, unless the underlying iteration methods itself has\nside-effect, e.g. IO#each_line.",
  "peek": "Returns the next object in the enumerator, but doesn't move the internal\nposition forward.  If the position is already at the end, StopIteration\nis raised.\n\n=== Example\n\n  a = [1,2,3]\n  e = a.to_enum\n  p e.next   #=> 1\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.peek   #=> 2\n  p e.next   #=> 2\n  p e.next   #=> 3\n  p e.next   #raises StopIteration",
  "feed": "Sets the value to be returned by the next yield inside +e+.\n\nIf the value is not set, the yield returns nil.\n\nThis value is cleared after being yielded.\n\n  # Array#map passes the array's elements to \"yield\" and collects the\n  # results of \"yield\" as an array.\n  # Following example shows that \"next\" returns the passed elements and\n  # values passed to \"feed\" are collected as an array which can be\n  # obtained by StopIteration#result.\n  e = [1,2,3].map\n  p e.next           #=> 1\n  e.feed \"a\"\n  p e.next           #=> 2\n  e.feed \"b\"\n  p e.next           #=> 3\n  e.feed \"c\"\n  begin\n    e.next\n  rescue StopIteration\n    p $!.result      #=> [\"a\", \"b\", \"c\"]\n  end\n\n  o = Object.new\n  def o.each\n    x = yield         # (2) blocks\n    p x               # (5) => \"foo\"\n    x = yield         # (6) blocks\n    p x               # (8) => nil\n    x = yield         # (9) blocks\n    p x               # not reached w/o another e.next\n  end\n\n  e = o.to_enum\n  e.next              # (1)\n  e.feed \"foo\"        # (3)\n  e.next              # (4)\n  e.next              # (7)\n                      # (10)",
  "rewind": "Rewinds the enumeration sequence to the beginning.\n\nIf the enclosed object responds to a \"rewind\" method, it is called.",
  "inspect": "Creates a printable version of <i>e</i>.",
  "size": "Returns the size of the enumerator, or +nil+ if it can't be calculated lazily.\n\n  (1..100).to_a.permutation(4).size # => 94109400\n  loop.size # => Float::INFINITY\n  (1..100).drop_while.size # => nil",
  "Lazy": "",
  "Generator": "",
  "Yielder": ""
}