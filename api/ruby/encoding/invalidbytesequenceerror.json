{
  "source_encoding_name": "Returns the source encoding name as a string.",
  "destination_encoding_name": "Returns the destination encoding name as a string.",
  "source_encoding": "Returns the source encoding as an encoding object.\n\nNote that the result may not be equal to the source encoding of\nthe encoding converter if the conversion has multiple steps.\n\n ec = Encoding::Converter.new(\"ISO-8859-1\", \"EUC-JP\") # ISO-8859-1 -> UTF-8 -> EUC-JP\n begin\n   ec.convert(\"\\xa0\") # NO-BREAK SPACE, which is available in UTF-8 but not in EUC-JP.\n rescue Encoding::UndefinedConversionError\n   p $!.source_encoding              #=> #<Encoding:UTF-8>\n   p $!.destination_encoding         #=> #<Encoding:EUC-JP>\n   p $!.source_encoding_name         #=> \"UTF-8\"\n   p $!.destination_encoding_name    #=> \"EUC-JP\"\n end",
  "destination_encoding": "Returns the destination encoding as an encoding object.",
  "error_bytes": "Returns the discarded bytes when Encoding::InvalidByteSequenceError occurs.\n\n ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n begin\n   ec.convert(\"abc\\xA1\\xFFdef\")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: \"\\xA1\" followed by \"\\xFF\" on EUC-JP>\n   puts $!.error_bytes.dump          #=> \"\\xA1\"\n   puts $!.readagain_bytes.dump      #=> \"\\xFF\"\n end",
  "readagain_bytes": "Returns the bytes to be read again when Encoding::InvalidByteSequenceError occurs.",
  "incomplete_input?": "Returns true if the invalid byte sequence error is caused by\npremature end of string.\n\n ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n\n begin\n   ec.convert(\"abc\\xA1z\")\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: \"\\xA1\" followed by \"z\" on EUC-JP>\n   p $!.incomplete_input?    #=> false\n end\n\n begin\n   ec.convert(\"abc\\xA1\")\n   ec.finish\n rescue Encoding::InvalidByteSequenceError\n   p $!      #=> #<Encoding::InvalidByteSequenceError: incomplete \"\\xA1\" on EUC-JP>\n   p $!.incomplete_input?    #=> true\n end"
}