{
  "asciicompat_encoding": "Returns the corresponding ASCII compatible encoding.\n\nReturns nil if the argument is an ASCII compatible encoding.\n\n\"corresponding ASCII compatible encoding\" is an ASCII compatible encoding which\ncan represents exactly the same characters as the given ASCII incompatible encoding.\nSo, no conversion undefined error occurs when converting between the two encodings.\n\n  Encoding::Converter.asciicompat_encoding(\"ISO-2022-JP\") #=> #<Encoding:stateless-ISO-2022-JP>\n  Encoding::Converter.asciicompat_encoding(\"UTF-16BE\") #=> #<Encoding:UTF-8>\n  Encoding::Converter.asciicompat_encoding(\"UTF-8\") #=> nil",
  "search_convpath": "Returns a conversion path.\n\n  p Encoding::Converter.search_convpath(\"ISO-8859-1\", \"EUC-JP\")\n  #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n  #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>]]\n\n  p Encoding::Converter.search_convpath(\"ISO-8859-1\", \"EUC-JP\", universal_newline: true)\n  or\n  p Encoding::Converter.search_convpath(\"ISO-8859-1\", \"EUC-JP\", newline: :universal)\n  #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n  #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n  #    \"universal_newline\"]\n\n  p Encoding::Converter.search_convpath(\"ISO-8859-1\", \"UTF-32BE\", universal_newline: true)\n  or\n  p Encoding::Converter.search_convpath(\"ISO-8859-1\", \"UTF-32BE\", newline: :universal)\n  #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n  #    \"universal_newline\",\n  #    [#<Encoding:UTF-8>, #<Encoding:UTF-32BE>]]",
  "initialize": "possible options elements:\n  hash form:\n    :invalid => nil            # raise error on invalid byte sequence (default)\n    :invalid => :replace       # replace invalid byte sequence\n    :undef => nil              # raise error on undefined conversion (default)\n    :undef => :replace         # replace undefined conversion\n    :replace => string         # replacement string (\"?\" or \"\\uFFFD\" if not specified)\n    :newline => :universal     # decorator for converting CRLF and CR to LF\n    :newline => :crlf          # decorator for converting LF to CRLF\n    :newline => :cr            # decorator for converting LF to CR\n    :universal_newline => true # decorator for converting CRLF and CR to LF\n    :crlf_newline => true      # decorator for converting LF to CRLF\n    :cr_newline => true        # decorator for converting LF to CR\n    :xml => :text              # escape as XML CharData.\n    :xml => :attr              # escape as XML AttValue\n  integer form:\n    Encoding::Converter::INVALID_REPLACE\n    Encoding::Converter::UNDEF_REPLACE\n    Encoding::Converter::UNDEF_HEX_CHARREF\n    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR\n    Encoding::Converter::CRLF_NEWLINE_DECORATOR\n    Encoding::Converter::CR_NEWLINE_DECORATOR\n    Encoding::Converter::XML_TEXT_DECORATOR\n    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR\n    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR\n\nEncoding::Converter.new creates an instance of Encoding::Converter.\n\nSource_encoding and destination_encoding should be a string or\nEncoding object.\n\nopt should be nil, a hash or an integer.\n\nconvpath should be an array.\nconvpath may contain\n- two-element arrays which contain encodings or encoding names, or\n- strings representing decorator names.\n\nEncoding::Converter.new optionally takes an option.\nThe option should be a hash or an integer.\nThe option hash can contain :invalid => nil, etc.\nThe option integer should be logical-or of constants such as\nEncoding::Converter::INVALID_REPLACE, etc.\n\n[:invalid => nil]\n  Raise error on invalid byte sequence.  This is a default behavior.\n[:invalid => :replace]\n  Replace invalid byte sequence by replacement string.\n[:undef => nil]\n  Raise an error if a character in source_encoding is not defined in destination_encoding.\n  This is a default behavior.\n[:undef => :replace]\n  Replace undefined character in destination_encoding with replacement string.\n[:replace => string]\n  Specify the replacement string.\n  If not specified, \"\\uFFFD\" is used for Unicode encodings and \"?\" for others.\n[:universal_newline => true]\n  Convert CRLF and CR to LF.\n[:crlf_newline => true]\n  Convert LF to CRLF.\n[:cr_newline => true]\n  Convert LF to CR.\n[:xml => :text]\n  Escape as XML CharData.\n  This form can be used as a HTML 4.0 #PCDATA.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;\n[:xml => :attr]\n  Escape as XML AttValue.\n  The converted result is quoted as \"...\".\n  This form can be used as a HTML 4.0 attribute value.\n  - '&' -> '&amp;'\n  - '<' -> '&lt;'\n  - '>' -> '&gt;'\n  - '\"' -> '&quot;'\n  - undefined characters in destination_encoding -> hexadecimal CharRef such as &#xHH;\n\nExamples:\n  # UTF-16BE to UTF-8\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\")\n\n  # Usually, decorators such as newline conversion are inserted last.\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\", :universal_newline => true)\n  p ec.convpath #=> [[#<Encoding:UTF-16BE>, #<Encoding:UTF-8>],\n                #    \"universal_newline\"]\n\n  # But, if the last encoding is ASCII incompatible,\n  # decorators are inserted before the last conversion.\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\", :crlf_newline => true)\n  p ec.convpath #=> [\"crlf_newline\",\n                #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]\n\n  # Conversion path can be specified directly.\n  ec = Encoding::Converter.new([\"universal_newline\", [\"EUC-JP\", \"UTF-8\"], [\"UTF-8\", \"UTF-16BE\"]])\n  p ec.convpath #=> [\"universal_newline\",\n                #    [#<Encoding:EUC-JP>, #<Encoding:UTF-8>],\n                #    [#<Encoding:UTF-8>, #<Encoding:UTF-16BE>]]",
  "inspect": "Returns a printable version of <i>ec</i>\n\n  ec = Encoding::Converter.new(\"iso-8859-1\", \"utf-8\")\n  puts ec.inspect    #=> #<Encoding::Converter: ISO-8859-1 to UTF-8>",
  "convpath": "Returns the conversion path of ec.\n\nThe result is an array of conversions.\n\n  ec = Encoding::Converter.new(\"ISO-8859-1\", \"EUC-JP\", crlf_newline: true)\n  p ec.convpath\n  #=> [[#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>],\n  #    [#<Encoding:UTF-8>, #<Encoding:EUC-JP>],\n  #    \"crlf_newline\"]\n\nEach element of the array is a pair of encodings or a string.\nA pair means an encoding conversion.\nA string means a decorator.\n\nIn the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means\na converter from ISO-8859-1 to UTF-8.\n\"crlf_newline\" means newline converter from LF to CRLF.",
  "source_encoding": "Returns the source encoding as an Encoding object.",
  "destination_encoding": "Returns the destination encoding as an Encoding object.",
  "primitive_convert": "possible opt elements:\n  hash form:\n    :partial_input => true           # source buffer may be part of larger source\n    :after_output => true            # stop conversion after output before input\n  integer form:\n    Encoding::Converter::PARTIAL_INPUT\n    Encoding::Converter::AFTER_OUTPUT\n\npossible results:\n   :invalid_byte_sequence\n   :incomplete_input\n   :undefined_conversion\n   :after_output\n   :destination_buffer_full\n   :source_buffer_empty\n   :finished\n\nprimitive_convert converts source_buffer into destination_buffer.\n\nsource_buffer should be a string or nil.\nnil means an empty string.\n\ndestination_buffer should be a string.\n\ndestination_byteoffset should be an integer or nil.\nnil means the end of destination_buffer.\nIf it is omitted, nil is assumed.\n\ndestination_bytesize should be an integer or nil.\nnil means unlimited.\nIf it is omitted, nil is assumed.\n\nopt should be nil, a hash or an integer.\nnil means no flags.\nIf it is omitted, nil is assumed.\n\nprimitive_convert converts the content of source_buffer from beginning\nand store the result into destination_buffer.\n\ndestination_byteoffset and destination_bytesize specify the region which\nthe converted result is stored.\ndestination_byteoffset specifies the start position in destination_buffer in bytes.\nIf destination_byteoffset is nil,\ndestination_buffer.bytesize is used for appending the result.\ndestination_bytesize specifies maximum number of bytes.\nIf destination_bytesize is nil,\ndestination size is unlimited.\nAfter conversion, destination_buffer is resized to\ndestination_byteoffset + actually produced number of bytes.\nAlso destination_buffer's encoding is set to destination_encoding.\n\nprimitive_convert drops the converted part of source_buffer.\nthe dropped part is converted in destination_buffer or\nbuffered in Encoding::Converter object.\n\nprimitive_convert stops conversion when one of following condition met.\n- invalid byte sequence found in source buffer (:invalid_byte_sequence)\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n- unexpected end of source buffer (:incomplete_input)\n  this occur only when :partial_input is not specified.\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n- character not representable in output encoding (:undefined_conversion)\n  +primitive_errinfo+ and +last_error+ methods returns the detail of the error.\n- after some output is generated, before input is done (:after_output)\n  this occur only when :after_output is specified.\n- destination buffer is full (:destination_buffer_full)\n  this occur only when destination_bytesize is non-nil.\n- source buffer is empty (:source_buffer_empty)\n  this occur only when :partial_input is specified.\n- conversion is finished (:finished)\n\nexample:\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\")\n  ret = ec.primitive_convert(src=\"pi\", dst=\"\", nil, 100)\n  p [ret, src, dst] #=> [:finished, \"\", \"\\x00p\\x00i\"]\n\n  ec = Encoding::Converter.new(\"UTF-8\", \"UTF-16BE\")\n  ret = ec.primitive_convert(src=\"pi\", dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"i\", \"\\x00\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"\", \"p\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:destination_buffer_full, \"\", \"\\x00\"]\n  ret = ec.primitive_convert(src, dst=\"\", nil, 1)\n  p [ret, src, dst] #=> [:finished, \"\", \"i\"]",
  "convert": "Convert source_string and return destination_string.\n\nsource_string is assumed as a part of source.\ni.e.  :partial_input=>true is specified internally.\nfinish method should be used last.\n\n  ec = Encoding::Converter.new(\"utf-8\", \"euc-jp\")\n  puts ec.convert(\"\\u3042\").dump     #=> \"\\xA4\\xA2\"\n  puts ec.finish.dump                #=> \"\"\n\n  ec = Encoding::Converter.new(\"euc-jp\", \"utf-8\")\n  puts ec.convert(\"\\xA4\").dump       #=> \"\"\n  puts ec.convert(\"\\xA2\").dump       #=> \"\\xE3\\x81\\x82\"\n  puts ec.finish.dump                #=> \"\"\n\n  ec = Encoding::Converter.new(\"utf-8\", \"iso-2022-jp\")\n  puts ec.convert(\"\\xE3\").dump       #=> \"\".force_encoding(\"ISO-2022-JP\")\n  puts ec.convert(\"\\x81\").dump       #=> \"\".force_encoding(\"ISO-2022-JP\")\n  puts ec.convert(\"\\x82\").dump       #=> \"\\e$B$\\\"\".force_encoding(\"ISO-2022-JP\")\n  puts ec.finish.dump                #=> \"\\e(B\".force_encoding(\"ISO-2022-JP\")\n\nIf a conversion error occur,\nEncoding::UndefinedConversionError or\nEncoding::InvalidByteSequenceError is raised.\nEncoding::Converter#convert doesn't supply methods to recover or restart\nfrom these exceptions.\nWhen you want to handle these conversion errors,\nuse Encoding::Converter#primitive_convert.",
  "finish": "Finishes the converter.\nIt returns the last part of the converted string.\n\n  ec = Encoding::Converter.new(\"utf-8\", \"iso-2022-jp\")\n  p ec.convert(\"\\u3042\")     #=> \"\\e$B$\\\"\"\n  p ec.finish                #=> \"\\e(B\"",
  "primitive_errinfo": "primitive_errinfo returns important information regarding the last error\nas a 5-element array:\n\n  [result, enc1, enc2, error_bytes, readagain_bytes]\n\nresult is the last result of primitive_convert.\n\nOther elements are only meaningful when result is\n:invalid_byte_sequence, :incomplete_input or :undefined_conversion.\n\nenc1 and enc2 indicate a conversion step as a pair of strings.\nFor example, a converter from EUC-JP to ISO-8859-1 converts\na string as follows: EUC-JP -> UTF-8 -> ISO-8859-1.\nSo [enc1, enc2] is either [\"EUC-JP\", \"UTF-8\"] or [\"UTF-8\", \"ISO-8859-1\"].\n\nerror_bytes and readagain_bytes indicate the byte sequences which caused the error.\nerror_bytes is discarded portion.\nreadagain_bytes is buffered portion which is read again on next conversion.\n\nExample:\n\n  # \\xff is invalid as EUC-JP.\n  ec = Encoding::Converter.new(\"EUC-JP\", \"Shift_JIS\")\n  ec.primitive_convert(src=\"\\xff\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"EUC-JP\", \"UTF-8\", \"\\xFF\", \"\"]\n\n  # HIRAGANA LETTER A (\\xa4\\xa2 in EUC-JP) is not representable in ISO-8859-1.\n  # Since this error is occur in UTF-8 to ISO-8859-1 conversion,\n  # error_bytes is HIRAGANA LETTER A in UTF-8 (\\xE3\\x81\\x82).\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\\xa2\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:undefined_conversion, \"UTF-8\", \"ISO-8859-1\", \"\\xE3\\x81\\x82\", \"\"]\n\n  # partial character is invalid\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:incomplete_input, \"EUC-JP\", \"UTF-8\", \"\\xA4\", \"\"]\n\n  # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by\n  # partial characters.\n  ec = Encoding::Converter.new(\"EUC-JP\", \"ISO-8859-1\")\n  ec.primitive_convert(src=\"\\xa4\", dst=\"\", nil, 10, Encoding::Converter::PARTIAL_INPUT)\n  p ec.primitive_errinfo\n  #=> [:source_buffer_empty, nil, nil, nil, nil]\n\n  # \\xd8\\x00\\x00@ is invalid as UTF-16BE because\n  # no low surrogate after high surrogate (\\xd8\\x00).\n  # It is detected by 3rd byte (\\00) which is part of next character.\n  # So the high surrogate (\\xd8\\x00) is discarded and\n  # the 3rd byte is read again later.\n  # Since the byte is buffered in ec, it is dropped from src.\n  ec = Encoding::Converter.new(\"UTF-16BE\", \"UTF-8\")\n  ec.primitive_convert(src=\"\\xd8\\x00\\x00@\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"UTF-16BE\", \"UTF-8\", \"\\xD8\\x00\", \"\\x00\"]\n  p src\n  #=> \"@\"\n\n  # Similar to UTF-16BE, \\x00\\xd8@\\x00 is invalid as UTF-16LE.\n  # The problem is detected by 4th byte.\n  ec = Encoding::Converter.new(\"UTF-16LE\", \"UTF-8\")\n  ec.primitive_convert(src=\"\\x00\\xd8@\\x00\", dst=\"\", nil, 10)\n  p ec.primitive_errinfo\n  #=> [:invalid_byte_sequence, \"UTF-16LE\", \"UTF-8\", \"\\x00\\xD8\", \"@\\x00\"]\n  p src\n  #=> \"\"",
  "insert_output": "Inserts string into the encoding converter.\nThe string will be converted to the destination encoding and\noutput on later conversions.\n\nIf the destination encoding is stateful,\nstring is converted according to the state and the state is updated.\n\nThis method should be used only when a conversion error occurs.\n\n ec = Encoding::Converter.new(\"utf-8\", \"iso-8859-1\")\n src = \"HIRAGANA LETTER A is \\u{3042}.\"\n dst = \"\"\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"HIRAGANA LETTER A is \", \".\"]\n ec.insert_output(\"<err>\")\n p ec.primitive_convert(src, dst)    #=> :finished\n puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"HIRAGANA LETTER A is <err>.\", \"\"]\n\n ec = Encoding::Converter.new(\"utf-8\", \"iso-2022-jp\")\n src = \"\\u{306F 3041 3068 2661 3002}\" # U+2661 is not representable in iso-2022-jp\n dst = \"\"\n p ec.primitive_convert(src, dst)    #=> :undefined_conversion\n puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"\\e$B$O$!$H\".force_encoding(\"ISO-2022-JP\"), \"\\xE3\\x80\\x82\"]\n ec.insert_output \"?\"                # state change required to output \"?\".\n p ec.primitive_convert(src, dst)    #=> :finished\n puts \"[#{dst.dump}, #{src.dump}]\"   #=> [\"\\e$B$O$!$H\\e(B?\\e$B!#\\e(B\".force_encoding(\"ISO-2022-JP\"), \"\"]",
  "putback": "call-seq\n  ec.putback                    -> string\n  ec.putback(max_numbytes)      -> string\n\nPut back the bytes which will be converted.\n\nThe bytes are caused by invalid_byte_sequence error.\nWhen invalid_byte_sequence error, some bytes are discarded and\nsome bytes are buffered to be converted later.\nThe latter bytes can be put back.\nIt can be observed by\nEncoding::InvalidByteSequenceError#readagain_bytes and\nEncoding::Converter#primitive_errinfo.\n\n  ec = Encoding::Converter.new(\"utf-16le\", \"iso-8859-1\")\n  src = \"\\x00\\xd8\\x61\\x00\"\n  dst = \"\"\n  p ec.primitive_convert(src, dst)   #=> :invalid_byte_sequence\n  p ec.primitive_errinfo     #=> [:invalid_byte_sequence, \"UTF-16LE\", \"UTF-8\", \"\\x00\\xD8\", \"a\\x00\"]\n  p ec.putback               #=> \"a\\x00\"\n  p ec.putback               #=> \"\"          # no more bytes to put back",
  "last_error": "Returns an exception object for the last conversion.\nReturns nil if the last conversion did not produce an error.\n\n\"error\" means that\nEncoding::InvalidByteSequenceError and Encoding::UndefinedConversionError for\nEncoding::Converter#convert and\n:invalid_byte_sequence, :incomplete_input and :undefined_conversion for\nEncoding::Converter#primitive_convert.\n\n ec = Encoding::Converter.new(\"utf-8\", \"iso-8859-1\")\n p ec.primitive_convert(src=\"\\xf1abcd\", dst=\"\")       #=> :invalid_byte_sequence\n p ec.last_error      #=> #<Encoding::InvalidByteSequenceError: \"\\xF1\" followed by \"a\" on UTF-8>\n p ec.primitive_convert(src, dst, nil, 1)             #=> :destination_buffer_full\n p ec.last_error      #=> nil",
  "replacement": "Returns the replacement string.\n\n ec = Encoding::Converter.new(\"euc-jp\", \"us-ascii\")\n p ec.replacement    #=> \"?\"\n\n ec = Encoding::Converter.new(\"euc-jp\", \"utf-8\")\n p ec.replacement    #=> \"\\uFFFD\"",
  "replacement=": "Sets the replacement string.\n\n ec = Encoding::Converter.new(\"utf-8\", \"us-ascii\", :undef => :replace)\n ec.replacement = \"<undef>\"\n p ec.convert(\"a \\u3042 b\")      #=> \"a <undef> b\"",
  "==": "",
  "INVALID_MASK": "Mask for invalid byte sequences",
  "INVALID_REPLACE": "Replace invalid byte sequences",
  "UNDEF_MASK": "Mask for a valid character in the source encoding but no related\ncharacter(s) in destination encoding.",
  "UNDEF_REPLACE": "Replace byte sequences that are undefined in the destination encoding.",
  "UNDEF_HEX_CHARREF": "Replace byte sequences that are undefined in the destination encoding\nwith an XML hexadecimal character reference.  This is valid for XML\nconversion.",
  "PARTIAL_INPUT": "Indicates the source may be part of a larger string.  See\nprimitive_convert for an example.",
  "AFTER_OUTPUT": "Stop converting after some output is complete but before all of the\ninput was consumed.  See primitive_convert for an example.",
  "UNIVERSAL_NEWLINE_DECORATOR": "Decorator for converting CRLF and CR to LF",
  "CRLF_NEWLINE_DECORATOR": "Decorator for converting LF to CRLF",
  "CR_NEWLINE_DECORATOR": "Decorator for converting LF to CR",
  "XML_TEXT_DECORATOR": "Escape as XML CharData",
  "XML_ATTR_CONTENT_DECORATOR": "Escape as XML AttValue",
  "XML_ATTR_QUOTE_DECORATOR": "Escape as XML AttValue"
}