{
  "initialize": "Not documented",
  "==": "Equality --- At the <code>Object</code> level, <code>==</code> returns\n<code>true</code> only if +obj+ and +other+ are the same object.\nTypically, this method is overridden in descendant classes to provide\nclass-specific meaning.\n\nUnlike <code>==</code>, the <code>equal?</code> method should never be\noverridden by subclasses as it is used to determine object identity\n(that is, <code>a.equal?(b)</code> if and only if <code>a</code> is the\nsame object as <code>b</code>):\n\n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n\nThe <code>eql?</code> method returns <code>true</code> if +obj+ and\n+other+ refer to the same hash key.  This is used by Hash to test members\nfor equality.  For objects of class <code>Object</code>, <code>eql?</code>\nis synonymous with <code>==</code>.  Subclasses normally continue this\ntradition by aliasing <code>eql?</code> to their overridden <code>==</code>\nmethod, but there are exceptions.  <code>Numeric</code> types, for\nexample, perform type conversion across <code>==</code>, but not across\n<code>eql?</code>, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false",
  "equal?": "Equality --- At the <code>Object</code> level, <code>==</code> returns\n<code>true</code> only if +obj+ and +other+ are the same object.\nTypically, this method is overridden in descendant classes to provide\nclass-specific meaning.\n\nUnlike <code>==</code>, the <code>equal?</code> method should never be\noverridden by subclasses as it is used to determine object identity\n(that is, <code>a.equal?(b)</code> if and only if <code>a</code> is the\nsame object as <code>b</code>):\n\n  obj = \"a\"\n  other = obj.dup\n\n  obj == other      #=> true\n  obj.equal? other  #=> false\n  obj.equal? obj    #=> true\n\nThe <code>eql?</code> method returns <code>true</code> if +obj+ and\n+other+ refer to the same hash key.  This is used by Hash to test members\nfor equality.  For objects of class <code>Object</code>, <code>eql?</code>\nis synonymous with <code>==</code>.  Subclasses normally continue this\ntradition by aliasing <code>eql?</code> to their overridden <code>==</code>\nmethod, but there are exceptions.  <code>Numeric</code> types, for\nexample, perform type conversion across <code>==</code>, but not across\n<code>eql?</code>, so:\n\n   1 == 1.0     #=> true\n   1.eql? 1.0   #=> false",
  "!": "Boolean negate.",
  "!=": "Returns true if two objects are not-equal, otherwise false.",
  "singleton_method_added": "Not documented",
  "singleton_method_removed": "Not documented",
  "singleton_method_undefined": "Not documented",
  "instance_eval": "Evaluates a string containing Ruby source code, or the given block,\nwithin the context of the receiver (_obj_). In order to set the\ncontext, the variable +self+ is set to _obj_ while\nthe code is executing, giving the code access to _obj_'s\ninstance variables. In the version of <code>instance_eval</code>\nthat takes a +String+, the optional second and third\nparameters supply a filename and starting line number that are used\nwhen reporting compilation errors.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_eval { @secret }   #=> 99",
  "instance_exec": "Executes the given block within the context of the receiver\n(_obj_). In order to set the context, the variable +self+ is set\nto _obj_ while the code is executing, giving the code access to\n_obj_'s instance variables.  Arguments are passed as block parameters.\n\n   class KlassWithSecret\n     def initialize\n       @secret = 99\n     end\n   end\n   k = KlassWithSecret.new\n   k.instance_exec(5) {|x| @secret+x }   #=> 104",
  "method_missing": "Invoked by Ruby when <i>obj</i> is sent a message it cannot handle.\n<i>symbol</i> is the symbol for the method called, and <i>args</i>\nare any arguments that were passed to it. By default, the interpreter\nraises an error when this method is called. However, it is possible\nto override the method to provide more dynamic behavior.\nIf it is decided that a particular method should not be handled, then\n<i>super</i> should be called, so that ancestors can pick up the\nmissing method.\nThe example below creates\na class <code>Roman</code>, which responds to methods with names\nconsisting of roman numerals, returning the corresponding integer\nvalues.\n\n   class Roman\n     def roman_to_int(str)\n       # ...\n     end\n     def method_missing(methId)\n       str = methId.id2name\n       roman_to_int(str)\n     end\n   end\n\n   r = Roman.new\n   r.iv      #=> 4\n   r.xxiii   #=> 23\n   r.mm      #=> 2000",
  "__send__": "Invokes the method identified by _symbol_, passing it any\n arguments specified. You can use <code>__send__</code> if the name\n +send+ clashes with an existing method in _obj_.\n When the method is identified by a string, the string is converted\n to a symbol.\n\n    class Klass\n      def hello(*args)\n        \"Hello \" + args.join(' ')\n      end\n    end\n    k = Klass.new\n    k.send :hello, \"gentle\", \"readers\"   #=> \"Hello gentle readers\"",
  "__id__": "Generates a Fixnum hash value for this object.\n\nThis function must have the property that <code>a.eql?(b)</code> implies\n<code>a.hash == b.hash</code>.\n\nThe hash value is used by Hash class.\n\nAny hash value that exceeds the capacity of a Fixnum will be truncated\nbefore being used."
}