{
  "initialize": ":nodoc:",
  "initialize_copy": ":nodoc:",
  "to_s": "Returns \"ARGF\".",
  "inspect": "Returns \"ARGF\".",
  "argv": "Returns the +ARGV+ array, which contains the arguments passed to your\nscript, one per element.\n\nFor example:\n\n    $ ruby argf.rb -v glark.txt\n\n    ARGF.argv   #=> [\"-v\", \"glark.txt\"]",
  "fileno": "Returns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3",
  "to_i": "Returns an integer representing the numeric file descriptor for\nthe current file. Raises an +ArgumentError+ if there isn't a current file.\n\n   ARGF.fileno    #=> 3",
  "to_io": "Returns an +IO+ object representing the current file. This will be a\n+File+ object unless the current file is a stream such as STDIN.\n\nFor example:\n\n   ARGF.to_io    #=> #<File:glark.txt>\n   ARGF.to_io    #=> #<IO:<STDIN>>",
  "to_write_io": "Returns IO instance tied to _ARGF_ for writing if inplace mode is\nenabled.",
  "each": "ARGF.each_line(sep=$/)       {|line| block }  -> ARGF\n   ARGF.each_line(sep=$/,limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                           -> an_enumerator\n\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts \"#{ARGF.lineno}: #{line}\"\n   end",
  "each_line": "ARGF.each_line(sep=$/)       {|line| block }  -> ARGF\n   ARGF.each_line(sep=$/,limit) {|line| block }  -> ARGF\n   ARGF.each_line(...)                           -> an_enumerator\n\nReturns an enumerator which iterates over each line (separated by _sep_,\nwhich defaults to your platform's newline character) of each file in\n+ARGV+. If a block is supplied, each line in turn will be yielded to the\nblock, otherwise an enumerator is returned.\nThe optional _limit_ argument is a +Fixnum+ specifying the maximum\nlength of each line; longer lines will be split according to this limit.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last line of the first file has been returned, the first line of the\nsecond file is returned. The +ARGF.filename+ and +ARGF.lineno+ methods can\nbe used to determine the filename and line number, respectively, of the\ncurrent line.\n\nFor example, the following code prints out each line of each named file\nprefixed with its line number, displaying the filename once per file:\n\n   ARGF.lines do |line|\n     puts ARGF.filename if ARGF.lineno == 1\n     puts \"#{ARGF.lineno}: #{line}\"\n   end",
  "each_byte": "ARGF.each_byte {|byte| block }  -> ARGF\n   ARGF.each_byte                  -> an_enumerator\n\nIterates over each byte of each file in +ARGV+.\nA byte is returned as a +Fixnum+ in the range 0..255.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last byte of the first file has been returned, the first byte of the\nsecond file is returned. The +ARGF.filename+ method can be used to\ndetermine the filename of the current byte.\n\nIf no block is given, an enumerator is returned instead.\n\nFor example:\n\n   ARGF.bytes.to_a  #=> [35, 32, ... 95, 10]",
  "each_char": "Iterates over each character of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last character of the first file has been returned, the first\ncharacter of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current character\nappears.\n\nIf no block is given, an enumerator is returned instead.",
  "each_codepoint": "Iterates over each codepoint of each file in +ARGF+.\n\nThis method allows you to treat the files supplied on the command line as\na single file consisting of the concatenation of each named file. After\nthe last codepoint of the first file has been returned, the first\ncodepoint of the second file is returned. The +ARGF.filename+ method can\nbe used to determine the name of the file in which the current codepoint\nappears.\n\nIf no block is given, an enumerator is returned instead.",
  "lines": "This is a deprecated alias for <code>each_line</code>.",
  "bytes": "This is a deprecated alias for <code>each_byte</code>.",
  "chars": "This is a deprecated alias for <code>each_char</code>.",
  "codepoints": "This is a deprecated alias for <code>each_codepoint</code>.",
  "read": "Reads _length_ bytes from ARGF. The files named on the command line\nare concatenated and treated as a single file by this method, so when\ncalled without arguments the contents of this pseudo file are returned in\ntheir entirety.\n\n_length_ must be a non-negative integer or nil. If it is a positive\ninteger, +read+ tries to read at most _length_ bytes. It returns nil\nif an EOF was encountered before anything could be read. Fewer than\n_length_ bytes may be returned if an EOF is encountered during the read.\n\nIf _length_ is omitted or is _nil_, it reads until EOF. A String is\nreturned even if EOF is encountered before any data is read.\n\nIf _length_ is zero, it returns _\"\"_.\n\nIf the optional _outbuf_ argument is present, it must reference a String,\nwhich will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\n\nFor example:\n\n   $ echo \"small\" > small.txt\n   $ echo \"large\" > large.txt\n   $ ./glark.rb small.txt large.txt\n\n   ARGF.read      #=> \"small\\nlarge\"\n   ARGF.read(200) #=> \"small\\nlarge\"\n   ARGF.read(2)   #=> \"sm\"\n   ARGF.read(0)   #=> \"\"\n\nNote that this method behaves like fread() function in C.  If you need the\nbehavior like read(2) system call, consider +ARGF.readpartial+.",
  "readpartial": "Reads at most _maxlen_ bytes from the ARGF stream.\n\nIf the optional _outbuf_ argument is present,\nit must reference a String, which will receive the data.\nThe <i>outbuf</i> will contain only the received data after the method call\neven if it is not empty at the beginning.\n\nIt raises <code>EOFError</code> on end of ARGF stream.\nSince ARGF stream is a concatenation of multiple files,\ninternally EOF is occur for each file.\nARGF.readpartial returns empty strings for EOFs except the last one and\nraises <code>EOFError</code> for the last one.",
  "read_nonblock": "Reads at most _maxlen_ bytes from the ARGF stream in non-blocking mode.",
  "readlines": "ARGF.to_a(sep=$/)     -> array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> \"This is line one\\n\"",
  "to_a": "ARGF.to_a(sep=$/)     -> array\n   ARGF.to_a(limit)      -> array\n   ARGF.to_a(sep, limit) -> array\n\nReads +ARGF+'s current file in its entirety, returning an +Array+ of its\nlines, one line per element. Lines are assumed to be separated by _sep_.\n\n   lines = ARGF.readlines\n   lines[0]                #=> \"This is line one\\n\"",
  "gets": "Returns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.",
  "readline": "Returns the next line from the current file in +ARGF+.\n\nBy default lines are assumed to be separated by +$/+; to use a different\ncharacter as a separator, supply it as a +String+ for the _sep_ argument.\n\nThe optional  _limit_ argument specifies how many characters of each line\nto return. By default all characters are returned.\n\nAn +EOFError+ is raised at the end of the file.",
  "getc": "Reads the next character from +ARGF+ and returns it as a +String+. Returns\n+nil+ at the end of the stream.\n\n+ARGF+ treats the files named on the command line as a single file created\nby concatenating their contents. After returning the last character of the\nfirst file, it returns the first character of the second file, and so on.\n\nFor example:\n\n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.getc  #=> \"f\"\n   ARGF.getc  #=> \"o\"\n   ARGF.getc  #=> \"o\"\n   ARGF.getc  #=> \"\\n\"\n   ARGF.getc  #=> nil\n   ARGF.getc  #=> nil",
  "getbyte": "Gets the next 8-bit byte (0..255) from +ARGF+. Returns +nil+ if called at\nthe end of the stream.\n\nFor example:\n\n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.getbyte #=> 102\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 111\n   ARGF.getbyte #=> 10\n   ARGF.getbyte #=> nil",
  "readchar": "Reads the next character from +ARGF+ and returns it as a +String+. Raises\nan +EOFError+ after the last character of the last file has been read.\n\nFor example:\n\n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.readchar  #=> \"f\"\n   ARGF.readchar  #=> \"o\"\n   ARGF.readchar  #=> \"o\"\n   ARGF.readchar  #=> \"\\n\"\n   ARGF.readchar  #=> end of file reached (EOFError)",
  "readbyte": "Reads the next 8-bit byte from ARGF and returns it as a +Fixnum+. Raises\nan +EOFError+ after the last byte of the last file has been read.\n\nFor example:\n\n   $ echo \"foo\" > file\n   $ ruby argf.rb file\n\n   ARGF.readbyte  #=> 102\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 111\n   ARGF.readbyte  #=> 10\n   ARGF.readbyte  #=> end of file reached (EOFError)",
  "tell": "Returns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> \"This is line one\\n\"\n   ARGF.pos    #=> 17",
  "seek": "Seeks to offset _amount_ (an +Integer+) in the +ARGF+ stream according to\nthe value of _whence_. See +IO#seek+ for further details.",
  "rewind": "Positions the current file to the beginning of input, resetting\n+ARGF.lineno+ to zero.\n\n   ARGF.readline   #=> \"This is line one\\n\"\n   ARGF.rewind     #=> 0\n   ARGF.lineno     #=> 0\n   ARGF.readline   #=> \"This is line one\\n\"",
  "pos": "Returns the current offset (in bytes) of the current file in +ARGF+.\n\n   ARGF.pos    #=> 0\n   ARGF.gets   #=> \"This is line one\\n\"\n   ARGF.pos    #=> 17",
  "pos=": "Seeks to the position given by _position_ (in bytes) in +ARGF+.\n\nFor example:\n\n    ARGF.pos = 17\n    ARGF.gets   #=> \"This is line two\\n\"",
  "eof": "Returns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo \"eof\" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> \"\\n\"\n   ARGF.eof?                 #=> true",
  "eof?": "Returns true if the current file in +ARGF+ is at end of file, i.e. it has\nno data to read. The stream must be opened for reading or an +IOError+\nwill be raised.\n\n   $ echo \"eof\" | ruby argf.rb\n\n   ARGF.eof?                 #=> false\n   3.times { ARGF.readchar }\n   ARGF.eof?                 #=> false\n   ARGF.readchar             #=> \"\\n\"\n   ARGF.eof?                 #=> true",
  "binmode": "Puts +ARGF+ into binary mode. Once a stream is in binary mode, it cannot\nbe reset to non-binary mode. This option has the following effects:\n\n*  Newline conversion is disabled.\n*  Encoding conversion is disabled.\n*  Content is treated as ASCII-8BIT.",
  "binmode?": "Returns true if +ARGF+ is being read in binary mode; false otherwise. (To\nenable binary mode use +ARGF.binmode+.\n\nFor example:\n\n   ARGF.binmode?  #=> false\n   ARGF.binmode\n   ARGF.binmode?  #=> true",
  "write": "Writes _string_ if inplace mode.",
  "print": "Writes the given object(s) to <em>ios</em>. The stream must be\nopened for writing. If the output field separator (<code>$,</code>)\nis not <code>nil</code>, it will be inserted between each object.\nIf the output record separator (<code>$\\\\</code>)\nis not <code>nil</code>, it will be appended to the output. If no\narguments are given, prints <code>$_</code>. Objects that aren't\nstrings will be converted by calling their <code>to_s</code> method.\nWith no argument, prints the contents of the variable <code>$_</code>.\nReturns <code>nil</code>.\n\n   $stdout.print(\"This is \", 100, \" percent.\\n\")\n\n<em>produces:</em>\n\n   This is 100 percent.",
  "putc": "If <i>obj</i> is <code>Numeric</code>, write the character whose code is\nthe least-significant byte of <i>obj</i>, otherwise write the first byte\nof the string representation of <i>obj</i> to <em>ios</em>. Note: This\nmethod is not safe for use with multi-byte characters as it will truncate\nthem.\n\n   $stdout.putc \"A\"\n   $stdout.putc 65\n\n<em>produces:</em>\n\n   AA",
  "puts": "Writes the given objects to <em>ios</em> as with\n<code>IO#print</code>. Writes a record separator (typically a\nnewline) after any that do not already end with a newline sequence.\nIf called with an array argument, writes each element on a new line.\nIf called without arguments, outputs a single record separator.\n\n   $stdout.puts(\"this\", \"is\", \"a\", \"test\")\n\n<em>produces:</em>\n\n   this\n   is\n   a\n   test",
  "printf": "Formats and writes to <em>ios</em>, converting parameters under\ncontrol of the format string. See <code>Kernel#sprintf</code>\nfor details.",
  "filename": "Returns the current filename. \"-\" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n   $ echo \"glark\" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.filename  #=> \"bar\"\n   ARGF.skip\n   ARGF.filename  #=> \"glark\"",
  "path": "Returns the current filename. \"-\" is returned when the current file is\nSTDIN.\n\nFor example:\n\n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n   $ echo \"glark\" > glark\n\n   $ ruby argf.rb foo bar glark\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.filename  #=> \"bar\"\n   ARGF.skip\n   ARGF.filename  #=> \"glark\"",
  "file": "Returns the current file as an +IO+ or +File+ object. #<IO:<STDIN>> is\nreturned when the current file is STDIN.\n\nFor example:\n\n   $ echo \"foo\" > foo\n   $ echo \"bar\" > bar\n\n   $ ruby argf.rb foo bar\n\n   ARGF.file      #=> #<File:foo>\n   ARGF.read(5)   #=> \"foo\\nb\"\n   ARGF.file      #=> #<File:bar>",
  "skip": "Sets the current file to the next file in ARGV. If there aren't any more\nfiles it has no effect.\n\nFor example:\n\n   $ ruby argf.rb foo bar\n   ARGF.filename  #=> \"foo\"\n   ARGF.skip\n   ARGF.filename  #=> \"bar\"",
  "close": "Closes the current file and skips to the next in the stream. Trying to\nclose a file that has already been closed causes an +IOError+ to be\nraised.\n\nFor example:\n\n   $ ruby argf.rb foo bar\n\n   ARGF.filename  #=> \"foo\"\n   ARGF.close\n   ARGF.filename  #=> \"bar\"\n   ARGF.close\n   ARGF.close     #=> closed stream (IOError)",
  "closed?": "Returns _true_ if the current file has been closed; _false_ otherwise. Use\n+ARGF.close+ to actually close the current file.",
  "lineno": "Returns the current line number of ARGF as a whole. This value\ncan be set manually with +ARGF.lineno=+.\n\nFor example:\n\n    ARGF.lineno   #=> 0\n    ARGF.readline #=> \"This is line 1\\n\"\n    ARGF.lineno   #=> 1",
  "lineno=": "Sets the line number of +ARGF+ as a whole to the given +Integer+.\n\n+ARGF+ sets the line number automatically as you read data, so normally\nyou will not need to set it explicitly. To access the current line number\nuse +ARGF.lineno+.\n\nFor example:\n\n    ARGF.lineno      #=> 0\n    ARGF.readline    #=> \"This is line 1\\n\"\n    ARGF.lineno      #=> 1\n    ARGF.lineno = 0  #=> 0\n    ARGF.lineno      #=> 0",
  "inplace_mode": "Returns the file extension appended to the names of modified files under\ninplace-edit mode. This value can be set using +ARGF.inplace_mode=+ or\npassing the +-i+ switch to the Ruby binary.",
  "inplace_mode=": "Sets the filename extension for inplace editing mode to the given String.\nEach file being edited has this value appended to its filename. The\nmodified file is saved under this new name.\n\nFor example:\n\n    $ ruby argf.rb file.txt\n\n    ARGF.inplace_mode = '.bak'\n    ARGF.lines do |line|\n      print line.sub(\"foo\",\"bar\")\n    end\n\nEach line of _file.txt_ has the first occurrence of \"foo\" replaced with\n\"bar\", then the new line is written out to _file.txt.bak_.",
  "external_encoding": "Returns the external encoding for files read from +ARGF+ as an +Encoding+\nobject. The external encoding is the encoding of the text as stored in a\nfile. Contrast with +ARGF.internal_encoding+, which is the encoding used\nto represent this text within Ruby.\n\nTo set the external encoding use +ARGF.set_encoding+.\n\nFor example:\n\n   ARGF.external_encoding  #=>  #<Encoding:UTF-8>",
  "internal_encoding": "Returns the internal encoding for strings read from +ARGF+ as an\n+Encoding+ object.\n\nIf +ARGF.set_encoding+ has been called with two encoding names, the second\nis returned. Otherwise, if +Encoding.default_external+ has been set, that\nvalue is returned. Failing that, if a default external encoding was\nspecified on the command-line, that value is used. If the encoding is\nunknown, nil is returned.",
  "set_encoding": "If single argument is specified, strings read from ARGF are tagged with\nthe encoding specified.\n\nIf two encoding names separated by a colon are given, e.g. \"ascii:utf-8\",\nthe read string is converted from the first encoding (external encoding)\nto the second encoding (internal encoding), then tagged with the second\nencoding.\n\nIf two arguments are specified, they must be encoding objects or encoding\nnames. Again, the first specifies the external encoding; the second\nspecifies the internal encoding.\n\nIf the external encoding and the internal encoding are specified, the\noptional +Hash+ argument can be used to adjust the conversion process. The\nstructure of this hash is explained in the +String#encode+ documentation.\n\nFor example:\n\n    ARGF.set_encoding('ascii')         # Tag the input as US-ASCII text\n    ARGF.set_encoding(Encoding::UTF_8) # Tag the input as UTF-8 text\n    ARGF.set_encoding('utf-8','ascii') # Transcode the input from US-ASCII\n                                       # to UTF-8."
}