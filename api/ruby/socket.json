{
  "initialize": "Creates a new socket object.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ is optional and should be a protocol defined in the domain.\nIf protocol is not given, 0 is used internally.\n\n  Socket.new(:INET, :STREAM) # TCP socket\n  Socket.new(:INET, :DGRAM)  # UDP socket\n  Socket.new(:UNIX, :STREAM) # UNIX stream socket\n  Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket",
  "connect": "Requests a connection to be made on the given +remote_sockaddr+. Returns 0 if\nsuccessful, otherwise an exception is raised.\n\n=== Parameter\n* +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object\n\n=== Example:\n\t# Pull down Google's web page\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )\n\tsocket.connect( sockaddr )\n\tsocket.write( \"GET / HTTP/1.0\\r\\n\\r\\n\" )\n\tresults = socket.read\n\n=== Unix-based Exceptions\nOn unix-based systems the following system exceptions may be raised if\nthe call to _connect_ fails:\n* Errno::EACCES - search permission is denied for a component of the prefix\n  path or write access to the +socket+ is denied\n* Errno::EADDRINUSE - the _sockaddr_ is already in use\n* Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the\n  local machine\n* Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for\n  the address family of the specified +socket+\n* Errno::EALREADY - a connection is already in progress for the specified\n  socket\n* Errno::EBADF - the +socket+ is not a valid file descriptor\n* Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections\n  refused the connection request\n* Errno::ECONNRESET - the remote host reset the connection request\n* Errno::EFAULT - the _sockaddr_ cannot be accessed\n* Errno::EHOSTUNREACH - the destination host cannot be reached (probably\n  because the host is down or a remote router cannot reach it)\n* Errno::EINPROGRESS - the O_NONBLOCK is set for the +socket+ and the\n  connection cannot be immediately established; the connection will be\n  established asynchronously\n* Errno::EINTR - the attempt to establish the connection was interrupted by\n  delivery of a signal that was caught; the connection will be established\n  asynchronously\n* Errno::EISCONN - the specified +socket+ is already connected\n* Errno::EINVAL - the address length used for the _sockaddr_ is not a valid\n  length for the address family or there is an invalid family in _sockaddr_\n* Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded\n  PATH_MAX\n* Errno::ENETDOWN - the local interface used to reach the destination is down\n* Errno::ENETUNREACH - no route to the network is present\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the calling +socket+ is listening and cannot be connected\n* Errno::EPROTOTYPE - the _sockaddr_ has a different type than the socket\n  bound to the specified peer address\n* Errno::ETIMEDOUT - the attempt to connect time out before a connection\n  was made.\n\nOn unix-based systems if the address family of the calling +socket+ is\nAF_UNIX the follow exceptions may be raised if the call to _connect_\nfails:\n* Errno::EIO - an i/o error occurred while reading from or writing to the\n  file system\n* Errno::ELOOP - too many symbolic links were encountered in translating\n  the pathname in _sockaddr_\n* Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX\n  characters, or an entire pathname exceeded PATH_MAX characters\n* Errno::ENOENT - a component of the pathname does not name an existing file\n  or the pathname is an empty string\n* Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_\n  is not a directory\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _connect_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use\n* Errno::EINTR - the socket was cancelled\n* Errno::EINPROGRESS - a blocking socket is in progress or the service provider\n  is still processing a callback function. Or a nonblocking connect call is\n  in progress on the +socket+.\n* Errno::EALREADY - see Errno::EINVAL\n* Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as\n  ADDR_ANY TODO check ADDRANY TO INADDR_ANY\n* Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with\n  with this +socket+\n* Errno::ECONNREFUSED - the target _sockaddr_ was not listening for connections\n  refused the connection request\n* Errno::EFAULT - the socket's internal address or address length parameter\n  is too small or is not a valid part of the user space address\n* Errno::EINVAL - the +socket+ is a listening socket\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::ENETUNREACH - the network cannot be reached from this host at this time\n* Errno::EHOSTUNREACH - no route to the network is present\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n* Errno::ETIMEDOUT - the attempt to connect time out before a connection\n  was made.\n* Errno::EWOULDBLOCK - the socket is marked as nonblocking and the\n  connection cannot be completed immediately\n* Errno::EACCES - the attempt to connect the datagram socket to the\n  broadcast address failed\n\n=== See\n* connect manual pages on unix-based systems\n* connect function in Microsoft's Winsock functions reference",
  "connect_nonblock": "Requests a connection to be made on the given +remote_sockaddr+ after\nO_NONBLOCK is set for the underlying file descriptor.\nReturns 0 if successful, otherwise an exception is raised.\n\n=== Parameter\n* +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object\n\n=== Example:\n\t# Pull down Google's web page\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new(AF_INET, SOCK_STREAM, 0)\n\tsockaddr = Socket.sockaddr_in(80, 'www.google.com')\n\tbegin # emulate blocking connect\n\t  socket.connect_nonblock(sockaddr)\n\trescue IO::WaitWritable\n\t  IO.select(nil, [socket]) # wait 3-way handshake completion\n\t  begin\n\t    socket.connect_nonblock(sockaddr) # check connection failure\n\t  rescue Errno::EISCONN\n\t  end\n\tend\n\tsocket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\")\n\tresults = socket.read\n\nRefer to Socket#connect for the exceptions that may be thrown if the call\nto _connect_nonblock_ fails.\n\nSocket#connect_nonblock may raise any error corresponding to connect(2) failure,\nincluding Errno::EINPROGRESS.\n\nIf the exception is Errno::EINPROGRESS,\nit is extended by IO::WaitWritable.\nSo IO::WaitWritable can be used to rescue the exceptions for retrying connect_nonblock.\n\n=== See\n* Socket#connect",
  "bind": "Binds to the given local address.\n\n=== Parameter\n* +local_sockaddr+ - the +struct+ sockaddr contained in a string or an Addrinfo object\n\n=== Example\n\trequire 'socket'\n\n\t# use Addrinfo\n\tsocket = Socket.new(:INET, :STREAM, 0)\n\tsocket.bind(Addrinfo.tcp(\"127.0.0.1\", 2222))\n\tp socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>\n\n\t# use struct sockaddr\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\n=== Unix-based Exceptions\nOn unix-based based systems the following system exceptions may be raised if\nthe call to _bind_ fails:\n* Errno::EACCES - the specified _sockaddr_ is protected and the current\n  user does not have permission to bind to it\n* Errno::EADDRINUSE - the specified _sockaddr_ is already in use\n* Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the\n  local machine\n* Errno::EAFNOSUPPORT - the specified _sockaddr_ is not a valid address for\n  the family of the calling +socket+\n* Errno::EBADF - the _sockaddr_ specified is not a valid file descriptor\n* Errno::EFAULT - the _sockaddr_ argument cannot be accessed\n* Errno::EINVAL - the +socket+ is already bound to an address, and the\n  protocol does not support binding to the new _sockaddr_ or the +socket+\n  has been shut down.\n* Errno::EINVAL - the address length is not a valid length for the address\n  family\n* Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded\n  PATH_MAX\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTSOCK - the +socket+ does not refer to a socket\n* Errno::EOPNOTSUPP - the socket type of the +socket+ does not support\n  binding to an address\n\nOn unix-based based systems if the address family of the calling +socket+ is\nSocket::AF_UNIX the follow exceptions may be raised if the call to _bind_\nfails:\n* Errno::EACCES - search permission is denied for a component of the prefix\n  path or write access to the +socket+ is denied\n* Errno::EDESTADDRREQ - the _sockaddr_ argument is a null pointer\n* Errno::EISDIR - same as Errno::EDESTADDRREQ\n* Errno::EIO - an i/o error occurred\n* Errno::ELOOP - too many symbolic links were encountered in translating\n  the pathname in _sockaddr_\n* Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX\n  characters, or an entire pathname exceeded PATH_MAX characters\n* Errno::ENOENT - a component of the pathname does not name an existing file\n  or the pathname is an empty string\n* Errno::ENOTDIR - a component of the path prefix of the pathname in _sockaddr_\n  is not a directory\n* Errno::EROFS - the name would reside on a read only filesystem\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _bind_ fails:\n* Errno::ENETDOWN-- the network is down\n* Errno::EACCES - the attempt to connect the datagram socket to the\n  broadcast address failed\n* Errno::EADDRINUSE - the socket's local address is already in use\n* Errno::EADDRNOTAVAIL - the specified address is not a valid address for this\n  computer\n* Errno::EFAULT - the socket's internal address or address length parameter\n  is too small or is not a valid part of the user space addressed\n* Errno::EINVAL - the +socket+ is already bound to an address\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOCK - the +socket+ argument does not refer to a socket\n\n=== See\n* bind manual pages on unix-based systems\n* bind function in Microsoft's Winsock functions reference",
  "listen": "Listens for connections, using the specified +int+ as the backlog. A call\nto _listen_ only applies if the +socket+ is of type SOCK_STREAM or\nSOCK_SEQPACKET.\n\n=== Parameter\n* +backlog+ - the maximum length of the queue for pending connections.\n\n=== Example 1\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\tsocket.listen( 5 )\n\n=== Example 2 (listening on an arbitrary port, unix-based systems only):\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsocket.listen( 1 )\n\n=== Unix-based Exceptions\nOn unix based systems the above will work because a new +sockaddr+ struct\nis created on the address ADDR_ANY, for an arbitrary port number as handed\noff by the kernel. It will not work on Windows, because Windows requires that\nthe +socket+ is bound by calling _bind_ before it can _listen_.\n\nIf the _backlog_ amount exceeds the implementation-dependent maximum\nqueue length, the implementation's maximum queue length will be used.\n\nOn unix-based based systems the following system exceptions may be raised if the\ncall to _listen_ fails:\n* Errno::EBADF - the _socket_ argument is not a valid file descriptor\n* Errno::EDESTADDRREQ - the _socket_ is not bound to a local address, and\n  the protocol does not support listening on an unbound socket\n* Errno::EINVAL - the _socket_ is already connected\n* Errno::ENOTSOCK - the _socket_ argument does not refer to a socket\n* Errno::EOPNOTSUPP - the _socket_ protocol does not support listen\n* Errno::EACCES - the calling process does not have appropriate privileges\n* Errno::EINVAL - the _socket_ has been shut down\n* Errno::ENOBUFS - insufficient resources are available in the system to\n  complete the call\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _listen_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EADDRINUSE - the socket's local address is already in use. This\n  usually occurs during the execution of _bind_ but could be delayed\n  if the call to _bind_ was to a partially wildcard address (involving\n  ADDR_ANY) and if a specific address needs to be committed at the\n  time of the call to _listen_\n* Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the\n  service provider is still processing a callback function\n* Errno::EINVAL - the +socket+ has not been bound with a call to _bind_.\n* Errno::EISCONN - the +socket+ is already connected\n* Errno::EMFILE - no more socket descriptors are available\n* Errno::ENOBUFS - no buffer space is available\n* Errno::ENOTSOC - +socket+ is not a socket\n* Errno::EOPNOTSUPP - the referenced +socket+ is not a type that supports\n  the _listen_ method\n\n=== See\n* listen manual pages on unix-based systems\n* listen function in Microsoft's Winsock functions reference",
  "accept": "Accepts a next connection.\nReturns a new Socket object and Addrinfo object.\n\n  serv = Socket.new(:INET, :STREAM, 0)\n  serv.listen(5)\n  c = Socket.new(:INET, :STREAM, 0)\n  c.connect(serv.connect_address)\n  p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]",
  "accept_nonblock": "Accepts an incoming connection using accept(2) after\nO_NONBLOCK is set for the underlying file descriptor.\nIt returns an array containing the accepted socket\nfor the incoming connection, _client_socket_,\nand an Addrinfo, _client_addrinfo_.\n\n=== Example\n\t# In one script, start this first\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new(AF_INET, SOCK_STREAM, 0)\n\tsockaddr = Socket.sockaddr_in(2200, 'localhost')\n\tsocket.bind(sockaddr)\n\tsocket.listen(5)\n\tbegin # emulate blocking accept\n\t  client_socket, client_addrinfo = socket.accept_nonblock\n\trescue IO::WaitReadable, Errno::EINTR\n\t  IO.select([socket])\n\t  retry\n\tend\n\tputs \"The client said, '#{client_socket.readline.chomp}'\"\n\tclient_socket.puts \"Hello from script one!\"\n\tsocket.close\n\n\t# In another script, start this second\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new(AF_INET, SOCK_STREAM, 0)\n\tsockaddr = Socket.sockaddr_in(2200, 'localhost')\n\tsocket.connect(sockaddr)\n\tsocket.puts \"Hello from script 2.\"\n\tputs \"The server said, '#{socket.readline.chomp}'\"\n\tsocket.close\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto _accept_nonblock_ fails.\n\nSocket#accept_nonblock may raise any error corresponding to accept(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED or Errno::EPROTO,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock.\n\n=== See\n* Socket#accept",
  "sysaccept": "Accepts an incoming connection returning an array containing the (integer)\nfile descriptor for the incoming connection, _client_socket_fd_,\nand an Addrinfo, _client_addrinfo_.\n\n=== Example\n\t# In one script, start this first\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\tsocket.listen( 5 )\n\tclient_fd, client_addrinfo = socket.sysaccept\n\tclient_socket = Socket.for_fd( client_fd )\n\tputs \"The client said, '#{client_socket.readline.chomp}'\"\n\tclient_socket.puts \"Hello from script one!\"\n\tsocket.close\n\n\t# In another script, start this second\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.connect( sockaddr )\n\tsocket.puts \"Hello from script 2.\"\n\tputs \"The server said, '#{socket.readline.chomp}'\"\n\tsocket.close\n\nRefer to Socket#accept for the exceptions that may be thrown if the call\nto _sysaccept_ fails.\n\n=== See\n* Socket#accept",
  "recvfrom": "Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more\nof the +MSG_+ options. The first element of the results, _mesg_, is the data\nreceived. The second element, _sender_addrinfo_, contains protocol-specific\naddress information of the sender.\n\n=== Parameters\n* +maxlen+ - the maximum number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n\t# In one file, start this first\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.bind( sockaddr )\n\tsocket.listen( 5 )\n\tclient, client_addrinfo = socket.accept\n\tdata = client.recvfrom( 20 )[0].chomp\n\tputs \"I only received 20 bytes '#{data}'\"\n\tsleep 1\n\tsocket.close\n\n\t# In another file, start this second\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new( AF_INET, SOCK_STREAM, 0 )\n\tsockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )\n\tsocket.connect( sockaddr )\n\tsocket.puts \"Watch this get cut short!\"\n\tsocket.close\n\n=== Unix-based Exceptions\nOn unix-based based systems the following system exceptions may be raised if the\ncall to _recvfrom_ fails:\n* Errno::EAGAIN - the +socket+ file descriptor is marked as O_NONBLOCK and no\n  data is waiting to be received; or MSG_OOB is set and no out-of-band data\n  is available and either the +socket+ file descriptor is marked as\n  O_NONBLOCK or the +socket+ does not support blocking to wait for\n  out-of-band-data\n* Errno::EWOULDBLOCK - see Errno::EAGAIN\n* Errno::EBADF - the +socket+ is not a valid file descriptor\n* Errno::ECONNRESET - a connection was forcibly closed by a peer\n* Errno::EFAULT - the socket's internal buffer, address or address length\n  cannot be accessed or written\n* Errno::EINTR - a signal interrupted _recvfrom_ before any data was available\n* Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is available\n* Errno::EIO - an i/o error occurred while reading from or writing to the\n  filesystem\n* Errno::ENOBUFS - insufficient resources were available in the system to\n  perform the operation\n* Errno::ENOMEM - insufficient memory was available to fulfill the request\n* Errno::ENOSR - there were insufficient STREAMS resources available to\n  complete the operation\n* Errno::ENOTCONN - a receive is attempted on a connection-mode socket that\n  is not connected\n* Errno::ENOTSOCK - the +socket+ does not refer to a socket\n* Errno::EOPNOTSUPP - the specified flags are not supported for this socket type\n* Errno::ETIMEDOUT - the connection timed out during connection establishment\n  or due to a transmission timeout on an active connection\n\n=== Windows Exceptions\nOn Windows systems the following system exceptions may be raised if\nthe call to _recvfrom_ fails:\n* Errno::ENETDOWN - the network is down\n* Errno::EFAULT - the internal buffer and from parameters on +socket+ are not\n  part of the user address space, or the internal fromlen parameter is\n  too small to accommodate the peer address\n* Errno::EINTR - the (blocking) call was cancelled by an internal call to\n  the WinSock function WSACancelBlockingCall\n* Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or\n  the service provider is still processing a callback function\n* Errno::EINVAL - +socket+ has not been bound with a call to _bind_, or an\n  unknown flag was specified, or MSG_OOB was specified for a socket with\n  SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal\n  len parameter on +socket+ was zero or negative\n* Errno::EISCONN - +socket+ is already connected. The call to _recvfrom_ is\n  not permitted with a connected socket on a socket that is connection\n  oriented or connectionless.\n* Errno::ENETRESET - the connection has been broken due to the keep-alive\n  activity detecting a failure while the operation was in progress.\n* Errno::EOPNOTSUPP - MSG_OOB was specified, but +socket+ is not stream-style\n  such as type SOCK_STREAM. OOB data is not supported in the communication\n  domain associated with +socket+, or +socket+ is unidirectional and\n  supports only send operations\n* Errno::ESHUTDOWN - +socket+ has been shutdown. It is not possible to\n  call _recvfrom_ on a socket after _shutdown_ has been invoked.\n* Errno::EWOULDBLOCK - +socket+ is marked as nonblocking and a  call to\n  _recvfrom_ would block.\n* Errno::EMSGSIZE - the message was too large to fit into the specified buffer\n  and was truncated.\n* Errno::ETIMEDOUT - the connection has been dropped, because of a network\n  failure or because the system on the other end went down without\n  notice\n* Errno::ECONNRESET - the virtual circuit was reset by the remote side\n  executing a hard or abortive close. The application should close the\n  socket; it is no longer usable. On a UDP-datagram socket this error\n  indicates a previous send operation resulted in an ICMP Port Unreachable\n  message.",
  "recvfrom_nonblock": "Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after\nO_NONBLOCK is set for the underlying file descriptor.\n_flags_ is zero or more of the +MSG_+ options.\nThe first element of the results, _mesg_, is the data received.\nThe second element, _sender_addrinfo_, contains protocol-specific address\ninformation of the sender.\n\nWhen recvfrom(2) returns 0, Socket#recvfrom_nonblock returns\nan empty string as data.\nThe meaning depends on the socket: EOF on TCP, empty packet on UDP, etc.\n\n=== Parameters\n* +maxlen+ - the maximum number of bytes to receive from the socket\n* +flags+ - zero or more of the +MSG_+ options\n\n=== Example\n\t# In one file, start this first\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new(AF_INET, SOCK_STREAM, 0)\n\tsockaddr = Socket.sockaddr_in(2200, 'localhost')\n\tsocket.bind(sockaddr)\n\tsocket.listen(5)\n\tclient, client_addrinfo = socket.accept\n\tbegin # emulate blocking recvfrom\n\t  pair = client.recvfrom_nonblock(20)\n\trescue IO::WaitReadable\n\t  IO.select([client])\n\t  retry\n\tend\n\tdata = pair[0].chomp\n\tputs \"I only received 20 bytes '#{data}'\"\n\tsleep 1\n\tsocket.close\n\n\t# In another file, start this second\n\trequire 'socket'\n\tinclude Socket::Constants\n\tsocket = Socket.new(AF_INET, SOCK_STREAM, 0)\n\tsockaddr = Socket.sockaddr_in(2200, 'localhost')\n\tsocket.connect(sockaddr)\n\tsocket.puts \"Watch this get cut short!\"\n\tsocket.close\n\nRefer to Socket#recvfrom for the exceptions that may be thrown if the call\nto _recvfrom_nonblock_ fails.\n\nSocket#recvfrom_nonblock may raise any error corresponding to recvfrom(2) failure,\nincluding Errno::EWOULDBLOCK.\n\nIf the exception is Errno::EWOULDBLOCK or Errno::AGAIN,\nit is extended by IO::WaitReadable.\nSo IO::WaitReadable can be used to rescue the exceptions for retrying recvfrom_nonblock.\n\n=== See\n* Socket#recvfrom",
  "socketpair": "Creates a pair of sockets connected each other.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain,\ndefaults to 0 for the domain.\n\n  s1, s2 = Socket.pair(:UNIX, :STREAM, 0)\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  s1.close\n  p s2.recv(10) #=> \"ab\"\n  p s2.recv(10) #=> \"\"\n  p s2.recv(10) #=> \"\"\n\n  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  p s2.recv(10) #=> \"a\"\n  p s2.recv(10) #=> \"b\"",
  "pair": "Creates a pair of sockets connected each other.\n\n_domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the domain,\ndefaults to 0 for the domain.\n\n  s1, s2 = Socket.pair(:UNIX, :STREAM, 0)\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  s1.close\n  p s2.recv(10) #=> \"ab\"\n  p s2.recv(10) #=> \"\"\n  p s2.recv(10) #=> \"\"\n\n  s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)\n  s1.send \"a\", 0\n  s1.send \"b\", 0\n  p s2.recv(10) #=> \"a\"\n  p s2.recv(10) #=> \"b\"",
  "gethostname": "",
  "gethostbyname": "Obtains the host information for _hostname_.\n\n  p Socket.gethostbyname(\"hal\") #=> [\"localhost\", [\"hal\"], 2, \"\\x7F\\x00\\x00\\x01\"]",
  "gethostbyaddr": "Obtains the host information for _address_.\n\n  p Socket.gethostbyaddr([221,186,184,68].pack(\"CCCC\"))\n  #=> [\"carbon.ruby-lang.org\", [], 2, \"\\xDD\\xBA\\xB8D\"]",
  "getservbyname": "Obtains the port number for _service_name_.\n\nIf _protocol_name_ is not given, \"tcp\" is assumed.\n\n  Socket.getservbyname(\"smtp\")          #=> 25\n  Socket.getservbyname(\"shell\")         #=> 514\n  Socket.getservbyname(\"syslog\", \"udp\") #=> 514",
  "getservbyport": "Obtains the port number for _port_.\n\nIf _protocol_name_ is not given, \"tcp\" is assumed.\n\n  Socket.getservbyport(80)         #=> \"www\"\n  Socket.getservbyport(514, \"tcp\") #=> \"shell\"\n  Socket.getservbyport(514, \"udp\") #=> \"syslog\"",
  "getaddrinfo": "Obtains address information for _nodename_:_servname_.\n\n_family_ should be an address family such as: :INET, :INET6, :UNIX, etc.\n\n_socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.\n\n_protocol_ should be a protocol defined in the family,\nand defaults to 0 for the family.\n\n_flags_ should be bitwise OR of Socket::AI_* constants.\n\n  Socket.getaddrinfo(\"www.ruby-lang.org\", \"http\", nil, :STREAM)\n  #=> [[\"AF_INET\", 80, \"carbon.ruby-lang.org\", \"221.186.184.68\", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP\n\n  Socket.getaddrinfo(\"localhost\", nil)\n  #=> [[\"AF_INET\", 0, \"localhost\", \"127.0.0.1\", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP\n  #    [\"AF_INET\", 0, \"localhost\", \"127.0.0.1\", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP\n  #    [\"AF_INET\", 0, \"localhost\", \"127.0.0.1\", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP\n\n_reverse_lookup_ directs the form of the third element, and has to\nbe one of below.  If _reverse_lookup_ is omitted, the default value is +nil+.\n\n  +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.\n  +false+, +:numeric+:  hostname is same as numeric address.\n  +nil+:              obey to the current +do_not_reverse_lookup+ flag.\n\nIf Addrinfo object is preferred, use Addrinfo.getaddrinfo.",
  "getnameinfo": "Obtains name information for _sockaddr_.\n\n_sockaddr_ should be one of follows.\n- packed sockaddr string such as Socket.sockaddr_in(80, \"127.0.0.1\")\n- 3-elements array such as [\"AF_INET\", 80, \"127.0.0.1\"]\n- 4-elements array such as [\"AF_INET\", 80, ignored, \"127.0.0.1\"]\n\n_flags_ should be bitwise OR of Socket::NI_* constants.\n\nNote:\nThe last form is compatible with IPSocket#addr and IPSocket#peeraddr.\n\n  Socket.getnameinfo(Socket.sockaddr_in(80, \"127.0.0.1\"))       #=> [\"localhost\", \"www\"]\n  Socket.getnameinfo([\"AF_INET\", 80, \"127.0.0.1\"])              #=> [\"localhost\", \"www\"]\n  Socket.getnameinfo([\"AF_INET\", 80, \"localhost\", \"127.0.0.1\"]) #=> [\"localhost\", \"www\"]\n\nIf Addrinfo object is preferred, use Addrinfo#getnameinfo.",
  "sockaddr_in": "Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.\n\n  Socket.sockaddr_in(80, \"127.0.0.1\")\n  #=> \"\\x02\\x00\\x00P\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n  Socket.sockaddr_in(80, \"::1\")\n  #=> \"\\n\\x00\\x00P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\"",
  "pack_sockaddr_in": "Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string.\n\n  Socket.sockaddr_in(80, \"127.0.0.1\")\n  #=> \"\\x02\\x00\\x00P\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n  Socket.sockaddr_in(80, \"::1\")\n  #=> \"\\n\\x00\\x00P\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\"",
  "unpack_sockaddr_in": "Unpacks _sockaddr_ into port and ip_address.\n\n_sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6.\n\n  sockaddr = Socket.sockaddr_in(80, \"127.0.0.1\")\n  p sockaddr #=> \"\\x02\\x00\\x00P\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n  p Socket.unpack_sockaddr_in(sockaddr) #=> [80, \"127.0.0.1\"]",
  "sockaddr_un": "Packs _path_ as an AF_UNIX sockaddr string.\n\n  Socket.sockaddr_un(\"/tmp/sock\") #=> \"\\x01\\x00/tmp/sock\\x00\\x00...\"",
  "pack_sockaddr_un": "Packs _path_ as an AF_UNIX sockaddr string.\n\n  Socket.sockaddr_un(\"/tmp/sock\") #=> \"\\x01\\x00/tmp/sock\\x00\\x00...\"",
  "unpack_sockaddr_un": "Unpacks _sockaddr_ into path.\n\n_sockaddr_ should be a string or an addrinfo for AF_UNIX.\n\n  sockaddr = Socket.sockaddr_un(\"/tmp/sock\")\n  p Socket.unpack_sockaddr_un(sockaddr) #=> \"/tmp/sock\"",
  "ip_address_list": "Returns local IP addresses as an array.\n\nThe array contains Addrinfo objects.\n\n pp Socket.ip_address_list\n #=> [#<Addrinfo: 127.0.0.1>,\n      #<Addrinfo: 192.168.0.128>,\n      #<Addrinfo: ::1>,\n      ...]",
  "Option": "Socket::Option represents a socket option used by\nBasicSocket#getsockopt and BasicSocket#setsockopt.  A socket option\ncontains the socket #family, protocol #level, option name #optname and\noption value #data.",
  "AncillaryData": "Socket::AncillaryData represents the ancillary data (control information)\nused by sendmsg and recvmsg system call.  It contains socket #family,\ncontrol message (cmsg) #level, cmsg #type and cmsg #data.",
  "Constants": "Socket::Constants provides socket-related constants.  All possible\nsocket constants are listed in the documentation but they may not all\nbe present on your platform.\n\nIf the underlying platform doesn't define a constant the corresponding\nRuby constant is not defined.",
  "SOCK_STREAM": "A stream socket provides a sequenced, reliable two-way connection for a byte stream",
  "SOCK_DGRAM": "A datagram socket provides connectionless, unreliable messaging",
  "SOCK_RAW": "A raw socket provides low-level access for direct access or implementing network protocols",
  "SOCK_RDM": "A reliable datagram socket provides reliable delivery of messages",
  "SOCK_SEQPACKET": "A sequential packet socket provides sequenced, reliable two-way connection for datagrams",
  "SOCK_PACKET": "Device-level packet access",
  "AF_UNSPEC": "Unspecified protocol, any supported address family",
  "PF_UNSPEC": "Unspecified protocol, any supported address family",
  "AF_INET": "IPv4 protocol",
  "PF_INET": "IPv4 protocol",
  "AF_INET6": "IPv6 protocol",
  "PF_INET6": "IPv6 protocol",
  "AF_UNIX": "UNIX sockets",
  "PF_UNIX": "UNIX sockets",
  "AF_AX25": "AX.25 protocol",
  "PF_AX25": "AX.25 protocol",
  "AF_IPX": "IPX protocol",
  "PF_IPX": "IPX protocol",
  "AF_APPLETALK": "AppleTalk protocol",
  "PF_APPLETALK": "AppleTalk protocol",
  "AF_LOCAL": "Host-internal protocols",
  "PF_LOCAL": "Host-internal protocols",
  "AF_IMPLINK": "ARPANET IMP protocol",
  "PF_IMPLINK": "ARPANET IMP protocol",
  "AF_PUP": "PARC Universal Packet protocol",
  "PF_PUP": "PARC Universal Packet protocol",
  "AF_CHAOS": "MIT CHAOS protocols",
  "PF_CHAOS": "MIT CHAOS protocols",
  "AF_NS": "XEROX NS protocols",
  "PF_NS": "XEROX NS protocols",
  "AF_ISO": "ISO Open Systems Interconnection protocols",
  "PF_ISO": "ISO Open Systems Interconnection protocols",
  "AF_OSI": "ISO Open Systems Interconnection protocols",
  "PF_OSI": "ISO Open Systems Interconnection protocols",
  "AF_ECMA": "European Computer Manufacturers protocols",
  "PF_ECMA": "European Computer Manufacturers protocols",
  "AF_DATAKIT": "Datakit protocol",
  "PF_DATAKIT": "Datakit protocol",
  "AF_CCITT": "CCITT (now ITU-T) protocols",
  "PF_CCITT": "CCITT (now ITU-T) protocols",
  "AF_SNA": "IBM SNA protocol",
  "PF_SNA": "IBM SNA protocol",
  "AF_DEC": "DECnet protocol",
  "PF_DEC": "DECnet protocol",
  "AF_DLI": "DEC Direct Data Link Interface protocol",
  "PF_DLI": "DEC Direct Data Link Interface protocol",
  "AF_LAT": "Local Area Transport protocol",
  "PF_LAT": "Local Area Transport protocol",
  "AF_HYLINK": "NSC Hyperchannel protocol",
  "PF_HYLINK": "NSC Hyperchannel protocol",
  "AF_ROUTE": "Internal routing protocol",
  "PF_ROUTE": "Internal routing protocol",
  "AF_LINK": "Link layer interface",
  "PF_LINK": "Link layer interface",
  "AF_COIP": "Connection-oriented IP",
  "PF_COIP": "Connection-oriented IP",
  "AF_CNT": "Computer Network Technology",
  "PF_CNT": "Computer Network Technology",
  "AF_SIP": "Simple Internet Protocol",
  "PF_SIP": "Simple Internet Protocol",
  "AF_NDRV": "Network driver raw access",
  "PF_NDRV": "Network driver raw access",
  "AF_ISDN": "Integrated Services Digital Network",
  "PF_ISDN": "Integrated Services Digital Network",
  "AF_NATM": "Native ATM access",
  "PF_NATM": "Native ATM access",
  "AF_SYSTEM": "",
  "PF_SYSTEM": "",
  "AF_NETBIOS": "NetBIOS",
  "PF_NETBIOS": "NetBIOS",
  "AF_PPP": "Point-to-Point Protocol",
  "PF_PPP": "Point-to-Point Protocol",
  "AF_ATM": "Asynchronous Transfer Mode",
  "PF_ATM": "Asynchronous Transfer Mode",
  "AF_NETGRAPH": "Netgraph sockets",
  "PF_NETGRAPH": "Netgraph sockets",
  "AF_MAX": "Maximum address family for this platform",
  "PF_MAX": "Maximum address family for this platform",
  "AF_PACKET": "Direct link-layer access",
  "PF_PACKET": "Direct link-layer access",
  "AF_E164": "CCITT (ITU-T) E.164 recommendation",
  "PF_XTP": "eXpress Transfer Protocol",
  "PF_RTIP": "",
  "PF_PIP": "",
  "PF_KEY": "",
  "MSG_OOB": "Process out-of-band data",
  "MSG_PEEK": "Peek at incoming message",
  "MSG_DONTROUTE": "Send without using the routing tables",
  "MSG_EOR": "Data completes record",
  "MSG_TRUNC": "Data discarded before delivery",
  "MSG_CTRUNC": "Control data lost before delivery",
  "MSG_WAITALL": "Wait for full request or error",
  "MSG_DONTWAIT": "This message should be non-blocking",
  "MSG_EOF": "Data completes connection",
  "MSG_FLUSH": "Start of a hold sequence.  Dumps to so_temp",
  "MSG_HOLD": "Hold fragment in so_temp",
  "MSG_SEND": "Send the packet in so_temp",
  "MSG_HAVEMORE": "Data ready to be read",
  "MSG_RCVMORE": "Data remains in the current packet",
  "MSG_COMPAT": "End of record",
  "MSG_PROXY": "Wait for full request",
  "MSG_FIN": "",
  "MSG_SYN": "",
  "MSG_CONFIRM": "Confirm path validity",
  "MSG_RST": "",
  "MSG_ERRQUEUE": "Fetch message from error queue",
  "MSG_NOSIGNAL": "Do not generate SIGPIPE",
  "MSG_MORE": "Sender will send more",
  "MSG_FASTOPEN": "Reduce step of the handshake process",
  "SOL_SOCKET": "Socket-level options",
  "SOL_IP": "IP socket options",
  "SOL_IPX": "IPX socket options",
  "SOL_AX25": "AX.25 socket options",
  "SOL_ATALK": "AppleTalk socket options",
  "SOL_TCP": "TCP socket options",
  "SOL_UDP": "UDP socket options",
  "IPPROTO_IP": "Dummy protocol for IP",
  "IPPROTO_ICMP": "Control message protocol",
  "IPPROTO_IGMP": "Group Management Protocol",
  "IPPROTO_GGP": "Gateway to Gateway Protocol",
  "IPPROTO_TCP": "TCP",
  "IPPROTO_EGP": "Exterior Gateway Protocol",
  "IPPROTO_PUP": "PARC Universal Packet protocol",
  "IPPROTO_UDP": "UDP",
  "IPPROTO_IDP": "XNS IDP",
  "IPPROTO_HELLO": "\"hello\" routing protocol",
  "IPPROTO_ND": "Sun net disk protocol",
  "IPPROTO_TP": "ISO transport protocol class 4",
  "IPPROTO_XTP": "Xpress Transport Protocol",
  "IPPROTO_EON": "ISO cnlp",
  "IPPROTO_BIP": "",
  "IPPROTO_AH": "IP6 auth header",
  "IPPROTO_DSTOPTS": "IP6 destination option",
  "IPPROTO_ESP": "IP6 Encapsulated Security Payload",
  "IPPROTO_FRAGMENT": "IP6 fragmentation header",
  "IPPROTO_HOPOPTS": "IP6 hop-by-hop options",
  "IPPROTO_ICMPV6": "ICMP6",
  "IPPROTO_IPV6": "IP6 header",
  "IPPROTO_NONE": "IP6 no next header",
  "IPPROTO_ROUTING": "IP6 routing header",
  "IPPROTO_RAW": "Raw IP packet",
  "IPPROTO_MAX": "Maximum IPPROTO constant",
  "IPPORT_RESERVED": "Default minimum address for bind or connect",
  "IPPORT_USERRESERVED": "Default maximum address for bind or connect",
  "INADDR_ANY": "A socket bound to INADDR_ANY receives packets from all interfaces and sends from the default IP address",
  "INADDR_BROADCAST": "The network broadcast address",
  "INADDR_LOOPBACK": "The loopback address",
  "INADDR_UNSPEC_GROUP": "The reserved multicast group",
  "INADDR_ALLHOSTS_GROUP": "Multicast group for all systems on this subset",
  "INADDR_MAX_LOCAL_GROUP": "The last local network multicast group",
  "INADDR_NONE": "A bitmask for matching no valid IP address",
  "IP_OPTIONS": "IP options to be included in packets",
  "IP_HDRINCL": "Header is included with data",
  "IP_TOS": "IP type-of-service",
  "IP_TTL": "IP time-to-live",
  "IP_RECVOPTS": "Receive all IP options with datagram",
  "IP_RECVRETOPTS": "Receive all IP options for response",
  "IP_RECVDSTADDR": "Receive IP destination address with datagram",
  "IP_RETOPTS": "IP options to be included in datagrams",
  "IP_MINTTL": "Minimum TTL allowed for received packets",
  "IP_DONTFRAG": "Don't fragment packets",
  "IP_SENDSRCADDR": "Source address for outgoing UDP datagrams",
  "IP_ONESBCAST": "Force outgoing broadcast datagrams to have the undirected broadcast address",
  "IP_RECVTTL": "Receive IP TTL with datagrams",
  "IP_RECVIF": "Receive interface information with datagrams",
  "IP_RECVSLLA": "Receive link-layer address with datagrams",
  "IP_PORTRANGE": "Set the port range for sockets with unspecified port numbers",
  "IP_MULTICAST_IF": "IP multicast interface",
  "IP_MULTICAST_TTL": "IP multicast TTL",
  "IP_MULTICAST_LOOP": "IP multicast loopback",
  "IP_ADD_MEMBERSHIP": "Add a multicast group membership",
  "IP_DROP_MEMBERSHIP": "Drop a multicast group membership",
  "IP_DEFAULT_MULTICAST_TTL": "Default multicast TTL",
  "IP_DEFAULT_MULTICAST_LOOP": "Default multicast loopback",
  "IP_MAX_MEMBERSHIPS": "Maximum number multicast groups a socket can join",
  "IP_ROUTER_ALERT": "Notify transit routers to more closely examine the contents of an IP packet",
  "IP_PKTINFO": "Receive packet information with datagrams",
  "IP_PKTOPTIONS": "Receive packet options with datagrams",
  "IP_MTU_DISCOVER": "Path MTU discovery",
  "IP_RECVERR": "Enable extended reliable error message passing",
  "IP_RECVTOS": "Receive TOS with incoming packets",
  "IP_MTU": "The Maximum Transmission Unit of the socket",
  "IP_FREEBIND": "Allow binding to nonexistent IP addresses",
  "IP_IPSEC_POLICY": "IPsec security policy",
  "IP_XFRM_POLICY": "",
  "IP_PASSSEC": "Retrieve security context with datagram",
  "IP_PMTUDISC_DONT": "Never send DF frames",
  "IP_PMTUDISC_WANT": "Use per-route hints",
  "IP_PMTUDISC_DO": "Always send DF frames",
  "IP_UNBLOCK_SOURCE": "Unblock IPv4 multicast packets with a give source address",
  "IP_BLOCK_SOURCE": "Block IPv4 multicast packets with a give source address",
  "IP_ADD_SOURCE_MEMBERSHIP": "Add a multicast group membership",
  "IP_DROP_SOURCE_MEMBERSHIP": "Drop a multicast group membership",
  "IP_MSFILTER": "Multicast source filtering",
  "MCAST_JOIN_GROUP": "Join a multicast group",
  "MCAST_BLOCK_SOURCE": "Block multicast packets from this source",
  "MCAST_UNBLOCK_SOURCE": "Unblock multicast packets from this source",
  "MCAST_LEAVE_GROUP": "Leave a multicast group",
  "MCAST_JOIN_SOURCE_GROUP": "Join a multicast source group",
  "MCAST_LEAVE_SOURCE_GROUP": "Leave a multicast source group",
  "MCAST_MSFILTER": "Multicast source filtering",
  "MCAST_EXCLUDE": "Exclusive multicast source filter",
  "MCAST_INCLUDE": "Inclusive multicast source filter",
  "SO_DEBUG": "Debug info recording",
  "SO_REUSEADDR": "Allow local address reuse",
  "SO_REUSEPORT": "Allow local address and port reuse",
  "SO_TYPE": "Get the socket type",
  "SO_ERROR": "Get and clear the error status",
  "SO_DONTROUTE": "Use interface addresses",
  "SO_BROADCAST": "Permit sending of broadcast messages",
  "SO_SNDBUF": "Send buffer size",
  "SO_RCVBUF": "Receive buffer size",
  "SO_KEEPALIVE": "Keep connections alive",
  "SO_OOBINLINE": "Leave received out-of-band data in-line",
  "SO_NO_CHECK": "Disable checksums",
  "SO_PRIORITY": "The protocol-defined priority for all packets on this socket",
  "SO_LINGER": "Linger on close if data is present",
  "SO_PASSCRED": "Receive SCM_CREDENTIALS messages",
  "SO_PEERCRED": "The credentials of the foreign process connected to this socket",
  "SO_RCVLOWAT": "Receive low-water mark",
  "SO_SNDLOWAT": "Send low-water mark",
  "SO_RCVTIMEO": "Receive timeout",
  "SO_SNDTIMEO": "Send timeout",
  "SO_ACCEPTCONN": "Socket has had listen() called on it",
  "SO_USELOOPBACK": "Bypass hardware when possible",
  "SO_ACCEPTFILTER": "There is an accept filter",
  "SO_DONTTRUNC": "Retain unread data",
  "SO_WANTMORE": "Give a hint when more data is ready",
  "SO_WANTOOBFLAG": "OOB data is wanted in MSG_FLAG on receive",
  "SO_NREAD": "Get first packet byte count",
  "SO_NKE": "Install socket-level Network Kernel Extension",
  "SO_NOSIGPIPE": "Don't SIGPIPE on EPIPE",
  "SO_SECURITY_AUTHENTICATION": "",
  "SO_SECURITY_ENCRYPTION_TRANSPORT": "",
  "SO_SECURITY_ENCRYPTION_NETWORK": "",
  "SO_BINDTODEVICE": "Only send packets from the given interface",
  "SO_ATTACH_FILTER": "Attach an accept filter",
  "SO_DETACH_FILTER": "Detach an accept filter",
  "SO_PEERNAME": "Name of the connecting user",
  "SO_TIMESTAMP": "Receive timestamp with datagrams (timeval)",
  "SO_TIMESTAMPNS": "Receive nanosecond timestamp with datagrams (timespec)",
  "SO_BINTIME": "Receive timestamp with datagrams (bintime)",
  "SO_RECVUCRED": "Receive user credentials with datagram",
  "SO_MAC_EXEMPT": "Mandatory Access Control exemption for unlabeled peers",
  "SO_ALLZONES": "Bypass zone boundaries",
  "SOPRI_INTERACTIVE": "Interactive socket priority",
  "SOPRI_NORMAL": "Normal socket priority",
  "SOPRI_BACKGROUND": "Background socket priority",
  "IPX_TYPE": "",
  "TCP_NODELAY": "Don't delay sending to coalesce packets",
  "TCP_MAXSEG": "Set maximum segment size",
  "TCP_CORK": "Don't send partial frames",
  "TCP_DEFER_ACCEPT": "Don't notify a listening socket until data is ready",
  "TCP_INFO": "Retrieve information about this socket",
  "TCP_KEEPCNT": "Maximum number of keepalive probes allowed before dropping a connection",
  "TCP_KEEPIDLE": "Idle time before keepalive probes are sent",
  "TCP_KEEPINTVL": "Time between keepalive probes",
  "TCP_LINGER2": "Lifetime of orphaned FIN_WAIT2 sockets",
  "TCP_MD5SIG": "Use MD5 digests (RFC2385)",
  "TCP_NOOPT": "Don't use TCP options",
  "TCP_NOPUSH": "Don't push the last block of write",
  "TCP_QUICKACK": "Enable quickack mode",
  "TCP_SYNCNT": "Number of SYN retransmits before a connection is dropped",
  "TCP_WINDOW_CLAMP": "Clamp the size of the advertised window",
  "TCP_FASTOPEN": "Reduce step of the handshake process",
  "UDP_CORK": "Don't send partial frames",
  "EAI_ADDRFAMILY": "Address family for hostname not supported",
  "EAI_AGAIN": "Temporary failure in name resolution",
  "EAI_BADFLAGS": "Invalid flags",
  "EAI_FAIL": "Non-recoverable failure in name resolution",
  "EAI_FAMILY": "Address family not supported",
  "EAI_MEMORY": "Memory allocation failure",
  "EAI_NODATA": "No address associated with hostname",
  "EAI_NONAME": "Hostname nor servname, or not known",
  "EAI_OVERFLOW": "Argument buffer overflow",
  "EAI_SERVICE": "Servname not supported for socket type",
  "EAI_SOCKTYPE": "Socket type not supported",
  "EAI_SYSTEM": "System error returned in errno",
  "EAI_BADHINTS": "Invalid value for hints",
  "EAI_PROTOCOL": "Resolved protocol is unknown",
  "EAI_MAX": "Maximum error code from getaddrinfo",
  "AI_PASSIVE": "Get address to use with bind()",
  "AI_CANONNAME": "Fill in the canonical name",
  "AI_NUMERICHOST": "Prevent host name resolution",
  "AI_NUMERICSERV": "Prevent service name resolution",
  "AI_MASK": "Valid flag mask for getaddrinfo (not for application use)",
  "AI_ALL": "Allow all addresses",
  "AI_V4MAPPED_CFG": "Accept IPv4 mapped addresses if the kernel supports it",
  "AI_ADDRCONFIG": "Accept only if any address is assigned",
  "AI_V4MAPPED": "Accept IPv4-mapped IPv6 addresses",
  "AI_DEFAULT": "Default flags for getaddrinfo",
  "NI_MAXHOST": "Maximum length of a hostname",
  "NI_MAXSERV": "Maximum length of a service name",
  "NI_NOFQDN": "An FQDN is not required for local hosts, return only the local part",
  "NI_NUMERICHOST": "Return a numeric address",
  "NI_NAMEREQD": "A name is required",
  "NI_NUMERICSERV": "Return the service name as a digit string",
  "NI_DGRAM": "The service specified is a datagram service (looks up UDP ports)",
  "SHUT_RD": "Shut down the reading side of the socket",
  "SHUT_WR": "Shut down the writing side of the socket",
  "SHUT_RDWR": "Shut down the both sides of the socket",
  "IPV6_JOIN_GROUP": "Join a group membership",
  "IPV6_LEAVE_GROUP": "Leave a group membership",
  "IPV6_MULTICAST_HOPS": "IP6 multicast hops",
  "IPV6_MULTICAST_IF": "IP6 multicast interface",
  "IPV6_MULTICAST_LOOP": "IP6 multicast loopback",
  "IPV6_UNICAST_HOPS": "IP6 unicast hops",
  "IPV6_V6ONLY": "Only bind IPv6 with a wildcard bind",
  "IPV6_CHECKSUM": "Checksum offset for raw sockets",
  "IPV6_DONTFRAG": "Don't fragment packets",
  "IPV6_DSTOPTS": "Destination option",
  "IPV6_HOPLIMIT": "Hop limit",
  "IPV6_HOPOPTS": "Hop-by-hop option",
  "IPV6_NEXTHOP": "Next hop address",
  "IPV6_PATHMTU": "Retrieve current path MTU",
  "IPV6_PKTINFO": "Receive packet information with datagram",
  "IPV6_RECVDSTOPTS": "Receive all IP6 options for response",
  "IPV6_RECVHOPLIMIT": "Receive hop limit with datagram",
  "IPV6_RECVHOPOPTS": "Receive hop-by-hop options",
  "IPV6_RECVPKTINFO": "Receive destination IP address and incoming interface",
  "IPV6_RECVRTHDR": "Receive routing header",
  "IPV6_RECVTCLASS": "Receive traffic class",
  "IPV6_RTHDR": "Allows removal of sticky routing headers",
  "IPV6_RTHDRDSTOPTS": "Allows removal of sticky destination options header",
  "IPV6_RTHDR_TYPE_0": "Routing header type 0",
  "IPV6_RECVPATHMTU": "Receive current path MTU with datagram",
  "IPV6_TCLASS": "Specify the traffic class",
  "IPV6_USE_MIN_MTU": "Use the minimum MTU size",
  "INET_ADDRSTRLEN": "Maximum length of an IPv4 address string",
  "INET6_ADDRSTRLEN": "Maximum length of an IPv6 address string",
  "IFNAMSIZ": "Maximum interface name size",
  "IF_NAMESIZE": "Maximum interface name size",
  "SOMAXCONN": "Maximum connection requests that may be queued for a socket",
  "SCM_RIGHTS": "Access rights",
  "SCM_TIMESTAMP": "Timestamp (timeval)",
  "SCM_TIMESTAMPNS": "Timespec (timespec)",
  "SCM_BINTIME": "Timestamp (bintime)",
  "SCM_CREDENTIALS": "The sender's credentials",
  "SCM_CREDS": "Process credentials",
  "SCM_UCRED": "User credentials",
  "LOCAL_PEERCRED": "Retrieve peer credentials",
  "LOCAL_CREDS": "Pass credentials to receiver",
  "LOCAL_CONNWAIT": "Connect blocks until accepted",
  "IFF_802_1Q_VLAN": "802.1Q VLAN device",
  "IFF_ALLMULTI": "receive all multicast packets",
  "IFF_ALTPHYS": "use alternate physical connection",
  "IFF_AUTOMEDIA": "auto media select active",
  "IFF_BONDING": "bonding master or slave",
  "IFF_BRIDGE_PORT": "device used as bridge port",
  "IFF_BROADCAST": "broadcast address valid",
  "IFF_CANTCONFIG": "unconfigurable using ioctl(2)",
  "IFF_DEBUG": "turn on debugging",
  "IFF_DISABLE_NETPOLL": "disable netpoll at run-time",
  "IFF_DONT_BRIDGE": "disallow bridging this ether dev",
  "IFF_DORMANT": "driver signals dormant",
  "IFF_DRV_OACTIVE": "tx hardware queue is full",
  "IFF_DRV_RUNNING": "resources allocated",
  "IFF_DYING": "interface is winding down",
  "IFF_DYNAMIC": "dialup device with changing addresses",
  "IFF_EBRIDGE": "ethernet bridging device",
  "IFF_ECHO": "echo sent packets",
  "IFF_ISATAP": "ISATAP interface (RFC4214)",
  "IFF_LINK0": "per link layer defined bit 0",
  "IFF_LINK1": "per link layer defined bit 1",
  "IFF_LINK2": "per link layer defined bit 2",
  "IFF_LIVE_ADDR_CHANGE": "hardware address change when it's running",
  "IFF_LOOPBACK": "loopback net",
  "IFF_LOWER_UP": "driver signals L1 up",
  "IFF_MACVLAN_PORT": "device used as macvlan port",
  "IFF_MASTER": "master of a load balancer",
  "IFF_MASTER_8023AD": "bonding master, 802.3ad.",
  "IFF_MASTER_ALB": "bonding master, balance-alb.",
  "IFF_MASTER_ARPMON": "bonding master, ARP mon in use",
  "IFF_MONITOR": "user-requested monitor mode",
  "IFF_MULTICAST": "supports multicast",
  "IFF_NOARP": "no address resolution protocol",
  "IFF_NOTRAILERS": "avoid use of trailers",
  "IFF_OACTIVE": "transmission in progress",
  "IFF_OVS_DATAPATH": "device used as Open vSwitch datapath port",
  "IFF_POINTOPOINT": "point-to-point link",
  "IFF_PORTSEL": "can set media type",
  "IFF_PPROMISC": "user-requested promisc mode",
  "IFF_PROMISC": "receive all packets",
  "IFF_RENAMING": "interface is being renamed",
  "IFF_ROUTE": "routing entry installed",
  "IFF_RUNNING": "resources allocated",
  "IFF_SIMPLEX": "can't hear own transmissions",
  "IFF_SLAVE": "slave of a load balancer",
  "IFF_SLAVE_INACTIVE": "bonding slave not the curr. active",
  "IFF_SLAVE_NEEDARP": "need ARPs for validation",
  "IFF_SMART": "interface manages own routes",
  "IFF_STATICARP": "static ARP",
  "IFF_SUPP_NOFCS": "sending custom FCS",
  "IFF_TEAM_PORT": "used as team port",
  "IFF_TX_SKB_SHARING": "sharing skbs on transmit",
  "IFF_UNICAST_FLT": "unicast filtering",
  "IFF_UP": "interface is up",
  "IFF_WAN_HDLC": "WAN HDLC device",
  "IFF_XMIT_DST_RELEASE": "dev_hard_start_xmit() is allowed to release skb->dst",
  "IFF_VOLATILE": "volatile flags",
  "IFF_CANTCHANGE": "flags not changeable",
  "Ifaddr": "Socket::Ifaddr represents a result of getifaddrs() function.",
  "getifaddrs": "Returns an array of interface addresses.\nAn element of the array is an instance of Socket::Ifaddr.\n\nThis method can be used to find multicast-enabled interfaces:\n\n  pp Socket.getifaddrs.reject {|ifaddr|\n    !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)\n  }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }\n  #=> [[\"eth0\", 2, #<Addrinfo: 221.186.184.67>],\n  #    [\"eth0\", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]\n\nExample result on GNU/Linux:\n  pp Socket.getifaddrs\n  #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,\n  #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,\n  #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,\n  #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,\n  #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,\n  #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,\n  #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]\n\nExample result on FreeBSD:\n  pp Socket.getifaddrs\n  #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,\n  #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,\n  #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,\n  #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,\n  #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,\n  #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,\n  #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,\n  #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,\n  #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,\n  #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]"
}