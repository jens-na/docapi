{
  "PROTECTED_IVARS": "",
  "_protected_ivars": ":nodoc:",
  "register_observers": "Register one or more Observers which will be notified when mail is delivered.",
  "register_interceptors": "Register one or more Interceptors which will be called before mail is sent.",
  "register_observer": "Register an Observer which will be notified when mail is delivered.\nEither a class, string or symbol can be passed in as the Observer.\nIf a string or symbol is passed in it will be camelized and constantized.",
  "register_interceptor": "Register an Interceptor which will be called before mail is sent.\nEither a class, string or symbol can be passed in as the Interceptor.\nIf a string or symbol is passed in it will be camelized and constantized.",
  "mailer_name": "Returns the name of the mailer object.",
  "mailer_name=": "Allows to set the name of current mailer.",
  "controller_path": "Returns the name of current mailer. This method is also being used as a path for a view lookup.\nIf this is an anonymous mailer, this method will return +anonymous+ instead.",
  "default": "Sets the defaults through app configuration:\n\n    config.action_mailer.default { from: \"no-reply@example.org\" }\n\nAliased by ::default_options=",
  "default_options=": "Sets the defaults through app configuration:\n\n    config.action_mailer.default { from: \"no-reply@example.org\" }\n\nAliased by ::default_options=\nAllows to set defaults through app configuration:\n\n   config.action_mailer.default_options = { from: \"no-reply@example.org\" }",
  "receive": "Receives a raw email, parses it into an email object, decodes it,\ninstantiates a new mailer, and passes the email object to the mailer\nobject's +receive+ method.\n\nIf you want your mailer to be able to process incoming messages, you'll\nneed to implement a +receive+ method that accepts the raw email string\nas a parameter:\n\n  class MyMailer < ActionMailer::Base\n    def receive(mail)\n      # ...\n    end\n  end",
  "deliver_mail": "Wraps an email delivery inside of <tt>ActiveSupport::Notifications</tt> instrumentation.\n\nThis method is actually called by the <tt>Mail::Message</tt> object itself\nthrough a callback when you call <tt>:deliver</tt> on the <tt>Mail::Message</tt>,\ncalling +deliver_mail+ directly and passing a <tt>Mail::Message</tt> will do\nnothing except tell the logger you sent the email.",
  "respond_to?": ":nodoc:",
  "set_payload_for_mail": ":nodoc:",
  "method_missing": ":nodoc:",
  "initialize": "Instantiate a new mailer object. If +method_name+ is not +nil+, the mailer\nwill be initialized according to the named method. If not, the mailer will\nremain uninitialized (useful when you only need to invoke the \"receive\"\nmethod, for instance).",
  "process": ":nodoc:",
  "NullMail": ":nodoc:",
  "headers": "Allows you to pass random and unusual headers to the new <tt>Mail::Message</tt>\nobject which will add them to itself.\n\n  headers['X-Special-Domain-Specific-Header'] = \"SecretValue\"\n\nYou can also pass a hash into headers of header field names and values,\nwhich will then be set on the <tt>Mail::Message</tt> object:\n\n  headers 'X-Special-Domain-Specific-Header' => \"SecretValue\",\n          'In-Reply-To' => incoming.message_id\n\nThe resulting <tt>Mail::Message</tt> will have the following in its header:\n\n  X-Special-Domain-Specific-Header: SecretValue",
  "attachments": "Allows you to add attachments to an email, like so:\n\n mail.attachments['filename.jpg'] = File.read('/path/to/filename.jpg')\n\nIf you do this, then Mail will take the file name and work out the mime type\nset the Content-Type, Content-Disposition, Content-Transfer-Encoding and\nbase64 encode the contents of the attachment all for you.\n\nYou can also specify overrides if you want by passing a hash instead of a string:\n\n mail.attachments['filename.jpg'] = {mime_type: 'application/x-gzip',\n                                     content: File.read('/path/to/filename.jpg')}\n\nIf you want to use a different encoding than Base64, you can pass an encoding in,\nbut then it is up to you to pass in the content pre-encoded, and don't expect\nMail to know how to decode this data:\n\n file_content = SpecialEncode(File.read('/path/to/filename.jpg'))\n mail.attachments['filename.jpg'] = {mime_type: 'application/x-gzip',\n                                     encoding: 'SpecialEncoding',\n                                     content: file_content }\n\nYou can also search for specific attachments:\n\n # By Filename\n mail.attachments['filename.jpg']   # => Mail::Part object or nil\n\n # or by index\n mail.attachments[0]                # => Mail::Part (first attachment)",
  "mail": "The main method that creates the message and renders the email templates. There are\ntwo ways to call this method, with a block, or without a block.\n\nBoth methods accept a headers hash. This hash allows you to specify the most used headers\nin an email message, these are:\n\n* +:subject+ - The subject of the message, if this is omitted, Action Mailer will\n  ask the Rails I18n class for a translated +:subject+ in the scope of\n  <tt>[mailer_scope, action_name]</tt> or if this is missing, will translate the\n  humanized version of the +action_name+\n* +:to+ - Who the message is destined for, can be a string of addresses, or an array\n  of addresses.\n* +:from+ - Who the message is from\n* +:cc+ - Who you would like to Carbon-Copy on this email, can be a string of addresses,\n  or an array of addresses.\n* +:bcc+ - Who you would like to Blind-Carbon-Copy on this email, can be a string of\n  addresses, or an array of addresses.\n* +:reply_to+ - Who to set the Reply-To header of the email to.\n* +:date+ - The date to say the email was sent on.\n\nYou can set default values for any of the above headers (except +:date+)\nby using the ::default class method:\n\n class Notifier < ActionMailer::Base\n   default from: 'no-reply@test.lindsaar.net',\n           bcc: 'email_logger@test.lindsaar.net',\n           reply_to: 'bounces@test.lindsaar.net'\n end\n\nIf you need other headers not listed above, you can either pass them in\nas part of the headers hash or use the <tt>headers['name'] = value</tt>\nmethod.\n\nWhen a +:return_path+ is specified as header, that value will be used as\nthe 'envelope from' address for the Mail message. Setting this is useful\nwhen you want delivery notifications sent to a different address than the\none in +:from+. Mail will actually use the +:return_path+ in preference\nto the +:sender+ in preference to the +:from+ field for the 'envelope\nfrom' value.\n\nIf you do not pass a block to the +mail+ method, it will find all\ntemplates in the view paths using by default the mailer name and the\nmethod name that it is being called from, it will then create parts for\neach of these templates intelligently, making educated guesses on correct\ncontent type and sequence, and return a fully prepared <tt>Mail::Message</tt>\nready to call <tt>:deliver</tt> on to send.\n\nFor example:\n\n  class Notifier < ActionMailer::Base\n    default from: 'no-reply@test.lindsaar.net'\n\n    def welcome\n      mail(to: 'mikel@test.lindsaar.net')\n    end\n  end\n\nWill look for all templates at \"app/views/notifier\" with name \"welcome\".\nIf no welcome template exists, it will raise an ActionView::MissingTemplate error.\n\nHowever, those can be customized:\n\n  mail(template_path: 'notifications', template_name: 'another')\n\nAnd now it will look for all templates at \"app/views/notifications\" with name \"another\".\n\nIf you do pass a block, you can render specific templates of your choice:\n\n  mail(to: 'mikel@test.lindsaar.net') do |format|\n    format.text\n    format.html\n  end\n\nYou can even render plain text directly without using a template:\n\n  mail(to: 'mikel@test.lindsaar.net') do |format|\n    format.text { render plain: \"Hello Mikel!\" }\n    format.html { render html: \"<h1>Hello Mikel!</h1>\".html_safe }\n  end\n\nWhich will render a +multipart/alternative+ email with +text/plain+ and\n+text/html+ parts.\n\nThe block syntax also allows you to customize the part headers if desired:\n\n  mail(to: 'mikel@test.lindsaar.net') do |format|\n    format.text(content_transfer_encoding: \"base64\")\n    format.html\n  end",
  "set_content_type": "Used by #mail to set the content type of the message.\n\nIt will use the given +user_content_type+, or multipart if the mail\nmessage has any attachments. If the attachments are inline, the content\ntype will be \"multipart/related\", otherwise \"multipart/mixed\".\n\nIf there is no content type passed in via headers, and there are no\nattachments, or the message is multipart, then the default content type is\nused.",
  "default_i18n_subject": "Translates the +subject+ using Rails I18n class under <tt>[mailer_scope, action_name]</tt> scope.\nIf it does not find a translation for the +subject+ under the specified scope it will default to a\nhumanized version of the <tt>action_name</tt>.\nIf the subject has interpolations, you can pass them through the +interpolations+ parameter.",
  "collect_responses": ":nodoc:",
  "each_template": ":nodoc:",
  "create_parts_from_responses": ":nodoc:",
  "insert_part": ":nodoc:"
}