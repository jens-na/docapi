{
  "__method_for_multibyte_testing_with_integer_result": "",
  "__method_for_multibyte_testing": "",
  "__method_for_multibyte_testing!": "",
  "__method_for_multibyte_testing_that_returns_nil!": "",
  "as_json": ":nodoc:",
  "BLANK_RE": "",
  "blank?": "A string is blank if it's empty or contains whitespaces only:\n\n  ''.blank?       # => true\n  '   '.blank?    # => true\n  \"\\t\\n\\r\".blank? # => true\n  ' blah '.blank? # => false\n\nUnicode whitespace is supported:\n\n  \"\\u00a0\".blank? # => true",
  "in_time_zone": "Converts String to a TimeWithZone in the current zone if Time.zone or Time.zone_default\nis set, otherwise converts String to a Time via String#to_time",
  "strip_heredoc": "Strips indentation in heredocs.\n\nFor example in\n\n  if options[:usage]\n    puts <<-USAGE.strip_heredoc\n      This command does such and such.\n\n      Supported options are:\n        -h         This message\n        ...\n    USAGE\n  end\n\nthe user would see the usage message aligned against the left margin.\n\nTechnically, it looks for the least indented line in the whole string, and removes\nthat amount of leading whitespace.",
  "indent!": "Same as +indent+, except it indents the receiver in-place.\n\nReturns the indented string, or +nil+ if there was nothing to indent.",
  "indent": "Indents the lines in the receiver:\n\n  <<EOS.indent(2)\n  def some_method\n    some_code\n  end\n  EOS\n  # =>\n    def some_method\n      some_code\n    end\n\nThe second argument, +indent_string+, specifies which indent string to\nuse. The default is +nil+, which tells the method to make a guess by\npeeking at the first indented line, and fallback to a space if there is\nnone.\n\n  \"  foo\".indent(2)        # => \"    foo\"\n  \"foo\\n\\t\\tbar\".indent(2) # => \"\\t\\tfoo\\n\\t\\t\\t\\tbar\"\n  \"foo\".indent(2, \"\\t\")    # => \"\\t\\tfoo\"\n\nWhile +indent_string+ is typically one space or tab, it may be any string.\n\nThe third argument, +indent_empty_lines+, is a flag that says whether\nempty lines should be indented. Default is false.\n\n  \"foo\\n\\nbar\".indent(2)            # => \"  foo\\n\\n  bar\"\n  \"foo\\n\\nbar\".indent(2, nil, true) # => \"  foo\\n  \\n  bar\"",
  "at": "If you pass a single Fixnum, returns a substring of one character at that\nposition. The first character of the string is at position 0, the next at\nposition 1, and so on. If a range is supplied, a substring containing\ncharacters at offsets given by the range is returned. In both cases, if an\noffset is negative, it is counted from the end of the string. Returns nil\nif the initial offset falls outside the string. Returns an empty string if\nthe beginning of the range is greater than the end of the string.\n\n  str = \"hello\"\n  str.at(0)      # => \"h\"\n  str.at(1..3)   # => \"ell\"\n  str.at(-2)     # => \"l\"\n  str.at(-2..-1) # => \"lo\"\n  str.at(5)      # => nil\n  str.at(5..-1)  # => \"\"\n\nIf a Regexp is given, the matching portion of the string is returned.\nIf a String is given, that given string is returned if it occurs in\nthe string. In both cases, nil is returned if there is no match.\n\n  str = \"hello\"\n  str.at(/lo/) # => \"lo\"\n  str.at(/ol/) # => nil\n  str.at(\"lo\") # => \"lo\"\n  str.at(\"ol\") # => nil",
  "from": "Returns a substring from the given position to the end of the string.\nIf the position is negative, it is counted from the end of the string.\n\n  str = \"hello\"\n  str.from(0)  # => \"hello\"\n  str.from(3)  # => \"lo\"\n  str.from(-2) # => \"lo\"\n\nYou can mix it with +to+ method and do fun things like:\n\n  str = \"hello\"\n  str.from(0).to(-1) # => \"hello\"\n  str.from(1).to(-2) # => \"ell\"",
  "to": "Returns a substring from the beginning of the string to the given position.\nIf the position is negative, it is counted from the end of the string.\n\n  str = \"hello\"\n  str.to(0)  # => \"h\"\n  str.to(3)  # => \"hell\"\n  str.to(-2) # => \"hell\"\n\nYou can mix it with +from+ method and do fun things like:\n\n  str = \"hello\"\n  str.from(0).to(-1) # => \"hello\"\n  str.from(1).to(-2) # => \"ell\"",
  "first": "Returns the first character. If a limit is supplied, returns a substring\nfrom the beginning of the string until it reaches the limit value. If the\ngiven limit is greater than or equal to the string length, returns a copy of self.\n\n  str = \"hello\"\n  str.first    # => \"h\"\n  str.first(1) # => \"h\"\n  str.first(2) # => \"he\"\n  str.first(0) # => \"\"\n  str.first(6) # => \"hello\"",
  "last": "Returns the last character of the string. If a limit is supplied, returns a substring\nfrom the end of the string until it reaches the limit value (counting backwards). If\nthe given limit is greater than or equal to the string length, returns a copy of self.\n\n  str = \"hello\"\n  str.last    # => \"o\"\n  str.last(1) # => \"o\"\n  str.last(2) # => \"lo\"\n  str.last(0) # => \"\"\n  str.last(6) # => \"hello\"",
  "squish": "Returns the string, first removing all whitespace on both ends of\nthe string, and then changing remaining consecutive whitespace\ngroups into one space each.\n\nNote that it handles both ASCII and Unicode whitespace like mongolian vowel separator (U+180E).\n\n  %{ Multi-line\n     string }.squish                   # => \"Multi-line string\"\n  \" foo   bar    \\n   \\t   boo\".squish # => \"foo bar boo\"",
  "squish!": "Performs a destructive squish. See String#squish.",
  "remove": "Returns a new string with all occurrences of the pattern removed. Short-hand for String#gsub(pattern, '').",
  "remove!": "Alters the string by removing all occurrences of the pattern. Short-hand for String#gsub!(pattern, '').",
  "truncate": "Truncates a given +text+ after a given <tt>length</tt> if +text+ is longer than <tt>length</tt>:\n\n  'Once upon a time in a world far far away'.truncate(27)\n  # => \"Once upon a time in a wo...\"\n\nPass a string or regexp <tt>:separator</tt> to truncate +text+ at a natural break:\n\n  'Once upon a time in a world far far away'.truncate(27, separator: ' ')\n  # => \"Once upon a time in a...\"\n\n  'Once upon a time in a world far far away'.truncate(27, separator: /\\s/)\n  # => \"Once upon a time in a...\"\n\nThe last characters will be replaced with the <tt>:omission</tt> string (defaults to \"...\")\nfor a total length not exceeding <tt>length</tt>:\n\n  'And they found that many people were sleeping better.'.truncate(25, omission: '... (continued)')\n  # => \"And they f... (continued)\"",
  "inquiry": "Wraps the current string in the <tt>ActiveSupport::StringInquirer</tt> class,\nwhich gives you a prettier way to test for equality.\n\n  env = 'production'.inquiry\n  env.production?  # => true\n  env.development? # => false",
  "exclude?": "The inverse of <tt>String#include?</tt>. Returns true if the string\ndoes not include the other string.\n\n  \"hello\".exclude? \"lo\" # => false\n  \"hello\".exclude? \"ol\" # => true\n  \"hello\".exclude? ?h   # => false",
  "acts_like_string?": "Enable more predictable duck-typing on String-like classes. See <tt>Object#acts_like?</tt>.",
  "mb_chars": "== Multibyte proxy\n\n+mb_chars+ is a multibyte safe proxy for string methods.\n\nIt creates and returns an instance of the ActiveSupport::Multibyte::Chars class which\nencapsulates the original string. A Unicode safe version of all the String methods are defined on this proxy\nclass. If the proxy class doesn't respond to a certain method, it's forwarded to the encapsulated string.\n\n  name = 'Claus Müller'\n  name.reverse # => \"rell??M sualC\"\n  name.length  # => 13\n\n  name.mb_chars.reverse.to_s # => \"rellüM sualC\"\n  name.mb_chars.length       # => 12\n\n== Method chaining\n\nAll the methods on the Chars proxy which normally return a string will return a Chars object. This allows\nmethod chaining on the result of any of these methods.\n\n  name.mb_chars.reverse.length # => 12\n\n== Interoperability and configuration\n\nThe Chars object tries to be as interchangeable with String objects as possible: sorting and comparing between\nString and Char work like expected. The bang! methods change the internal string representation in the Chars\nobject. Interoperability problems can be resolved easily with a +to_s+ call.\n\nFor more information about the methods defined on the Chars proxy see ActiveSupport::Multibyte::Chars. For\ninformation about how to change the default Multibyte behavior see ActiveSupport::Multibyte.",
  "is_utf8?": "",
  "to_time": "Converts a string to a Time value.\nThe +form+ can be either :utc or :local (default :local).\n\nThe time is parsed using Time.parse method.\nIf +form+ is :local, then the time is in the system timezone.\nIf the date part is missing then the current date is used and if\nthe time part is missing then it is assumed to be 00:00:00.\n\n  \"13-12-2012\".to_time               # => 2012-12-13 00:00:00 +0100\n  \"06:12\".to_time                    # => 2012-12-13 06:12:00 +0100\n  \"2012-12-13 06:12\".to_time         # => 2012-12-13 06:12:00 +0100\n  \"2012-12-13T06:12\".to_time         # => 2012-12-13 06:12:00 +0100\n  \"2012-12-13T06:12\".to_time(:utc)   # => 2012-12-13 05:12:00 UTC\n  \"12/13/2012\".to_time               # => ArgumentError: argument out of range",
  "to_date": "Converts a string to a Date value.\n\n  \"1-1-2012\".to_date   # => Sun, 01 Jan 2012\n  \"01/01/2012\".to_date # => Sun, 01 Jan 2012\n  \"2012-12-13\".to_date # => Thu, 13 Dec 2012\n  \"12/13/2012\".to_date # => ArgumentError: invalid date",
  "to_datetime": "Converts a string to a DateTime value.\n\n  \"1-1-2012\".to_datetime            # => Sun, 01 Jan 2012 00:00:00 +0000\n  \"01/01/2012 23:59:59\".to_datetime # => Sun, 01 Jan 2012 23:59:59 +0000\n  \"2012-12-13 12:50\".to_datetime    # => Thu, 13 Dec 2012 12:50:00 +0000\n  \"12/13/2012\".to_datetime          # => ArgumentError: invalid date",
  "pluralize": "Returns the plural form of the word in the string.\n\nIf the optional parameter +count+ is specified,\nthe singular form will be returned if <tt>count == 1</tt>.\nFor any other value of +count+ the plural will be returned.\n\nIf the optional parameter +locale+ is specified,\nthe word will be pluralized as a word of that language.\nBy default, this parameter is set to <tt>:en</tt>.\nYou must define your own inflection rules for languages other than English.\n\n  'post'.pluralize             # => \"posts\"\n  'octopus'.pluralize          # => \"octopi\"\n  'sheep'.pluralize            # => \"sheep\"\n  'words'.pluralize            # => \"words\"\n  'the blue mailman'.pluralize # => \"the blue mailmen\"\n  'CamelOctopus'.pluralize     # => \"CamelOctopi\"\n  'apple'.pluralize(1)         # => \"apple\"\n  'apple'.pluralize(2)         # => \"apples\"\n  'ley'.pluralize(:es)         # => \"leyes\"\n  'ley'.pluralize(1, :es)      # => \"ley\"",
  "singularize": "The reverse of +pluralize+, returns the singular form of a word in a string.\n\nIf the optional parameter +locale+ is specified,\nthe word will be singularized as a word of that language.\nBy default, this parameter is set to <tt>:en</tt>.\nYou must define your own inflection rules for languages other than English.\n\n  'posts'.singularize            # => \"post\"\n  'octopi'.singularize           # => \"octopus\"\n  'sheep'.singularize            # => \"sheep\"\n  'word'.singularize             # => \"word\"\n  'the blue mailmen'.singularize # => \"the blue mailman\"\n  'CamelOctopi'.singularize      # => \"CamelOctopus\"\n  'leyes'.singularize(:es)       # => \"ley\"",
  "constantize": "+constantize+ tries to find a declared constant with the name specified\nin the string. It raises a NameError when the name is not in CamelCase\nor is not initialized.  See ActiveSupport::Inflector.constantize\n\n  'Module'.constantize  # => Module\n  'Class'.constantize   # => Class\n  'blargle'.constantize # => NameError: wrong constant name blargle",
  "safe_constantize": "+safe_constantize+ tries to find a declared constant with the name specified\nin the string. It returns nil when the name is not in CamelCase\nor is not initialized.  See ActiveSupport::Inflector.safe_constantize\n\n  'Module'.safe_constantize  # => Module\n  'Class'.safe_constantize   # => Class\n  'blargle'.safe_constantize # => nil",
  "camelize": "By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize\nis set to <tt>:lower</tt> then camelize produces lowerCamelCase.\n\n+camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.\n\n  'active_record'.camelize                # => \"ActiveRecord\"\n  'active_record'.camelize(:lower)        # => \"activeRecord\"\n  'active_record/errors'.camelize         # => \"ActiveRecord::Errors\"\n  'active_record/errors'.camelize(:lower) # => \"activeRecord::Errors\"",
  "camelcase": "By default, +camelize+ converts strings to UpperCamelCase. If the argument to camelize\nis set to <tt>:lower</tt> then camelize produces lowerCamelCase.\n\n+camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.\n\n  'active_record'.camelize                # => \"ActiveRecord\"\n  'active_record'.camelize(:lower)        # => \"activeRecord\"\n  'active_record/errors'.camelize         # => \"ActiveRecord::Errors\"\n  'active_record/errors'.camelize(:lower) # => \"activeRecord::Errors\"",
  "titleize": "Capitalizes all the words and replaces some characters in the string to create\na nicer looking title. +titleize+ is meant for creating pretty output. It is not\nused in the Rails internals.\n\n+titleize+ is also aliased as +titlecase+.\n\n  'man from the boondocks'.titleize # => \"Man From The Boondocks\"\n  'x-men: the last stand'.titleize  # => \"X Men: The Last Stand\"",
  "titlecase": "Capitalizes all the words and replaces some characters in the string to create\na nicer looking title. +titleize+ is meant for creating pretty output. It is not\nused in the Rails internals.\n\n+titleize+ is also aliased as +titlecase+.\n\n  'man from the boondocks'.titleize # => \"Man From The Boondocks\"\n  'x-men: the last stand'.titleize  # => \"X Men: The Last Stand\"",
  "underscore": "The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.\n\n+underscore+ will also change '::' to '/' to convert namespaces to paths.\n\n  'ActiveModel'.underscore         # => \"active_model\"\n  'ActiveModel::Errors'.underscore # => \"active_model/errors\"",
  "dasherize": "Replaces underscores with dashes in the string.\n\n  'puni_puni'.dasherize # => \"puni-puni\"",
  "demodulize": "Removes the module part from the constant expression in the string.\n\n  'ActiveRecord::CoreExtensions::String::Inflections'.demodulize # => \"Inflections\"\n  'Inflections'.demodulize                                       # => \"Inflections\"\n  '::Inflections'.demodulize                                     # => \"Inflections\"\n  ''.demodulize                                                  # => ''\n\nSee also +deconstantize+.",
  "deconstantize": "Removes the rightmost segment from the constant expression in the string.\n\n  'Net::HTTP'.deconstantize   # => \"Net\"\n  '::Net::HTTP'.deconstantize # => \"::Net\"\n  'String'.deconstantize      # => \"\"\n  '::String'.deconstantize    # => \"\"\n  ''.deconstantize            # => \"\"\n\nSee also +demodulize+.",
  "parameterize": "Replaces special characters in a string so that it may be used as part of a 'pretty' URL.\n\n  class Person\n    def to_param\n      \"#{id}-#{name.parameterize}\"\n    end\n  end\n\n  @person = Person.find(1)\n  # => #<Person id: 1, name: \"Donald E. Knuth\">\n\n  <%= link_to(@person.name, person_path) %>\n  # => <a href=\"/person/1-donald-e-knuth\">Donald E. Knuth</a>",
  "tableize": "Creates the name of a table like Rails does for models to table names. This method\nuses the +pluralize+ method on the last word in the string.\n\n  'RawScaledScorer'.tableize # => \"raw_scaled_scorers\"\n  'egg_and_ham'.tableize     # => \"egg_and_hams\"\n  'fancyCategory'.tableize   # => \"fancy_categories\"",
  "classify": "Create a class name from a plural table name like Rails does for table names to models.\nNote that this returns a string and not a class. (To convert to an actual class\nfollow +classify+ with +constantize+.)\n\n  'egg_and_hams'.classify # => \"EggAndHam\"\n  'posts'.classify        # => \"Post\"",
  "humanize": "Capitalizes the first word, turns underscores into spaces, and strips a\ntrailing '_id' if present.\nLike +titleize+, this is meant for creating pretty output.\n\nThe capitalization of the first word can be turned off by setting the\noptional parameter +capitalize+ to false.\nBy default, this parameter is true.\n\n  'employee_salary'.humanize              # => \"Employee salary\"\n  'author_id'.humanize                    # => \"Author\"\n  'author_id'.humanize(capitalize: false) # => \"author\"",
  "foreign_key": "Creates a foreign key name from a class name.\n+separate_class_name_and_id_with_underscore+ sets whether\nthe method should put '_' between the name and 'id'.\n\n  'Message'.foreign_key        # => \"message_id\"\n  'Message'.foreign_key(false) # => \"messageid\"\n  'Admin::Post'.foreign_key    # => \"post_id\"",
  "html_safe": "",
  "starts_with?": "",
  "ends_with?": ""
}