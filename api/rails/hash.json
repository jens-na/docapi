{
  "transform_keys": "Returns a new hash with all keys converted using the block operation.\n\n hash = { name: 'Rob', age: '28' }\n\n hash.transform_keys{ |key| key.to_s.upcase }\n # => {\"NAME\"=>\"Rob\", \"AGE\"=>\"28\"}",
  "transform_keys!": "Destructively convert all keys using the block operations.\nSame as transform_keys but modifies +self+.",
  "stringify_keys": "Returns a new hash with all keys converted to strings.\n\n  hash = { name: 'Rob', age: '28' }\n\n  hash.stringify_keys\n  # => {\"name\"=>\"Rob\", \"age\"=>\"28\"}",
  "stringify_keys!": "Destructively convert all keys to strings. Same as\n+stringify_keys+, but modifies +self+.",
  "symbolize_keys": "Returns a new hash with all keys converted to symbols, as long as\nthey respond to +to_sym+.\n\n  hash = { 'name' => 'Rob', 'age' => '28' }\n\n  hash.symbolize_keys\n  # => {:name=>\"Rob\", :age=>\"28\"}",
  "to_options": "Returns a new hash with all keys converted to symbols, as long as\nthey respond to +to_sym+.\n\n  hash = { 'name' => 'Rob', 'age' => '28' }\n\n  hash.symbolize_keys\n  # => {:name=>\"Rob\", :age=>\"28\"}",
  "symbolize_keys!": "Destructively convert all keys to symbols, as long as they respond\nto +to_sym+. Same as +symbolize_keys+, but modifies +self+.",
  "to_options!": "Destructively convert all keys to symbols, as long as they respond\nto +to_sym+. Same as +symbolize_keys+, but modifies +self+.",
  "assert_valid_keys": "Validate all keys in a hash match <tt>*valid_keys</tt>, raising ArgumentError\non a mismatch. Note that keys are NOT treated indifferently, meaning if you\nuse strings for keys but assert symbols as keys, this will fail.\n\n  { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises \"ArgumentError: Unknown key: :years. Valid keys are: :name, :age\"\n  { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises \"ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'\"\n  { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing",
  "deep_transform_keys": "Returns a new hash with all keys converted by the block operation.\nThis includes the keys from the root hash and from all\nnested hashes and arrays.\n\n hash = { person: { name: 'Rob', age: '28' } }\n\n hash.deep_transform_keys{ |key| key.to_s.upcase }\n # => {\"PERSON\"=>{\"NAME\"=>\"Rob\", \"AGE\"=>\"28\"}}",
  "deep_transform_keys!": "Destructively convert all keys by using the block operation.\nThis includes the keys from the root hash and from all\nnested hashes and arrays.",
  "deep_stringify_keys": "Returns a new hash with all keys converted to strings.\nThis includes the keys from the root hash and from all\nnested hashes and arrays.\n\n  hash = { person: { name: 'Rob', age: '28' } }\n\n  hash.deep_stringify_keys\n  # => {\"person\"=>{\"name\"=>\"Rob\", \"age\"=>\"28\"}}",
  "deep_stringify_keys!": "Destructively convert all keys to strings.\nThis includes the keys from the root hash and from all\nnested hashes and arrays.",
  "deep_symbolize_keys": "Returns a new hash with all keys converted to symbols, as long as\nthey respond to +to_sym+. This includes the keys from the root hash\nand from all nested hashes and arrays.\n\n  hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }\n\n  hash.deep_symbolize_keys\n  # => {:person=>{:name=>\"Rob\", :age=>\"28\"}}",
  "deep_symbolize_keys!": "Destructively convert all keys to symbols, as long as they respond\nto +to_sym+. This includes the keys from the root hash and from all\nnested hashes and arrays.",
  "_deep_transform_keys_in_object": "support methods for deep transforming nested hashes and arrays",
  "_deep_transform_keys_in_object!": "",
  "slice": "Slice a hash to include only the given keys. This is useful for\nlimiting an options hash to valid keys before passing to a method:\n\n  def search(criteria = {})\n    criteria.assert_valid_keys(:mass, :velocity, :time)\n  end\n\n  search(options.slice(:mass, :velocity, :time))\n\nIf you have an array of keys you want to limit to, you should splat them:\n\n  valid_keys = [:mass, :velocity, :time]\n  search(options.slice(*valid_keys))",
  "slice!": "Replaces the hash with only the given keys.\nReturns a hash containing the removed key/value pairs.\n\n  { a: 1, b: 2, c: 3, d: 4 }.slice!(:a, :b)\n  # => {:c=>3, :d=>4}",
  "extract!": "Removes and returns the key/value pairs matching the given keys.\n\n  { a: 1, b: 2, c: 3, d: 4 }.extract!(:a, :b) # => {:a=>1, :b=>2}\n  { a: 1, b: 2 }.extract!(:a, :x)             # => {:a=>1}",
  "except": "Returns a hash that includes everything but the given keys. This is useful for\nlimiting a set of parameters to everything but a few known toggles:\n\n  @person.update(params[:person].except(:admin))",
  "except!": "Replaces the hash without the given keys.",
  "as_json": ":nodoc:",
  "compact": "Returns a hash with non +nil+ values.\n\n  hash = { a: true, b: false, c: nil}\n  hash.compact # => { a: true, b: false}\n  hash # => { a: true, b: false, c: nil}\n  { c: nil }.compact # => {}",
  "compact!": "Replaces current hash with non +nil+ values.\n\n  hash = { a: true, b: false, c: nil}\n  hash.compact! # => { a: true, b: false}\n  hash # => { a: true, b: false}",
  "blank?": "A hash is blank if it's empty:\n\n  {}.blank?                # => true\n  { key: 'value' }.blank?  # => false",
  "to_param": "Returns a string representation of the receiver suitable for use as a URL\nquery string:\n\n  {name: 'David', nationality: 'Danish'}.to_param\n  # => \"name=David&nationality=Danish\"\n\nAn optional namespace can be passed to enclose the param names:\n\n  {name: 'David', nationality: 'Danish'}.to_param('user')\n  # => \"user[name]=David&user[nationality]=Danish\"\n\nThe string pairs \"key=value\" that conform the query string\nare sorted lexicographically in ascending order.\n\nThis method is also aliased as +to_query+.",
  "deep_merge": "Returns a new hash with +self+ and +other_hash+ merged recursively.\n\n  h1 = { a: true, b: { c: [1, 2, 3] } }\n  h2 = { a: false, b: { x: [3, 4, 5] } }\n\n  h1.deep_merge(h2) #=> { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }\n\nLike with Hash#merge in the standard library, a block can be provided\nto merge values:\n\n  h1 = { a: 100, b: 200, c: { c1: 100 } }\n  h2 = { b: 250, c: { c1: 200 } }\n  h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }\n  # => { a: 100, b: 450, c: { c1: 300 } }",
  "deep_merge!": "Same as +deep_merge+, but modifies +self+.",
  "deep_dup": "Returns a deep copy of hash.\n\n  hash = { a: { b: 'b' } }\n  dup  = hash.deep_dup\n  dup[:a][:c] = 'c'\n\n  hash[:a][:c] # => nil\n  dup[:a][:c]  # => \"c\"",
  "to_query": "Returns a string representation of the receiver suitable for use as a URL\nquery string:\n\n  {name: 'David', nationality: 'Danish'}.to_param\n  # => \"name=David&nationality=Danish\"\n\nAn optional namespace can be passed to enclose the param names:\n\n  {name: 'David', nationality: 'Danish'}.to_param('user')\n  # => \"user[name]=David&user[nationality]=Danish\"\n\nThe string pairs \"key=value\" that conform the query string\nare sorted lexicographically in ascending order.\n\nThis method is also aliased as +to_query+.",
  "to_xml": "Returns a string containing an XML representation of its receiver:\n\n  { foo: 1, bar: 2 }.to_xml\n  # =>\n  # <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  # <hash>\n  #   <foo type=\"integer\">1</foo>\n  #   <bar type=\"integer\">2</bar>\n  # </hash>\n\nTo do so, the method loops over the pairs and builds nodes that depend on\nthe _values_. Given a pair +key+, +value+:\n\n* If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>.\n\n* If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>,\n  and +key+ singularized as <tt>:children</tt>.\n\n* If +value+ is a callable object it must expect one or two arguments. Depending\n  on the arity, the callable is invoked with the +options+ hash as first argument\n  with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The\n  callable can add nodes by using <tt>options[:builder]</tt>.\n\n    'foo'.to_xml(lambda { |options, key| options[:builder].b(key) })\n    # => \"<b>foo</b>\"\n\n* If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.\n\n    class Foo\n      def to_xml(options)\n        options[:builder].bar 'fooing!'\n      end\n    end\n\n    { foo: Foo.new }.to_xml(skip_instruct: true)\n    # =>\n    # <hash>\n    #   <bar>fooing!</bar>\n    # </hash>\n\n* Otherwise, a node with +key+ as tag is created with a string representation of\n  +value+ as text node. If +value+ is +nil+ an attribute \"nil\" set to \"true\" is added.\n  Unless the option <tt>:skip_types</tt> exists and is true, an attribute \"type\" is\n  added as well according to the following mapping:\n\n    XML_TYPE_NAMES = {\n      \"Symbol\"     => \"symbol\",\n      \"Fixnum\"     => \"integer\",\n      \"Bignum\"     => \"integer\",\n      \"BigDecimal\" => \"decimal\",\n      \"Float\"      => \"float\",\n      \"TrueClass\"  => \"boolean\",\n      \"FalseClass\" => \"boolean\",\n      \"Date\"       => \"date\",\n      \"DateTime\"   => \"dateTime\",\n      \"Time\"       => \"dateTime\"\n    }\n\nBy default the root node is \"hash\", but that's configurable via the <tt>:root</tt> option.\n\nThe default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can\nconfigure your own builder with the <tt>:builder</tt> option. The method also accepts\noptions like <tt>:dasherize</tt> and friends, they are forwarded to the builder.",
  "from_xml": "Returns a Hash containing a collection of pairs when the key is the node name and the value is\nits content\n\n  xml = <<-XML\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n      <hash>\n        <foo type=\"integer\">1</foo>\n        <bar type=\"integer\">2</bar>\n      </hash>\n  XML\n\n  hash = Hash.from_xml(xml)\n  # => {\"hash\"=>{\"foo\"=>1, \"bar\"=>2}}\n\n+DisallowedType+ is raised if the XML contains attributes with <tt>type=\"yaml\"</tt> or\n<tt>type=\"symbol\"</tt>. Use <tt>Hash.from_trusted_xml</tt> to parse this XML.",
  "from_trusted_xml": "Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.",
  "reverse_merge": "Merges the caller into +other_hash+. For example,\n\n  options = options.reverse_merge(size: 25, velocity: 10)\n\nis equivalent to\n\n  options = { size: 25, velocity: 10 }.merge(options)\n\nThis is particularly useful for initializing an options hash\nwith default values.",
  "reverse_merge!": "Destructive +reverse_merge+.",
  "reverse_update": "Destructive +reverse_merge+.",
  "extractable_options?": "By default, only instances of Hash itself are extractable.\nSubclasses of Hash may implement this method and return\ntrue to declare themselves as extractable. If a Hash\nis extractable, Array#extract_options! pops it from\nthe Array when it is the last element of the Array.",
  "with_indifferent_access": "Returns an <tt>ActiveSupport::HashWithIndifferentAccess</tt> out of its receiver:\n\n  { a: 1 }.with_indifferent_access['a'] # => 1",
  "nested_under_indifferent_access": "Returns an <tt>ActiveSupport::HashWithIndifferentAccess</tt> out of its receiver:\n\n  { a: 1 }.with_indifferent_access['a'] # => 1\nCalled when object is nested under an object that receives\n#with_indifferent_access. This method will be called on the current object\nby the enclosing object and is aliased to #with_indifferent_access by\ndefault. Subclasses of Hash may overwrite this method to return +self+ if\nconverting to an <tt>ActiveSupport::HashWithIndifferentAccess</tt> would not be\ndesirable.\n\n  b = { b: 1 }\n  { a: b }.with_indifferent_access['a'] # calls b.nested_under_indifferent_access\n  # => {\"b\"=>1}"
}