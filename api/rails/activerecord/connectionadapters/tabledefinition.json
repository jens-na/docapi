{
  "indexes": "An array of ColumnDefinition objects, representing the column changes\nthat have been defined.",
  "indexes=": "An array of ColumnDefinition objects, representing the column changes\nthat have been defined.",
  "name": "Returns the value of attribute name",
  "temporary": "Returns the value of attribute temporary",
  "options": "Returns the value of attribute options",
  "as": "Returns the value of attribute as",
  "initialize": "",
  "columns": "",
  "primary_key": "Appends a primary key definition to the table definition.\nCan be called multiple times, but this is probably not a good idea.",
  "[]": "Returns a ColumnDefinition for the column with name +name+.",
  "column": "Instantiates a new column for the table.\nThe +type+ parameter is normally one of the migrations native types,\nwhich is one of the following:\n<tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>,\n<tt>:integer</tt>, <tt>:float</tt>, <tt>:decimal</tt>,\n<tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>,\n<tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>.\n\nYou may use a type not in this list as long as it is supported by your\ndatabase (for example, \"polygon\" in MySQL), but this will not be database\nagnostic and should usually be avoided.\n\nAvailable options are (none of these exists by default):\n* <tt>:limit</tt> -\n  Requests a maximum column length. This is number of characters for <tt>:string</tt> and\n  <tt>:text</tt> columns and number of bytes for <tt>:binary</tt> and <tt>:integer</tt> columns.\n* <tt>:default</tt> -\n  The column's default value. Use nil for NULL.\n* <tt>:null</tt> -\n  Allows or disallows +NULL+ values in the column. This option could\n  have been named <tt>:null_allowed</tt>.\n* <tt>:precision</tt> -\n  Specifies the precision for a <tt>:decimal</tt> column.\n* <tt>:scale</tt> -\n  Specifies the scale for a <tt>:decimal</tt> column.\n\nFor clarity's sake: the precision is the number of significant digits,\nwhile the scale is the number of digits that can be stored following\nthe decimal point. For example, the number 123.45 has a precision of 5\nand a scale of 2. A decimal with a precision of 5 and a scale of 2 can\nrange from -999.99 to 999.99.\n\nPlease be aware of different RDBMS implementations behavior with\n<tt>:decimal</tt> columns:\n* The SQL standard says the default scale should be 0, <tt>:scale</tt> <=\n  <tt>:precision</tt>, and makes no comments about the requirements of\n  <tt>:precision</tt>.\n* MySQL: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..30].\n  Default is (10,0).\n* PostgreSQL: <tt>:precision</tt> [1..infinity],\n  <tt>:scale</tt> [0..infinity]. No default.\n* SQLite2: Any <tt>:precision</tt> and <tt>:scale</tt> may be used.\n  Internal storage as strings. No default.\n* SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>,\n  but the maximum supported <tt>:precision</tt> is 16. No default.\n* Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127].\n  Default is (38,0).\n* DB2: <tt>:precision</tt> [1..63], <tt>:scale</tt> [0..62].\n  Default unknown.\n* Firebird: <tt>:precision</tt> [1..18], <tt>:scale</tt> [0..18].\n  Default (9,0). Internal types NUMERIC and DECIMAL have different\n  storage rules, decimal being better.\n* FrontBase?: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].\n  Default (38,0). WARNING Max <tt>:precision</tt>/<tt>:scale</tt> for\n  NUMERIC is 19, and DECIMAL is 38.\n* SqlServer?: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].\n  Default (38,0).\n* Sybase: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].\n  Default (38,0).\n* OpenBase?: Documentation unclear. Claims storage in <tt>double</tt>.\n\nThis method returns <tt>self</tt>.\n\n== Examples\n # Assuming +td+ is an instance of TableDefinition\n td.column(:granted, :boolean)\n # granted BOOLEAN\n\n td.column(:picture, :binary, limit: 2.megabytes)\n # => picture BLOB(2097152)\n\n td.column(:sales_stage, :string, limit: 20, default: 'new', null: false)\n # => sales_stage VARCHAR(20) DEFAULT 'new' NOT NULL\n\n td.column(:bill_gates_money, :decimal, precision: 15, scale: 2)\n # => bill_gates_money DECIMAL(15,2)\n\n td.column(:sensor_reading, :decimal, precision: 30, scale: 20)\n # => sensor_reading DECIMAL(30,20)\n\n # While <tt>:scale</tt> defaults to zero on most databases, it\n # probably wouldn't hurt to include it.\n td.column(:huge_integer, :decimal, precision: 30)\n # => huge_integer DECIMAL(30)\n\n # Defines a column with a database-specific type.\n td.column(:foo, 'polygon')\n # => foo polygon\n\n== Short-hand examples\n\nInstead of calling +column+ directly, you can also work with the short-hand definitions for the default types.\nThey use the type as the method name instead of as a parameter and allow for multiple columns to be defined\nin a single statement.\n\nWhat can be written like this with the regular calls to column:\n\n  create_table :products do |t|\n    t.column :shop_id,    :integer\n    t.column :creator_id, :integer\n    t.column :name,       :string, default: \"Untitled\"\n    t.column :value,      :string, default: \"Untitled\"\n    t.column :created_at, :datetime\n    t.column :updated_at, :datetime\n  end\n\ncan also be written as follows using the short-hand:\n\n  create_table :products do |t|\n    t.integer :shop_id, :creator_id\n    t.string  :name, :value, default: \"Untitled\"\n    t.timestamps\n  end\n\nThere's a short-hand method for each of the type values declared at the top. And then there's\nTableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.\n\nTableDefinition#references will add an appropriately-named _id column, plus a corresponding _type\ncolumn if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of\noptions, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option\nwill also create an index, similar to calling <tt>add_index</tt>. So what can be written like this:\n\n  create_table :taggings do |t|\n    t.integer :tag_id, :tagger_id, :taggable_id\n    t.string  :tagger_type\n    t.string  :taggable_type, default: 'Photo'\n  end\n  add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'\n  add_index :taggings, [:tagger_id, :tagger_type]\n\nCan also be written as follows using references:\n\n  create_table :taggings do |t|\n    t.references :tag, index: { name: 'index_taggings_on_tag_id' }\n    t.references :tagger, polymorphic: true, index: true\n    t.references :taggable, polymorphic: { default: 'Photo' }\n  end",
  "remove_column": "",
  "index": "Adds index options to the indexes hash, keyed by column name\nThis is primarily used to track indexes that need to be created after the table\n\n  index(:account_id, name: 'index_projects_on_account_id')",
  "timestamps": "Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and\n<tt>:updated_at</tt> to the table.",
  "references": "",
  "belongs_to": "",
  "new_column_definition": ":nodoc:",
  "create_column_definition": "",
  "primary_key_column_name": "",
  "native": ""
}