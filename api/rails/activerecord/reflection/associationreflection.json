{
  "klass": "Returns the target association's class.\n\n  class Author < ActiveRecord::Base\n    has_many :books\n  end\n\n  Author.reflect_on_association(:books).klass\n  # => Book\n\n<b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate\na new association object. Use +build_association+ or +create_association+\ninstead. This allows plugins to hook into association object creation.",
  "type": "Returns the value of attribute type",
  "foreign_type": "Returns the value of attribute foreign_type",
  "parent_reflection": "[:name, Reflection]",
  "parent_reflection=": "[:name, Reflection]",
  "initialize": "",
  "association_scope_cache": "",
  "build_association": "Returns a new, unsaved instance of the associated class. +attributes+ will\nbe passed to the class's constructor.",
  "constructable?": ":nodoc:",
  "table_name": "",
  "quoted_table_name": "",
  "join_table": "",
  "foreign_key": "",
  "primary_key_column": "",
  "association_foreign_key": "",
  "association_primary_key": "klass option is necessary to support loading polymorphic associations",
  "active_record_primary_key": "",
  "counter_cache_column": "",
  "check_validity!": "",
  "check_validity_of_inverse!": "",
  "check_preloadable!": "",
  "check_eager_loadable!": "",
  "join_id_for": ":nodoc:",
  "through_reflection": "",
  "source_reflection": "",
  "chain": "A chain of reflections from this one back to the owner. For more see the explanation in\nThroughReflection.",
  "nested?": "",
  "scope_chain": "An array of arrays of scopes. Each item in the outside array corresponds to a reflection\nin the #chain.",
  "source_macro": "",
  "has_inverse?": "",
  "inverse_of": "",
  "polymorphic_inverse_of": "",
  "collection?": "Returns whether or not this association reflection is for a collection\nassociation. Returns +true+ if the +macro+ is either +has_many+ or\n+has_and_belongs_to_many+, +false+ otherwise.",
  "validate?": "Returns whether or not the association should be validated as part of\nthe parent's validation.\n\nUnless you explicitly disable validation with\n<tt>validate: false</tt>, validation will take place when:\n\n* you explicitly enable validation; <tt>validate: true</tt>\n* you use autosave; <tt>autosave: true</tt>\n* the association is a +has_many+ association",
  "belongs_to?": "Returns +true+ if +self+ is a +belongs_to+ reflection.",
  "has_one?": "Returns +true+ if +self+ is a +has_one+ reflection.",
  "association_class": "",
  "polymorphic?": "",
  "VALID_AUTOMATIC_INVERSE_MACROS": "",
  "INVALID_AUTOMATIC_INVERSE_OPTIONS": "",
  "actual_source_reflection": "FIXME: this is a horrible name",
  "calculate_constructable": "",
  "inverse_name": "Attempts to find the inverse association name automatically.\nIf it cannot find a suitable inverse association name, it returns\nnil.",
  "automatic_inverse_of": "returns either nil or the inverse association name that it finds.",
  "valid_inverse_reflection?": "Checks if the inverse reflection that is returned from the\n+automatic_inverse_of+ method is a valid reflection. We must\nmake sure that the reflection's active_record name matches up\nwith the current reflection's klass name.\n\nNote: klass will always be valid because when there's a NameError\nfrom calling +klass+, +reflection+ will already be set to false.",
  "can_find_inverse_of_automatically?": "Checks to see if the reflection doesn't have any options that prevent\nus from being able to guess the inverse automatically. First, the\n<tt>inverse_of</tt> option cannot be set to false. Second, we must\nhave <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations.\nThird, we must not have options such as <tt>:polymorphic</tt> or\n<tt>:foreign_key</tt> which prevent us from correctly guessing the\ninverse association.\n\nAnything with a scope can additionally ruin our attempt at finding an\ninverse, so we exclude reflections with scopes.",
  "derive_class_name": "",
  "derive_foreign_key": "",
  "derive_join_table": "",
  "primary_key": ""
}