{
  "reader": "Implements the reader method, e.g. foo.items for Foo.has_many :items",
  "writer": "Implements the writer method, e.g. foo.items= for Foo.has_many :items",
  "ids_reader": "Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items",
  "ids_writer": "Implements the ids writer method, e.g. foo.item_ids= for Foo.has_many :items",
  "reset": "",
  "select": "",
  "find": "",
  "first": "",
  "second": "",
  "third": "",
  "fourth": "",
  "fifth": "",
  "forty_two": "",
  "last": "",
  "build": "",
  "create": "",
  "create!": "",
  "concat": "Add +records+ to this association. Returns +self+ so method calls may\nbe chained. Since << flattens its argument list and inserts each record,\n+push+ and +concat+ behave identically.",
  "transaction": "Starts a transaction in the association class's database connection.\n\n  class Author < ActiveRecord::Base\n    has_many :books\n  end\n\n  Author.first.books.transaction do\n    # same effect as calling Book.transaction\n  end",
  "delete_all": "Removes all records from the association without calling callbacks\non the associated records. It honors the `:dependent` option. However\nif the `:dependent` value is `:destroy` then in that case the `:delete_all`\ndeletion strategy for the association is applied.\n\nYou can force a particular deletion strategy by passing a parameter.\n\nExample:\n\n@author.books.delete_all(:nullify)\n@author.books.delete_all(:delete_all)\n\nSee delete for more info.",
  "destroy_all": "Destroy all the records from this association.\n\nSee destroy for more info.",
  "count": "Count all records using SQL.  Construct options and pass them with\nscope to the target class's +count+.",
  "delete": "Removes +records+ from this association calling +before_remove+ and\n+after_remove+ callbacks.\n\nThis method is abstract in the sense that +delete_records+ has to be\nprovided by descendants. Note this method does not imply the records\nare actually removed from the database, that depends precisely on\n+delete_records+. They are in any case removed from the collection.",
  "destroy": "Deletes the +records+ and removes them from this association calling\n+before_remove+ , +after_remove+ , +before_destroy+ and +after_destroy+ callbacks.\n\nNote that this method removes records from the database ignoring the\n+:dependent+ option.",
  "size": "Returns the size of the collection by executing a SELECT COUNT(*)\nquery if the collection hasn't been loaded, and calling\n<tt>collection.size</tt> if it has.\n\nIf the collection has been already loaded +size+ and +length+ are\nequivalent. If not and you are going to need the records anyway\n+length+ will take one less query. Otherwise +size+ is more efficient.\n\nThis method is abstract in the sense that it relies on\n+count_records+, which is a method descendants have to provide.",
  "length": "Returns the size of the collection calling +size+ on the target.\n\nIf the collection has been already loaded +length+ and +size+ are\nequivalent. If not and you are going to need the records anyway this\nmethod will take one less query. Otherwise +size+ is more efficient.",
  "empty?": "Returns true if the collection is empty.\n\nIf the collection has been loaded\nit is equivalent to <tt>collection.size.zero?</tt>. If the\ncollection has not been loaded, it is equivalent to\n<tt>collection.exists?</tt>. If the collection has not already been\nloaded and you are going to fetch the records anyway it is better to\ncheck <tt>collection.length.zero?</tt>.",
  "any?": "Returns true if the collections is not empty.\nEquivalent to +!collection.empty?+.",
  "many?": "Returns true if the collection has more than 1 record.\nEquivalent to +collection.size > 1+.",
  "distinct": "",
  "uniq": "",
  "replace": "Replace this collection with +other_array+. This will perform a diff\nand delete/add only records that have changed.",
  "include?": "",
  "load_target": "",
  "add_to_target": "",
  "scope": "",
  "null_scope?": "",
  "find_target": "",
  "merge_target_lists": "We have some records loaded from the database (persisted) and some that are\nin-memory (memory). The same record may be represented in the persisted array\nand in the memory array.\n\nSo the task of this method is to merge them according to the following rules:\n\n  * The final array must not have duplicates\n  * The order of the persisted array is to be preserved\n  * Any changes made to attributes on objects in the memory array are to be preserved\n  * Otherwise, attributes should have the value found in the database",
  "create_record": "",
  "insert_record": "Do the relevant stuff to insert the given record into the association collection.",
  "create_scope": "",
  "delete_or_destroy": "",
  "remove_records": "",
  "delete_records": "Delete the given records from the association, using one of the methods :destroy,\n:delete_all or :nullify (or nil, in which case a default is used).",
  "replace_records": "",
  "concat_records": "",
  "callback": "",
  "callbacks_for": "",
  "fetch_first_nth_or_last_using_find?": "Should we deal with assoc.first or assoc.last by issuing an independent query to\nthe database, or by getting the target, and then taking the first/last item from that?\n\nIf the args is just a non-empty options hash, go to the database.\n\nOtherwise, go to the database only if none of the following are true:\n  * target already loaded\n  * owner is new record\n  * target contains new or changed record(s)",
  "include_in_memory?": "",
  "find_by_scan": "If the :inverse_of option has been\nspecified, then #find scans the entire collection.",
  "first_nth_or_last": "Fetches the first/last using SQL if possible, otherwise from the target array."
}