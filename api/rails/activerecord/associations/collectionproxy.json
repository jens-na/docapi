{
  "initialize": ":nodoc:",
  "target": "",
  "load_target": "",
  "loaded?": "Returns +true+ if the association has been loaded, otherwise +false+.\n\n  person.pets.loaded? # => false\n  person.pets\n  person.pets.loaded? # => true",
  "select": "Works in two ways.\n\n*First:* Specify a subset of fields to be selected from the result set.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.select(:name)\n  # => [\n  #      #<Pet id: nil, name: \"Fancy-Fancy\">,\n  #      #<Pet id: nil, name: \"Spook\">,\n  #      #<Pet id: nil, name: \"Choo-Choo\">\n  #    ]\n\n  person.pets.select(:id, :name )\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\">,\n  #      #<Pet id: 2, name: \"Spook\">,\n  #      #<Pet id: 3, name: \"Choo-Choo\">\n  #    ]\n\nBe careful because this also means you're initializing a model\nobject with only the fields that you've selected. If you attempt\nto access a field except +id+ that is not in the initialized record you'll\nreceive:\n\n  person.pets.select(:name).first.person_id\n  # => ActiveModel::MissingAttributeError: missing attribute: person_id\n\n*Second:* You can pass a block so it can be used just like Array#select.\nThis builds an array of objects from the database for the scope,\nconverting them into an array and iterating through them using\nArray#select.\n\n  person.pets.select { |pet| pet.name =~ /oo/ }\n  # => [\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.select(:name) { |pet| pet.name =~ /oo/ }\n  # => [\n  #      #<Pet id: 2, name: \"Spook\">,\n  #      #<Pet id: 3, name: \"Choo-Choo\">\n  #    ]",
  "find": "Finds an object in the collection responding to the +id+. Uses the same\nrules as <tt>ActiveRecord::Base.find</tt>. Returns <tt>ActiveRecord::RecordNotFound</tt>\nerror if the object cannot be found.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.find(1) # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>\n  person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=4\n\n  person.pets.find(2) { |pet| pet.name.downcase! }\n  # => #<Pet id: 2, name: \"fancy-fancy\", person_id: 1>\n\n  person.pets.find(2, 3)\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "first": "Returns the first record, or the first +n+ records, from the collection.\nIf the collection is empty, the first form returns +nil+, and the second\nform returns an empty array.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.first # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>\n\n  person.pets.first(2)\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>\n  #    ]\n\n  another_person_without.pets          # => []\n  another_person_without.pets.first    # => nil\n  another_person_without.pets.first(3) # => []",
  "second": "Same as +first+ except returns only the second record.",
  "third": "Same as +first+ except returns only the third record.",
  "fourth": "Same as +first+ except returns only the fourth record.",
  "fifth": "Same as +first+ except returns only the fifth record.",
  "forty_two": "Same as +first+ except returns only the forty second record.\nAlso known as accessing \"the reddit\".",
  "last": "Returns the last record, or the last +n+ records, from the collection.\nIf the collection is empty, the first form returns +nil+, and the second\nform returns an empty array.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.last # => #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n\n  person.pets.last(2)\n  # => [\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  another_person_without.pets         # => []\n  another_person_without.pets.last    # => nil\n  another_person_without.pets.last(3) # => []",
  "build": "Returns a new object of the collection type that has been instantiated\nwith +attributes+ and linked to this object, but have not yet been saved.\nYou can pass an array of attributes hashes, this will return an array\nwith the new objects.\n\n  class Person\n    has_many :pets\n  end\n\n  person.pets.build\n  # => #<Pet id: nil, name: nil, person_id: 1>\n\n  person.pets.build(name: 'Fancy-Fancy')\n  # => #<Pet id: nil, name: \"Fancy-Fancy\", person_id: 1>\n\n  person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])\n  # => [\n  #      #<Pet id: nil, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: nil, name: \"Choo-Choo\", person_id: 1>,\n  #      #<Pet id: nil, name: \"Brain\", person_id: 1>\n  #    ]\n\n  person.pets.size  # => 5 # size of the collection\n  person.pets.count # => 0 # count from database",
  "new": "Returns a new object of the collection type that has been instantiated\nwith +attributes+ and linked to this object, but have not yet been saved.\nYou can pass an array of attributes hashes, this will return an array\nwith the new objects.\n\n  class Person\n    has_many :pets\n  end\n\n  person.pets.build\n  # => #<Pet id: nil, name: nil, person_id: 1>\n\n  person.pets.build(name: 'Fancy-Fancy')\n  # => #<Pet id: nil, name: \"Fancy-Fancy\", person_id: 1>\n\n  person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])\n  # => [\n  #      #<Pet id: nil, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: nil, name: \"Choo-Choo\", person_id: 1>,\n  #      #<Pet id: nil, name: \"Brain\", person_id: 1>\n  #    ]\n\n  person.pets.size  # => 5 # size of the collection\n  person.pets.count # => 0 # count from database",
  "create": "Returns a new object of the collection type that has been instantiated with\nattributes, linked to this object and that has already been saved (if it\npasses the validations).\n\n  class Person\n    has_many :pets\n  end\n\n  person.pets.create(name: 'Fancy-Fancy')\n  # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>\n\n  person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])\n  # => [\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.size  # => 3\n  person.pets.count # => 3\n\n  person.pets.find(1, 2, 3)\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "create!": "Like +create+, except that if the record is invalid, raises an exception.\n\n  class Person\n    has_many :pets\n  end\n\n  class Pet\n    validates :name, presence: true\n  end\n\n  person.pets.create!(name: nil)\n  # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank",
  "concat": "Add one or more records to the collection by setting their foreign keys\nto the association's primary key. Since << flattens its argument list and\ninserts each record, +push+ and +concat+ behave identically. Returns +self+\nso method calls may be chained.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 0\n  person.pets.concat(Pet.new(name: 'Fancy-Fancy'))\n  person.pets.concat(Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo'))\n  person.pets.size # => 3\n\n  person.id # => 1\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.concat([Pet.new(name: 'Brain'), Pet.new(name: 'Benny')])\n  person.pets.size # => 5",
  "replace": "Replaces this collection with +other_array+. This will perform a diff\nand delete/add only records that have changed.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [#<Pet id: 1, name: \"Gorby\", group: \"cats\", person_id: 1>]\n\n  other_pets = [Pet.new(name: 'Puff', group: 'celebrities']\n\n  person.pets.replace(other_pets)\n\n  person.pets\n  # => [#<Pet id: 2, name: \"Puff\", group: \"celebrities\", person_id: 1>]\n\nIf the supplied array has an incorrect association type, it raises\nan <tt>ActiveRecord::AssociationTypeMismatch</tt> error:\n\n  person.pets.replace([\"doo\", \"ggie\", \"gaga\"])\n  # => ActiveRecord::AssociationTypeMismatch: Pet expected, got String",
  "delete_all": "Deletes all the records from the collection. For +has_many+ associations,\nthe deletion is done according to the strategy specified by the <tt>:dependent</tt>\noption.\n\nIf no <tt>:dependent</tt> option is given, then it will follow the\ndefault strategy. The default strategy is <tt>:nullify</tt>. This\nsets the foreign keys to <tt>NULL</tt>. For, +has_many+ <tt>:through</tt>,\nthe default strategy is +delete_all+.\n\n  class Person < ActiveRecord::Base\n    has_many :pets # dependent: :nullify option by default\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete_all\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.size # => 0\n  person.pets      # => []\n\n  Pet.find(1, 2, 3)\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: nil>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: nil>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: nil>\n  #    ]\n\nIf it is set to <tt>:destroy</tt> all the objects from the collection\nare removed by calling their +destroy+ method. See +destroy+ for more\ninformation.\n\n  class Person < ActiveRecord::Base\n    has_many :pets, dependent: :destroy\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete_all\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  Pet.find(1, 2, 3)\n  # => ActiveRecord::RecordNotFound\n\nIf it is set to <tt>:delete_all</tt>, all the objects are deleted\n*without* calling their +destroy+ method.\n\n  class Person < ActiveRecord::Base\n    has_many :pets, dependent: :delete_all\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete_all\n\n  Pet.find(1, 2, 3)\n  # => ActiveRecord::RecordNotFound",
  "destroy_all": "Deletes the records of the collection directly from the database\nignoring the +:dependent+ option. It invokes +before_remove+,\n+after_remove+ , +before_destroy+ and +after_destroy+ callbacks.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.destroy_all\n\n  person.pets.size # => 0\n  person.pets      # => []\n\n  Pet.find(1) # => Couldn't find Pet with id=1",
  "delete": "Deletes the +records+ supplied and removes them from the collection. For\n+has_many+ associations, the deletion is done according to the strategy\nspecified by the <tt>:dependent</tt> option. Returns an array with the\ndeleted records.\n\nIf no <tt>:dependent</tt> option is given, then it will follow the default\nstrategy. The default strategy is <tt>:nullify</tt>. This sets the foreign\nkeys to <tt>NULL</tt>. For, +has_many+ <tt>:through</tt>, the default\nstrategy is +delete_all+.\n\n  class Person < ActiveRecord::Base\n    has_many :pets # dependent: :nullify option by default\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete(Pet.find(1))\n  # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]\n\n  person.pets.size # => 2\n  person.pets\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  Pet.find(1)\n  # => #<Pet id: 1, name: \"Fancy-Fancy\", person_id: nil>\n\nIf it is set to <tt>:destroy</tt> all the +records+ are removed by calling\ntheir +destroy+ method. See +destroy+ for more information.\n\n  class Person < ActiveRecord::Base\n    has_many :pets, dependent: :destroy\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete(Pet.find(1), Pet.find(3))\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.size # => 1\n  person.pets\n  # => [#<Pet id: 2, name: \"Spook\", person_id: 1>]\n\n  Pet.find(1, 3)\n  # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (1, 3)\n\nIf it is set to <tt>:delete_all</tt>, all the +records+ are deleted\n*without* calling their +destroy+ method.\n\n  class Person < ActiveRecord::Base\n    has_many :pets, dependent: :delete_all\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete(Pet.find(1))\n  # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]\n\n  person.pets.size # => 2\n  person.pets\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  Pet.find(1)\n  # => ActiveRecord::RecordNotFound: Couldn't find Pet with id=1\n\nYou can pass +Fixnum+ or +String+ values, it finds the records\nresponding to the +id+ and executes delete on them.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.delete(\"1\")\n  # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]\n\n  person.pets.delete(2, 3)\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "destroy": "Destroys the +records+ supplied and removes them from the collection.\nThis method will _always_ remove record from the database ignoring\nthe +:dependent+ option. Returns an array with the removed records.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.destroy(Pet.find(1))\n  # => [#<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>]\n\n  person.pets.size # => 2\n  person.pets\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.destroy(Pet.find(2), Pet.find(3))\n  # => [\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.size  # => 0\n  person.pets       # => []\n\n  Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (1, 2, 3)\n\nYou can pass +Fixnum+ or +String+ values, it finds the records\nresponding to the +id+ and then deletes them from the database.\n\n  person.pets.size # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  person.pets.destroy(\"4\")\n  # => #<Pet id: 4, name: \"Benny\", person_id: 1>\n\n  person.pets.size # => 2\n  person.pets\n  # => [\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  person.pets.destroy(5, 6)\n  # => [\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  person.pets.size  # => 0\n  person.pets       # => []\n\n  Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with IDs (4, 5, 6)",
  "distinct": "Specifies whether the records should be unique or not.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.select(:name)\n  # => [\n  #      #<Pet name: \"Fancy-Fancy\">,\n  #      #<Pet name: \"Fancy-Fancy\">\n  #    ]\n\n  person.pets.select(:name).distinct\n  # => [#<Pet name: \"Fancy-Fancy\">]",
  "uniq": "Specifies whether the records should be unique or not.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.select(:name)\n  # => [\n  #      #<Pet name: \"Fancy-Fancy\">,\n  #      #<Pet name: \"Fancy-Fancy\">\n  #    ]\n\n  person.pets.select(:name).distinct\n  # => [#<Pet name: \"Fancy-Fancy\">]",
  "count": "Count all records using SQL.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.count # => 3\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "size": "Returns the size of the collection. If the collection hasn't been loaded,\nit executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.\n\nIf the collection has been already loaded +size+ and +length+ are\nequivalent. If not and you are going to need the records anyway\n+length+ will take one less query. Otherwise +size+ is more efficient.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 3\n  # executes something like SELECT COUNT(*) FROM \"pets\" WHERE \"pets\".\"person_id\" = 1\n\n  person.pets # This will execute a SELECT * FROM query\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]\n\n  person.pets.size # => 3\n  # Because the collection is already loaded, this will behave like\n  # collection.size and no SQL count query is executed.",
  "length": "Returns the size of the collection calling +size+ on the target.\nIf the collection has been already loaded, +length+ and +size+ are\nequivalent. If not and you are going to need the records anyway this\nmethod will take one less query. Otherwise +size+ is more efficient.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.length # => 3\n  # executes something like SELECT \"pets\".* FROM \"pets\" WHERE \"pets\".\"person_id\" = 1\n\n  # Because the collection is loaded, you can\n  # call the collection with no additional queries:\n  person.pets\n  # => [\n  #       #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #       #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #       #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "empty?": "Returns +true+ if the collection is empty. If the collection has been\nloaded it is equivalent\nto <tt>collection.size.zero?</tt>. If the collection has not been loaded,\nit is equivalent to <tt>collection.exists?</tt>. If the collection has\nnot already been loaded and you are going to fetch the records anyway it\nis better to check <tt>collection.length.zero?</tt>.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.count  # => 1\n  person.pets.empty? # => false\n\n  person.pets.delete_all\n\n  person.pets.count  # => 0\n  person.pets.empty? # => true",
  "any?": "Returns +true+ if the collection is not empty.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.count # => 0\n  person.pets.any?  # => false\n\n  person.pets << Pet.new(name: 'Snoop')\n  person.pets.count # => 0\n  person.pets.any?  # => true\n\nYou can also pass a block to define criteria. The behavior\nis the same, it returns true if the collection based on the\ncriteria is not empty.\n\n  person.pets\n  # => [#<Pet name: \"Snoop\", group: \"dogs\">]\n\n  person.pets.any? do |pet|\n    pet.group == 'cats'\n  end\n  # => false\n\n  person.pets.any? do |pet|\n    pet.group == 'dogs'\n  end\n  # => true",
  "many?": "Returns true if the collection has more than one record.\nEquivalent to <tt>collection.size > 1</tt>.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.count # => 1\n  person.pets.many? # => false\n\n  person.pets << Pet.new(name: 'Snoopy')\n  person.pets.count # => 2\n  person.pets.many? # => true\n\nYou can also pass a block to define criteria. The\nbehavior is the same, it returns true if the collection\nbased on the criteria has more than one record.\n\n  person.pets\n  # => [\n  #      #<Pet name: \"Gorby\", group: \"cats\">,\n  #      #<Pet name: \"Puff\", group: \"cats\">,\n  #      #<Pet name: \"Snoop\", group: \"dogs\">\n  #    ]\n\n  person.pets.many? do |pet|\n    pet.group == 'dogs'\n  end\n  # => false\n\n  person.pets.many? do |pet|\n    pet.group == 'cats'\n  end\n  # => true",
  "include?": "Returns +true+ if the given object is present in the collection.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets # => [#<Pet id: 20, name: \"Snoop\">]\n\n  person.pets.include?(Pet.find(20)) # => true\n  person.pets.include?(Pet.find(21)) # => false",
  "arel": "",
  "proxy_association": "",
  "scoping": "We don't want this object to be put on the scoping stack, because\nthat could create an infinite loop where we call an @association\nmethod, which gets the current scope, which is this object, which\ndelegates to @association, and so on.",
  "scope": "Returns a <tt>Relation</tt> object for the records in this association",
  "spawn": "Returns a <tt>Relation</tt> object for the records in this association",
  "==": "Equivalent to <tt>Array#==</tt>. Returns +true+ if the two arrays\ncontain the same number of elements and if each element is equal\nto the corresponding element in the other array, otherwise returns\n+false+.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>\n  #    ]\n\n  other = person.pets.to_ary\n\n  person.pets == other\n  # => true\n\n  other = [Pet.new(id: 1), Pet.new(id: 2)]\n\n  person.pets == other\n  # => false",
  "to_ary": "Returns a new array of objects from the collection. If the collection\nhasn't been loaded, it fetches the records from the database.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  other_pets = person.pets.to_ary\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  other_pets.replace([Pet.new(name: 'BooGoo')])\n\n  other_pets\n  # => [#<Pet id: nil, name: \"BooGoo\", person_id: 1>]\n\n  person.pets\n  # This is not affected by replace\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]",
  "to_a": "Returns a new array of objects from the collection. If the collection\nhasn't been loaded, it fetches the records from the database.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  other_pets = person.pets.to_ary\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]\n\n  other_pets.replace([Pet.new(name: 'BooGoo')])\n\n  other_pets\n  # => [#<Pet id: nil, name: \"BooGoo\", person_id: 1>]\n\n  person.pets\n  # This is not affected by replace\n  # => [\n  #       #<Pet id: 4, name: \"Benny\", person_id: 1>,\n  #       #<Pet id: 5, name: \"Brain\", person_id: 1>,\n  #       #<Pet id: 6, name: \"Boss\",  person_id: 1>\n  #    ]",
  "<<": "Adds one or more +records+ to the collection by setting their foreign keys\nto the association's primary key. Returns +self+, so several appends may be\nchained together.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 0\n  person.pets << Pet.new(name: 'Fancy-Fancy')\n  person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]\n  person.pets.size # => 3\n\n  person.id # => 1\n  person.pets\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "push": "Adds one or more +records+ to the collection by setting their foreign keys\nto the association's primary key. Returns +self+, so several appends may be\nchained together.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 0\n  person.pets << Pet.new(name: 'Fancy-Fancy')\n  person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]\n  person.pets.size # => 3\n\n  person.id # => 1\n  person.pets\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "append": "Adds one or more +records+ to the collection by setting their foreign keys\nto the association's primary key. Returns +self+, so several appends may be\nchained together.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets.size # => 0\n  person.pets << Pet.new(name: 'Fancy-Fancy')\n  person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]\n  person.pets.size # => 3\n\n  person.id # => 1\n  person.pets\n  # => [\n  #      #<Pet id: 1, name: \"Fancy-Fancy\", person_id: 1>,\n  #      #<Pet id: 2, name: \"Spook\", person_id: 1>,\n  #      #<Pet id: 3, name: \"Choo-Choo\", person_id: 1>\n  #    ]",
  "prepend": "",
  "clear": "Equivalent to +delete_all+. The difference is that returns +self+, instead\nof an array with the deleted objects, so methods can be chained. See\n+delete_all+ for more information.",
  "reload": "Reloads the collection from the database. Returns +self+.\nEquivalent to <tt>collection(true)</tt>.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets # fetches pets from the database\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]\n\n  person.pets # uses the pets cache\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]\n\n  person.pets.reload # fetches pets from the database\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]\n\n  person.pets(true)  # fetches pets from the database\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]",
  "reset": "Unloads the association. Returns +self+.\n\n  class Person < ActiveRecord::Base\n    has_many :pets\n  end\n\n  person.pets # fetches pets from the database\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]\n\n  person.pets # uses the pets cache\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]\n\n  person.pets.reset # clears the pets cache\n\n  person.pets  # fetches pets from the database\n  # => [#<Pet id: 1, name: \"Snoop\", group: \"dogs\", person_id: 1>]"
}