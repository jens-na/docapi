{
  "owner": ":nodoc:",
  "target": ":nodoc:",
  "reflection": ":nodoc:",
  "inversed": "Returns the value of attribute inversed",
  "inversed=": "Sets the attribute inversed",
  "initialize": "",
  "aliased_table_name": "Returns the name of the table of the associated class:\n\n  post.comments.aliased_table_name # => \"comments\"",
  "reset": "Resets the \\loaded flag to +false+ and sets the \\target to +nil+.",
  "reload": "Reloads the \\target and returns +self+ on success.",
  "loaded?": "Has the \\target been already \\loaded?",
  "loaded!": "Asserts the \\target has been loaded setting the \\loaded flag to +true+.",
  "stale_target?": "The target is stale if the target no longer points to the record(s) that the\nrelevant foreign_key(s) refers to. If stale, the association accessor method\non the owner will reload the target. It's up to subclasses to implement the\nstale_state method if relevant.\n\nNote that if the target has not been loaded, it is not considered stale.",
  "target=": "Sets the target of this association to <tt>\\target</tt>, and the \\loaded flag to +true+.",
  "scope": "",
  "association_scope": "The scope for this association.\n\nNote that the association_scope is merged into the target_scope only when the\nscope method is called. This is because at that point the call may be surrounded\nby scope.scoping { ... } or with_scope { ... } etc, which affects the scope which\nactually gets built.",
  "reset_scope": "",
  "set_inverse_instance": "Set the inverse association, if possible",
  "klass": "Returns the class of the target. belongs_to polymorphic overrides this to look at the\npolymorphic_type field on the owner.",
  "target_scope": "Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the\nthrough association's scope)",
  "load_target": "Loads the \\target if needed and returns it.\n\nThis method is abstract in the sense that it relies on +find_target+,\nwhich is expected to be provided by descendants.\n\nIf the \\target is already \\loaded it is just returned. Thus, you can call\n+load_target+ unconditionally to get the \\target.\n\nActiveRecord::RecordNotFound is rescued within the method, and it is\nnot reraised. The proxy is \\reset and +nil+ is the return value.",
  "interpolate": "",
  "marshal_dump": "We can't dump @reflection since it contains the scope proc",
  "marshal_load": "",
  "initialize_attributes": ":nodoc:",
  "find_target?": "",
  "creation_attributes": "",
  "set_owner_attributes": "Sets the owner attributes on the given record",
  "foreign_key_present?": "Returns true if there is a foreign key present on the owner which\nreferences the target. This is used to determine whether we can load\nthe target if the owner is currently a new record (and therefore\nwithout a key). If the owner is a new record then foreign_key must\nbe present in order to load target.\n\nCurrently implemented by belongs_to (vanilla and polymorphic) and\nhas_one/has_many :through associations which go through a belongs_to.",
  "raise_on_type_mismatch!": "Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of\nthe kind of the class of the associated objects. Meant to be used as\na sanity check when you are about to assign an associated record.",
  "inverse_reflection_for": "Can be redefined by subclasses, notably polymorphic belongs_to\nThe record parameter is necessary to support polymorphic inverses as we must check for\nthe association in the specific class of the record.",
  "invertible_for?": "Returns true if inverse association on the given record needs to be set.\nThis method is redefined by subclasses.",
  "foreign_key_for?": "Returns true if record contains the foreign_key",
  "stale_state": "This should be implemented to return the values of the relevant key(s) on the owner,\nso that when stale_state is different from the value stored on the last find_target,\nthe target is stale.\n\nThis is only relevant to certain associations, which is why it returns nil by default.",
  "build_record": ""
}