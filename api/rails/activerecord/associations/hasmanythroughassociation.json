{
  "initialize": "",
  "size": "Returns the size of the collection by executing a SELECT COUNT(*) query\nif the collection hasn't been loaded, and by calling collection.size if\nit has. If the collection will likely have a size greater than zero,\nand if fetching the collection will be needed afterwards, one less\nSELECT query will be generated by using #length instead.",
  "concat": "",
  "concat_records": "",
  "insert_record": "",
  "through_association": "",
  "build_through_record": "The through record (built with build_record) is temporarily cached\nso that it may be reused if insert_record is subsequently called.\n\nHowever, after insert_record has been called, the cache is cleared in\norder to allow multiple instances of the same record in an association.",
  "options_for_through_record": "",
  "through_scope_attributes": "",
  "save_through_record": "",
  "build_record": "",
  "target_reflection_has_associated_record?": "",
  "update_through_counter?": "",
  "delete_or_nullify_all_records": "",
  "delete_records": "",
  "through_records_for": "",
  "delete_through_records": "",
  "find_target": "",
  "invertible_for?": "NOTE - not sure that we can actually cope with inverses here"
}