{
  "JoinOperation": "",
  "MULTI_VALUE_METHODS": "",
  "SINGLE_VALUE_METHODS": "",
  "VALUE_METHODS": "",
  "table": "Returns the value of attribute table",
  "klass": "Returns the value of attribute klass",
  "loaded": "Returns the value of attribute loaded",
  "model": "Returns the value of attribute klass",
  "loaded?": "Returns the value of attribute loaded",
  "initialize": "",
  "initialize_copy": "",
  "insert": ":nodoc:",
  "update_record": ":nodoc:",
  "substitute_values": ":nodoc:",
  "new": "Initializes new record from relation while maintaining the current\nscope.\n\nExpects arguments in the same format as +Base.new+.\n\n  users = User.where(name: 'DHH')\n  user = users.new # => #<User id: nil, name: \"DHH\", created_at: nil, updated_at: nil>\n\nYou can also pass a block to new with the new record as argument:\n\n  user = users.new { |user| user.name = 'Oscar' }\n  user.name # => Oscar",
  "build": "Initializes new record from relation while maintaining the current\nscope.\n\nExpects arguments in the same format as +Base.new+.\n\n  users = User.where(name: 'DHH')\n  user = users.new # => #<User id: nil, name: \"DHH\", created_at: nil, updated_at: nil>\n\nYou can also pass a block to new with the new record as argument:\n\n  user = users.new { |user| user.name = 'Oscar' }\n  user.name # => Oscar",
  "create": "Tries to create a new record with the same scoped attributes\ndefined in the relation. Returns the initialized object if validation fails.\n\nExpects arguments in the same format as +Base.create+.\n\n==== Examples\n  users = User.where(name: 'Oscar')\n  users.create # #<User id: 3, name: \"oscar\", ...>\n\n  users.create(name: 'fxn')\n  users.create # #<User id: 4, name: \"fxn\", ...>\n\n  users.create { |user| user.name = 'tenderlove' }\n  # #<User id: 5, name: \"tenderlove\", ...>\n\n  users.create(name: nil) # validation on name\n  # #<User id: nil, name: nil, ...>",
  "create!": "Similar to #create, but calls +create!+ on the base class. Raises\nan exception if a validation error occurs.\n\nExpects arguments in the same format as <tt>Base.create!</tt>.",
  "first_or_create": ":nodoc:",
  "first_or_create!": ":nodoc:",
  "first_or_initialize": ":nodoc:",
  "find_or_create_by": "Finds the first record with the given attributes, or creates a record\nwith the attributes if one is not found:\n\n  # Find the first user named \"Penélope\" or create a new one.\n  User.find_or_create_by(first_name: 'Penélope')\n  # => #<User id: 1, first_name: \"Penélope\", last_name: nil>\n\n  # Find the first user named \"Penélope\" or create a new one.\n  # We already have one so the existing record will be returned.\n  User.find_or_create_by(first_name: 'Penélope')\n  # => #<User id: 1, first_name: \"Penélope\", last_name: nil>\n\n  # Find the first user named \"Scarlett\" or create a new one with\n  # a particular last name.\n  User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')\n  # => #<User id: 2, first_name: \"Scarlett\", last_name: \"Johansson\">\n\nThis method accepts a block, which is passed down to +create+. The last example\nabove can be alternatively written this way:\n\n  # Find the first user named \"Scarlett\" or create a new one with a\n  # different last name.\n  User.find_or_create_by(first_name: 'Scarlett') do |user|\n    user.last_name = 'Johansson'\n  end\n  # => #<User id: 2, first_name: \"Scarlett\", last_name: \"Johansson\">\n\nThis method always returns a record, but if creation was attempted and\nfailed due to validation errors it won't be persisted, you get what\n+create+ returns in such situation.\n\nPlease note *this method is not atomic*, it runs first a SELECT, and if\nthere are no results an INSERT is attempted. If there are other threads\nor processes there is a race condition between both calls and it could\nbe the case that you end up with two similar records.\n\nWhether that is a problem or not depends on the logic of the\napplication, but in the particular case in which rows have a UNIQUE\nconstraint an exception may be raised, just retry:\n\n begin\n   CreditAccount.find_or_create_by(user_id: user.id)\n rescue ActiveRecord::RecordNotUnique\n   retry\n end",
  "find_or_create_by!": "Like <tt>find_or_create_by</tt>, but calls <tt>create!</tt> so an exception\nis raised if the created record is invalid.",
  "find_or_initialize_by": "Like <tt>find_or_create_by</tt>, but calls <tt>new</tt> instead of <tt>create</tt>.",
  "explain": "Runs EXPLAIN on the query or queries triggered by this relation and\nreturns the result as a string. The string is formatted imitating the\nones printed by the database shell.\n\nNote that this method actually runs the queries, since the results of some\nare needed by the next ones when eager loading is going on.\n\nPlease see further details in the\n{Active Record Query Interface guide}[http://guides.rubyonrails.org/active_record_querying.html#running-explain].",
  "to_a": "Converts relation objects to Array.",
  "as_json": ":nodoc:",
  "size": "Returns size of the records.",
  "empty?": "Returns true if there are no records.",
  "any?": "Returns true if there are any records.",
  "many?": "Returns true if there is more than one record.",
  "scoping": "Scope all queries to the current scope.\n\n  Comment.where(post_id: 1).scoping do\n    Comment.first\n  end\n  # => SELECT \"comments\".* FROM \"comments\" WHERE \"comments\".\"post_id\" = 1 ORDER BY \"comments\".\"id\" ASC LIMIT 1\n\nPlease check unscoped if you want to remove all previous scopes (including\nthe default_scope) during the execution of a block.",
  "update_all": "Updates all records with details given if they match a set of conditions supplied, limits and order can\nalso be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the\ndatabase. It does not instantiate the involved models and it does not trigger Active Record callbacks\nor validations.\n\n==== Parameters\n\n* +updates+ - A string, array, or hash representing the SET part of an SQL statement.\n\n==== Examples\n\n  # Update all customers with the given attributes\n  Customer.update_all wants_email: true\n\n  # Update all books with 'Rails' in their title\n  Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')\n\n  # Update all books that match conditions, but limit it to 5 ordered by date\n  Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')",
  "update": "Updates an object (or multiple objects) and saves it to the database, if validations pass.\nThe resulting object is returned whether the object was saved successfully to the database or not.\n\n==== Parameters\n\n* +id+ - This should be the id or an array of ids to be updated.\n* +attributes+ - This should be a hash of attributes or an array of hashes.\n\n==== Examples\n\n  # Updates one record\n  Person.update(15, user_name: 'Samuel', group: 'expert')\n\n  # Updates multiple records\n  people = { 1 => { \"first_name\" => \"David\" }, 2 => { \"first_name\" => \"Jeremy\" } }\n  Person.update(people.keys, people.values)",
  "destroy_all": "Destroys the records matching +conditions+ by instantiating each\nrecord and calling its +destroy+ method. Each object's callbacks are\nexecuted (including <tt>:dependent</tt> association options). Returns the\ncollection of objects that were destroyed; each will be frozen, to\nreflect that no changes should be made (since they can't be persisted).\n\nNote: Instantiation, callback execution, and deletion of each\nrecord can be time consuming when you're removing many records at\nonce. It generates at least one SQL +DELETE+ query per record (or\npossibly more, to enforce your callbacks). If you want to delete many\nrows quickly, without concern for their associations or callbacks, use\n+delete_all+ instead.\n\n==== Parameters\n\n* +conditions+ - A string, array, or hash that specifies which records\n  to destroy. If omitted, all records are destroyed. See the\n  Conditions section in the introduction to ActiveRecord::Base for\n  more information.\n\n==== Examples\n\n  Person.destroy_all(\"last_login < '2004-04-04'\")\n  Person.destroy_all(status: \"inactive\")\n  Person.where(age: 0..18).destroy_all",
  "destroy": "Destroy an object (or multiple objects) that has the given id. The object is instantiated first,\ntherefore all callbacks and filters are fired off before the object is deleted. This method is\nless efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.\n\nThis essentially finds the object (or multiple objects) with the given id, creates a new object\nfrom the attributes, and then calls destroy on it.\n\n==== Parameters\n\n* +id+ - Can be either an Integer or an Array of Integers.\n\n==== Examples\n\n  # Destroy a single object\n  Todo.destroy(1)\n\n  # Destroy multiple objects\n  todos = [1,2,3]\n  Todo.destroy(todos)",
  "delete_all": "Deletes the records matching +conditions+ without instantiating the records\nfirst, and hence not calling the +destroy+ method nor invoking callbacks. This\nis a single SQL DELETE statement that goes straight to the database, much more\nefficient than +destroy_all+. Be careful with relations though, in particular\n<tt>:dependent</tt> rules defined on associations are not honored. Returns the\nnumber of rows affected.\n\n  Post.delete_all(\"person_id = 5 AND (category = 'Something' OR category = 'Else')\")\n  Post.delete_all([\"person_id = ? AND (category = ? OR category = ?)\", 5, 'Something', 'Else'])\n  Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all\n\nBoth calls delete the affected posts all at once with a single DELETE statement.\nIf you need to destroy dependent associations or call your <tt>before_*</tt> or\n+after_destroy+ callbacks, use the +destroy_all+ method instead.\n\nIf a limit scope is supplied, +delete_all+ raises an ActiveRecord error:\n\n  Post.limit(100).delete_all\n  # => ActiveRecord::ActiveRecordError: delete_all doesn't support limit scope",
  "delete": "Deletes the row with a primary key matching the +id+ argument, using a\nSQL +DELETE+ statement, and returns the number of rows deleted. Active\nRecord objects are not instantiated, so the object's callbacks are not\nexecuted, including any <tt>:dependent</tt> association options.\n\nYou can delete multiple rows at once by passing an Array of <tt>id</tt>s.\n\nNote: Although it is often much faster than the alternative,\n<tt>#destroy</tt>, skipping callbacks might bypass business logic in\nyour application that ensures referential integrity or performs other\nessential jobs.\n\n==== Examples\n\n  # Delete a single row\n  Todo.delete(1)\n\n  # Delete multiple rows\n  Todo.delete([2,3,4])",
  "load": "Causes the records to be loaded from the database if they have not\nbeen loaded already. You can use this if for some reason you need\nto explicitly load some records before actually using them. The\nreturn value is the relation itself, not the records.\n\n  Post.where(published: true).load # => #<ActiveRecord::Relation>",
  "reload": "Forces reloading of relation.",
  "reset": "",
  "to_sql": "Returns sql statement for the relation.\n\n  User.where(name: 'Oscar').to_sql\n  # => SELECT \"users\".* FROM \"users\"  WHERE \"users\".\"name\" = 'Oscar'",
  "where_values_hash": "Returns a hash of where conditions.\n\n  User.where(name: 'Oscar').where_values_hash\n  # => {name: \"Oscar\"}",
  "scope_for_create": "",
  "eager_loading?": "Returns true if relation needs eager loading.",
  "joined_includes_values": "Joins that are also marked for preloading. In which case we should just eager load them.\nNote that this is a naive implementation because we could have strings and symbols which\nrepresent the same association, but that aren't matched by this. Also, we could have\nnested hashes which partially match, e.g. { a: :b } & { a: [:b, :c] }",
  "uniq_value": "+uniq+ and +uniq!+ are silently deprecated. +uniq_value+ delegates to +distinct_value+\nto maintain backwards compatibility. Use +distinct_value+ instead.",
  "==": "Compares two relations for equality.",
  "pretty_print": "",
  "blank?": "Returns true if relation is blank.",
  "values": "",
  "inspect": "",
  "exec_queries": "",
  "references_eager_loaded_tables?": "",
  "tables_in_string": "",
  "HashMerger": ":nodoc:",
  "Merger": ":nodoc:"
}