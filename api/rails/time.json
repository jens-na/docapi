{
  "zone_default": "Returns the value of attribute zone_default",
  "zone_default=": "Sets the attribute zone_default",
  "zone": "Returns the TimeZone for the current request, if this has been set (via Time.zone=).\nIf <tt>Time.zone</tt> has not been set for the current request, returns the TimeZone specified in <tt>config.time_zone</tt>.",
  "zone=": "Sets <tt>Time.zone</tt> to a TimeZone object for the current request/thread.\n\nThis method accepts any of the following:\n\n* A Rails TimeZone object.\n* An identifier for a Rails TimeZone object (e.g., \"Eastern Time (US & Canada)\", <tt>-5.hours</tt>).\n* A TZInfo::Timezone object.\n* An identifier for a TZInfo::Timezone object (e.g., \"America/New_York\").\n\nHere's an example of how you might set <tt>Time.zone</tt> on a per request basis and reset it when the request is done.\n<tt>current_user.time_zone</tt> just needs to return a string identifying the user's preferred time zone:\n\n  class ApplicationController < ActionController::Base\n    around_filter :set_time_zone\n\n    def set_time_zone\n      if logged_in?\n        Time.use_zone(current_user.time_zone) { yield }\n      else\n        yield\n      end\n    end\n  end",
  "use_zone": "Allows override of <tt>Time.zone</tt> locally inside supplied block; resets <tt>Time.zone</tt> to existing value when done.",
  "find_zone!": "Returns a TimeZone instance or nil, or raises an ArgumentError for invalid timezones.",
  "find_zone": "",
  "as_json": ":nodoc:",
  "_load_without_zone": "",
  "_load": "",
  "_dump_without_zone": "",
  "_dump": "",
  "acts_like_time?": "Duck-types as a Time-like class. See Object#acts_like?.",
  "DATE_FORMATS": "",
  "to_formatted_s": "Converts to a formatted string. See DATE_FORMATS for builtin formats.\n\nThis method is aliased to <tt>to_s</tt>.\n\n  time = Time.now                    # => Thu Jan 18 06:10:17 CST 2007\n\n  time.to_formatted_s(:time)         # => \"06:10\"\n  time.to_s(:time)                   # => \"06:10\"\n\n  time.to_formatted_s(:db)           # => \"2007-01-18 06:10:17\"\n  time.to_formatted_s(:number)       # => \"20070118061017\"\n  time.to_formatted_s(:short)        # => \"18 Jan 06:10\"\n  time.to_formatted_s(:long)         # => \"January 18, 2007 06:10\"\n  time.to_formatted_s(:long_ordinal) # => \"January 18th, 2007 06:10\"\n  time.to_formatted_s(:rfc822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\"\n  time.to_formatted_s(:iso8601)      # => \"2007-01-18T06:10:17-06:00\"\n\n== Adding your own time formats to +to_formatted_s+\nYou can add your own formats to the Time::DATE_FORMATS hash.\nUse the format name as the hash key and either a strftime string\nor Proc instance that takes a time argument as the value.\n\n  # config/initializers/time_formats.rb\n  Time::DATE_FORMATS[:month_and_year] = '%B %Y'\n  Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime(\"%B #{time.day.ordinalize}\") }",
  "to_default_s": "",
  "to_s": "Converts to a formatted string. See DATE_FORMATS for builtin formats.\n\nThis method is aliased to <tt>to_s</tt>.\n\n  time = Time.now                    # => Thu Jan 18 06:10:17 CST 2007\n\n  time.to_formatted_s(:time)         # => \"06:10\"\n  time.to_s(:time)                   # => \"06:10\"\n\n  time.to_formatted_s(:db)           # => \"2007-01-18 06:10:17\"\n  time.to_formatted_s(:number)       # => \"20070118061017\"\n  time.to_formatted_s(:short)        # => \"18 Jan 06:10\"\n  time.to_formatted_s(:long)         # => \"January 18, 2007 06:10\"\n  time.to_formatted_s(:long_ordinal) # => \"January 18th, 2007 06:10\"\n  time.to_formatted_s(:rfc822)       # => \"Thu, 18 Jan 2007 06:10:17 -0600\"\n  time.to_formatted_s(:iso8601)      # => \"2007-01-18T06:10:17-06:00\"\n\n== Adding your own time formats to +to_formatted_s+\nYou can add your own formats to the Time::DATE_FORMATS hash.\nUse the format name as the hash key and either a strftime string\nor Proc instance that takes a time argument as the value.\n\n  # config/initializers/time_formats.rb\n  Time::DATE_FORMATS[:month_and_year] = '%B %Y'\n  Time::DATE_FORMATS[:short_ordinal]  = ->(time) { time.strftime(\"%B #{time.day.ordinalize}\") }",
  "formatted_offset": "Returns the UTC offset as an +HH:MM formatted string.\n\n  Time.local(2000).formatted_offset        # => \"-06:00\"\n  Time.local(2000).formatted_offset(false) # => \"-0600\"",
  "COMMON_YEAR_DAYS_IN_MONTH": "",
  "===": "Overriding case equality method so that it returns true for ActiveSupport::TimeWithZone instances",
  "days_in_month": "Return the number of days in the given month.\nIf no year is specified, it will use the current year.",
  "current": "Returns <tt>Time.zone.now</tt> when <tt>Time.zone</tt> or <tt>config.time_zone</tt> are set, otherwise just returns <tt>Time.now</tt>.",
  "at_with_coercion": "Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime\ninstances can be used when called with a single argument",
  "at_without_coercion": "",
  "at": "Layers additional behavior on Time.at so that ActiveSupport::TimeWithZone and DateTime\ninstances can be used when called with a single argument",
  "seconds_since_midnight": "Seconds since midnight: Time.now.seconds_since_midnight",
  "seconds_until_end_of_day": "Returns the number of seconds until 23:59:59.\n\n  Time.new(2012, 8, 29,  0,  0,  0).seconds_until_end_of_day # => 86399\n  Time.new(2012, 8, 29, 12, 34, 56).seconds_until_end_of_day # => 41103\n  Time.new(2012, 8, 29, 23, 59, 59).seconds_until_end_of_day # => 0",
  "change": "Returns a new Time where one or more of the elements have been changed according\nto the +options+ parameter. The time options (<tt>:hour</tt>, <tt>:min</tt>,\n<tt>:sec</tt>, <tt>:usec</tt>) reset cascadingly, so if only the hour is passed,\nthen minute, sec, and usec is set to 0. If the hour and minute is passed, then\nsec and usec is set to 0.  The +options+ parameter takes a hash with any of these\nkeys: <tt>:year</tt>, <tt>:month</tt>, <tt>:day</tt>, <tt>:hour</tt>, <tt>:min</tt>,\n<tt>:sec</tt>, <tt>:usec</tt>.\n\n  Time.new(2012, 8, 29, 22, 35, 0).change(day: 1)              # => Time.new(2012, 8, 1, 22, 35, 0)\n  Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, day: 1)  # => Time.new(1981, 8, 1, 22, 35, 0)\n  Time.new(2012, 8, 29, 22, 35, 0).change(year: 1981, hour: 0) # => Time.new(1981, 8, 29, 0, 0, 0)",
  "advance": "Uses Date to provide precise Time calculations for years, months, and days\naccording to the proleptic Gregorian calendar. The +options+ parameter\ntakes a hash with any of these keys: <tt>:years</tt>, <tt>:months</tt>,\n<tt>:weeks</tt>, <tt>:days</tt>, <tt>:hours</tt>, <tt>:minutes</tt>,\n<tt>:seconds</tt>.",
  "ago": "Returns a new Time representing the time a number of seconds ago, this is basically a wrapper around the Numeric extension",
  "since": "Returns a new Time representing the time a number of seconds since the instance time",
  "in": "Returns a new Time representing the time a number of seconds since the instance time",
  "beginning_of_day": "Returns a new Time representing the start of the day (0:00)",
  "midnight": "Returns a new Time representing the start of the day (0:00)",
  "at_midnight": "Returns a new Time representing the start of the day (0:00)",
  "at_beginning_of_day": "Returns a new Time representing the start of the day (0:00)",
  "middle_of_day": "Returns a new Time representing the middle of the day (12:00)",
  "midday": "Returns a new Time representing the middle of the day (12:00)",
  "noon": "Returns a new Time representing the middle of the day (12:00)",
  "at_midday": "Returns a new Time representing the middle of the day (12:00)",
  "at_noon": "Returns a new Time representing the middle of the day (12:00)",
  "at_middle_of_day": "Returns a new Time representing the middle of the day (12:00)",
  "end_of_day": "Returns a new Time representing the end of the day, 23:59:59.999999 (.999999999 in ruby1.9)",
  "at_end_of_day": "Returns a new Time representing the end of the day, 23:59:59.999999 (.999999999 in ruby1.9)",
  "beginning_of_hour": "Returns a new Time representing the start of the hour (x:00)",
  "at_beginning_of_hour": "Returns a new Time representing the start of the hour (x:00)",
  "end_of_hour": "Returns a new Time representing the end of the hour, x:59:59.999999 (.999999999 in ruby1.9)",
  "at_end_of_hour": "Returns a new Time representing the end of the hour, x:59:59.999999 (.999999999 in ruby1.9)",
  "beginning_of_minute": "Returns a new Time representing the start of the minute (x:xx:00)",
  "at_beginning_of_minute": "Returns a new Time representing the start of the minute (x:xx:00)",
  "end_of_minute": "Returns a new Time representing the end of the minute, x:xx:59.999999 (.999999999 in ruby1.9)",
  "at_end_of_minute": "Returns a new Time representing the end of the minute, x:xx:59.999999 (.999999999 in ruby1.9)",
  "all_day": "Returns a Range representing the whole day of the current time.",
  "plus_with_duration": ":nodoc:",
  "plus_without_duration": "",
  "+": ":nodoc:",
  "minus_with_duration": ":nodoc:",
  "minus_without_duration": "",
  "-": "Time#- can also be used to determine the number of seconds between two Time instances.\nWe're layering on additional behavior so that ActiveSupport::TimeWithZone instances\nare coerced into values that Time#- will recognize",
  "minus_with_coercion": "Time#- can also be used to determine the number of seconds between two Time instances.\nWe're layering on additional behavior so that ActiveSupport::TimeWithZone instances\nare coerced into values that Time#- will recognize",
  "minus_without_coercion": ":nodoc:",
  "compare_with_coercion": "Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances\ncan be chronologically compared with a Time",
  "compare_without_coercion": "",
  "<=>": "Layers additional behavior on Time#<=> so that DateTime and ActiveSupport::TimeWithZone instances\ncan be chronologically compared with a Time",
  "eql_with_coercion": "Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances\ncan be eql? to an equivalent Time",
  "eql_without_coercion": "",
  "eql?": "Layers additional behavior on Time#eql? so that ActiveSupport::TimeWithZone instances\ncan be eql? to an equivalent Time"
}