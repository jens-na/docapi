{
  "silence": "Returns the value of attribute silence",
  "options": "Returns the value of attribute options",
  "silence?": "Returns the value of attribute silence",
  "initialize": "Create a new cache. The options will be passed to any write method calls\nexcept for <tt>:namespace</tt> which can be used to set the global\nnamespace for the cache.",
  "silence!": "Silence the logger.",
  "mute": "Silence the logger within a block.",
  "instrument=": "Set to +true+ if cache stores should be instrumented.\nDefault is +false+.",
  "instrument": "",
  "fetch": "Fetches data from the cache, using the given key. If there is data in\nthe cache with the given key, then that data is returned.\n\nIf there is no such data in the cache (a cache miss), then +nil+ will be\nreturned. However, if a block has been passed, that block will be passed\nthe key and executed in the event of a cache miss. The return value of the\nblock will be written to the cache under the given cache key, and that\nreturn value will be returned.\n\n  cache.write('today', 'Monday')\n  cache.fetch('today')  # => \"Monday\"\n\n  cache.fetch('city')   # => nil\n  cache.fetch('city') do\n    'Duckburgh'\n  end\n  cache.fetch('city')   # => \"Duckburgh\"\n\nYou may also specify additional options via the +options+ argument.\nSetting <tt>force: true</tt> will force a cache miss:\n\n  cache.write('today', 'Monday')\n  cache.fetch('today', force: true)  # => nil\n\nSetting <tt>:compress</tt> will store a large cache entry set by the call\nin a compressed format.\n\nSetting <tt>:expires_in</tt> will set an expiration time on the cache.\nAll caches support auto-expiring content after a specified number of\nseconds. This value can be specified as an option to the constructor\n(in which case all entries will be affected), or it can be supplied to\nthe +fetch+ or +write+ method to effect just one entry.\n\n  cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 5.minutes)\n  cache.write(key, value, expires_in: 1.minute) # Set a lower value for one entry\n\nSetting <tt>:race_condition_ttl</tt> is very useful in situations where\na cache entry is used very frequently and is under heavy load. If a\ncache expires and due to heavy load several different processes will try\nto read data natively and then they all will try to write to cache. To\navoid that case the first process to find an expired cache entry will\nbump the cache expiration time by the value set in <tt>:race_condition_ttl</tt>.\nYes, this process is extending the time for a stale value by another few\nseconds. Because of extended life of the previous cache, other processes\nwill continue to use slightly stale data for a just a bit longer. In the\nmeantime that first process will go ahead and will write into cache the\nnew value. After that all the processes will start getting new value.\nThe key is to keep <tt>:race_condition_ttl</tt> small.\n\nIf the process regenerating the entry errors out, the entry will be\nregenerated after the specified number of seconds. Also note that the\nlife of stale cache is extended only if it expired recently. Otherwise\na new value is generated and <tt>:race_condition_ttl</tt> does not play\nany role.\n\n  # Set all values to expire after one minute.\n  cache = ActiveSupport::Cache::MemoryStore.new(expires_in: 1.minute)\n\n  cache.write('foo', 'original value')\n  val_1 = nil\n  val_2 = nil\n  sleep 60\n\n  Thread.new do\n    val_1 = cache.fetch('foo', race_condition_ttl: 10) do\n      sleep 1\n      'new value 1'\n    end\n  end\n\n  Thread.new do\n    val_2 = cache.fetch('foo', race_condition_ttl: 10) do\n      'new value 2'\n    end\n  end\n\n  # val_1 => \"new value 1\"\n  # val_2 => \"original value\"\n  # sleep 10 # First thread extend the life of cache by another 10 seconds\n  # cache.fetch('foo') => \"new value 1\"\n\nOther options will be handled by the specific cache store implementation.\nInternally, #fetch calls #read_entry, and calls #write_entry on a cache\nmiss. +options+ will be passed to the #read and #write calls.\n\nFor example, MemCacheStore's #write method supports the +:raw+\noption, which tells the memcached server to store all values as strings.\nWe can use this option with #fetch too:\n\n  cache = ActiveSupport::Cache::MemCacheStore.new\n  cache.fetch(\"foo\", force: true, raw: true) do\n    :bar\n  end\n  cache.fetch('foo') # => \"bar\"",
  "read": "Fetches data from the cache, using the given key. If there is data in\nthe cache with the given key, then that data is returned. Otherwise,\n+nil+ is returned.\n\nOptions are passed to the underlying cache implementation.",
  "read_multi": "Read multiple values at once from the cache. Options can be passed\nin the last argument.\n\nSome cache implementation may optimize this method.\n\nReturns a hash mapping the names provided to the values found.",
  "fetch_multi": "Fetches data from the cache, using the given keys. If there is data in\nthe cache with the given keys, then that data is returned. Otherwise,\nthe supplied block is called for each key for which there was no data,\nand the result will be written to the cache and returned.\n\nOptions are passed to the underlying cache implementation.\n\nReturns an array with the data for each of the names. For example:\n\n  cache.write(\"bim\", \"bam\")\n  cache.fetch_multi(\"bim\", \"boom\") {|key| key * 2 }\n  # => [\"bam\", \"boomboom\"]",
  "write": "Writes the value to the cache, with the key.\n\nOptions are passed to the underlying cache implementation.",
  "delete": "Deletes an entry in the cache. Returns +true+ if an entry is deleted.\n\nOptions are passed to the underlying cache implementation.",
  "exist?": "Returns +true+ if the cache contains an entry for the given key.\n\nOptions are passed to the underlying cache implementation.",
  "delete_matched": "Delete all entries with keys matching the pattern.\n\nOptions are passed to the underlying cache implementation.\n\nAll implementations may not support this method.",
  "increment": "Increment an integer value in the cache.\n\nOptions are passed to the underlying cache implementation.\n\nAll implementations may not support this method.",
  "decrement": "Decrement an integer value in the cache.\n\nOptions are passed to the underlying cache implementation.\n\nAll implementations may not support this method.",
  "cleanup": "Cleanup the cache by removing expired entries.\n\nOptions are passed to the underlying cache implementation.\n\nAll implementations may not support this method.",
  "clear": "Clear the entire cache. Be careful with this method since it could\naffect other processes if shared cache is being used.\n\nThe options hash is passed to the underlying cache implementation.\n\nAll implementations may not support this method.",
  "key_matcher": "Add the namespace defined in the options to a pattern designed to\nmatch keys. Implementations that support delete_matched should call\nthis method to translate a pattern that matches names into one that\nmatches namespaced keys.",
  "read_entry": "Read an entry from the cache implementation. Subclasses must implement\nthis method.",
  "write_entry": "Write an entry to the cache implementation. Subclasses must implement\nthis method.",
  "delete_entry": "Delete an entry from the cache implementation. Subclasses must\nimplement this method.",
  "merged_options": "Merge the default options with ones specific to a method call.",
  "expanded_key": "Expand key to be a consistent string value. Invoke +cache_key+ if\nobject responds to +cache_key+. Otherwise, +to_param+ method will be\ncalled. If the key is a Hash, then keys will be sorted alphabetically.",
  "namespaced_key": "Prefix a key with the namespace. Namespace and key will be delimited\nwith a colon.",
  "log": "",
  "find_cached_entry": "",
  "handle_expired_entry": "",
  "get_entry_value": "",
  "save_block_result_to_cache": ""
}