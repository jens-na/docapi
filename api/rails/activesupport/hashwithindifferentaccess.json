{
  "extractable_options?": "Returns +true+ so that <tt>Array#extract_options!</tt> finds members of\nthis class.",
  "with_indifferent_access": "",
  "nested_under_indifferent_access": "",
  "initialize": "",
  "default": "",
  "new_from_hash_copying_default": "",
  "[]": "",
  "regular_writer": "",
  "regular_update": "",
  "[]=": "Assigns a new value to the hash:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash[:key] = 'value'\n\nThis value can be later fetched using either +:key+ or +'key'+.",
  "store": "Assigns a new value to the hash:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash[:key] = 'value'\n\nThis value can be later fetched using either +:key+ or +'key'+.",
  "update": "Updates the receiver in-place, merging in the hash passed as argument:\n\n  hash_1 = ActiveSupport::HashWithIndifferentAccess.new\n  hash_1[:key] = 'value'\n\n  hash_2 = ActiveSupport::HashWithIndifferentAccess.new\n  hash_2[:key] = 'New Value!'\n\n  hash_1.update(hash_2) # => {\"key\"=>\"New Value!\"}\n\nThe argument can be either an\n<tt>ActiveSupport::HashWithIndifferentAccess</tt> or a regular +Hash+.\nIn either case the merge respects the semantics of indifferent access.\n\nIf the argument is a regular hash with keys +:key+ and +\"key\"+ only one\nof the values end up in the receiver, but which one is unspecified.\n\nWhen given a block, the value for duplicated keys will be determined\nby the result of invoking the block with the duplicated key, the value\nin the receiver, and the value in +other_hash+. The rules for duplicated\nkeys follow the semantics of indifferent access:\n\n  hash_1[:key] = 10\n  hash_2['key'] = 12\n  hash_1.update(hash_2) { |key, old, new| old + new } # => {\"key\"=>22}",
  "merge!": "Updates the receiver in-place, merging in the hash passed as argument:\n\n  hash_1 = ActiveSupport::HashWithIndifferentAccess.new\n  hash_1[:key] = 'value'\n\n  hash_2 = ActiveSupport::HashWithIndifferentAccess.new\n  hash_2[:key] = 'New Value!'\n\n  hash_1.update(hash_2) # => {\"key\"=>\"New Value!\"}\n\nThe argument can be either an\n<tt>ActiveSupport::HashWithIndifferentAccess</tt> or a regular +Hash+.\nIn either case the merge respects the semantics of indifferent access.\n\nIf the argument is a regular hash with keys +:key+ and +\"key\"+ only one\nof the values end up in the receiver, but which one is unspecified.\n\nWhen given a block, the value for duplicated keys will be determined\nby the result of invoking the block with the duplicated key, the value\nin the receiver, and the value in +other_hash+. The rules for duplicated\nkeys follow the semantics of indifferent access:\n\n  hash_1[:key] = 10\n  hash_2['key'] = 12\n  hash_1.update(hash_2) { |key, old, new| old + new } # => {\"key\"=>22}",
  "key?": "Checks the hash for a key matching the argument passed in:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash['key'] = 'value'\n  hash.key?(:key)  # => true\n  hash.key?('key') # => true",
  "include?": "Checks the hash for a key matching the argument passed in:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash['key'] = 'value'\n  hash.key?(:key)  # => true\n  hash.key?('key') # => true",
  "has_key?": "Checks the hash for a key matching the argument passed in:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash['key'] = 'value'\n  hash.key?(:key)  # => true\n  hash.key?('key') # => true",
  "member?": "Checks the hash for a key matching the argument passed in:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash['key'] = 'value'\n  hash.key?(:key)  # => true\n  hash.key?('key') # => true",
  "fetch": "Same as <tt>Hash#fetch</tt> where the key passed as argument can be\neither a string or a symbol:\n\n  counters = ActiveSupport::HashWithIndifferentAccess.new\n  counters[:foo] = 1\n\n  counters.fetch('foo')          # => 1\n  counters.fetch(:bar, 0)        # => 0\n  counters.fetch(:bar) { |key| 0 } # => 0\n  counters.fetch(:zoo)           # => KeyError: key not found: \"zoo\"",
  "values_at": "Returns an array of the values at the specified indices:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash[:a] = 'x'\n  hash[:b] = 'y'\n  hash.values_at('a', 'b') # => [\"x\", \"y\"]",
  "dup": "Returns a shallow copy of the hash.\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new({ a: { b: 'b' } })\n  dup  = hash.dup\n  dup[:a][:c] = 'c'\n\n  hash[:a][:c] # => nil\n  dup[:a][:c]  # => \"c\"",
  "merge": "This method has the same semantics of +update+, except it does not\nmodify the receiver but rather returns a new hash with indifferent\naccess with the result of the merge.",
  "reverse_merge": "Like +merge+ but the other way around: Merges the receiver into the\nargument and returns a new hash with indifferent access as result:\n\n  hash = ActiveSupport::HashWithIndifferentAccess.new\n  hash['a'] = nil\n  hash.reverse_merge(a: 0, b: 1) # => {\"a\"=>nil, \"b\"=>1}",
  "reverse_merge!": "Same semantics as +reverse_merge+ but modifies the receiver in-place.",
  "replace": "Replaces the contents of this hash with other_hash.\n\n  h = { \"a\" => 100, \"b\" => 200 }\n  h.replace({ \"c\" => 300, \"d\" => 400 }) # => {\"c\"=>300, \"d\"=>400}",
  "delete": "Removes the specified key from the hash.",
  "stringify_keys!": "",
  "deep_stringify_keys!": "",
  "stringify_keys": "",
  "deep_stringify_keys": "",
  "symbolize_keys": "",
  "deep_symbolize_keys": "",
  "to_options!": "",
  "select": "",
  "reject": "",
  "to_hash": "Convert to a regular hash with string keys.",
  "convert_key": "",
  "convert_value": ""
}