{
  "wrapped_string": "Returns the value of attribute wrapped_string",
  "to_s": "Returns the value of attribute wrapped_string",
  "to_str": "Returns the value of attribute wrapped_string",
  "initialize": "Creates a new Chars instance by wrapping _string_.",
  "method_missing": "Forward all undefined methods to the wrapped string.",
  "respond_to_missing?": "Returns +true+ if _obj_ responds to the given method. Private methods\nare included in the search only if the optional second parameter\nevaluates to +true+.",
  "consumes?": "Returns +true+ when the proxy class can handle the string. Returns\n+false+ otherwise.",
  "split": "Works just like <tt>String#split</tt>, with the exception that the items\nin the resulting list are Chars instances instead of String. This makes\nchaining methods easier.\n\n  'Café périferôl'.mb_chars.split(/é/).map { |part| part.upcase.to_s } # => [\"CAF\", \" P\", \"RIFERÔL\"]",
  "slice!": "Works like like <tt>String#slice!</tt>, but returns an instance of\nChars, or nil if the string was not modified.",
  "reverse": "Reverses all characters in the string.\n\n  'Café'.mb_chars.reverse.to_s # => 'éfaC'",
  "limit": "Limits the byte size of the string to a number of bytes without breaking\ncharacters. Usable when the storage for a string is limited for some\nreason.\n\n  'こんにちは'.mb_chars.limit(7).to_s # => \"こん\"",
  "upcase": "Converts characters in the string to uppercase.\n\n  'Laurent, où sont les tests ?'.mb_chars.upcase.to_s # => \"LAURENT, OÙ SONT LES TESTS ?\"",
  "downcase": "Converts characters in the string to lowercase.\n\n  'VĚDA A VÝZKUM'.mb_chars.downcase.to_s # => \"věda a výzkum\"",
  "swapcase": "Converts characters in the string to the opposite case.\n\n   'El Cañón\".mb_chars.swapcase.to_s # => \"eL cAÑÓN\"",
  "capitalize": "Converts the first character to uppercase and the remainder to lowercase.\n\n 'über'.mb_chars.capitalize.to_s # => \"Über\"",
  "titleize": "Capitalizes the first letter of every word, when possible.\n\n  \"ÉL QUE SE ENTERÓ\".mb_chars.titleize    # => \"Él Que Se Enteró\"\n  \"日本語\".mb_chars.titleize                 # => \"日本語\"",
  "titlecase": "Capitalizes the first letter of every word, when possible.\n\n  \"ÉL QUE SE ENTERÓ\".mb_chars.titleize    # => \"Él Que Se Enteró\"\n  \"日本語\".mb_chars.titleize                 # => \"日本語\"",
  "normalize": "Returns the KC normalization of the string by default. NFKC is\nconsidered the best normalization form for passing strings to databases\nand validations.\n\n* <tt>form</tt> - The form you want to normalize in. Should be one of the following:\n  <tt>:c</tt>, <tt>:kc</tt>, <tt>:d</tt>, or <tt>:kd</tt>. Default is\n  ActiveSupport::Multibyte::Unicode.default_normalization_form",
  "decompose": "Performs canonical decomposition on all the characters.\n\n  'é'.length                         # => 2\n  'é'.mb_chars.decompose.to_s.length # => 3",
  "compose": "Performs composition on all the characters.\n\n  'é'.length                       # => 3\n  'é'.mb_chars.compose.to_s.length # => 2",
  "grapheme_length": "Returns the number of grapheme clusters in the string.\n\n  'क्षि'.mb_chars.length   # => 4\n  'क्षि'.mb_chars.grapheme_length # => 3",
  "tidy_bytes": "Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent\nresulting in a valid UTF-8 string.\n\nPassing +true+ will forcibly tidy all bytes, assuming that the string's\nencoding is entirely CP1252 or ISO-8859-1.",
  "as_json": ":nodoc:",
  "translate_offset": ":nodoc:",
  "chars": ":nodoc:"
}