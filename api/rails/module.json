{
  "alias_method_chain": "Encapsulates the common pattern of:\n\n  alias_method :foo_without_feature, :foo\n  alias_method :foo, :foo_with_feature\n\nWith this, you simply do:\n\n  alias_method_chain :foo, :feature\n\nAnd both aliases are set up for you.\n\nQuery and bang methods (foo?, foo!) keep the same punctuation:\n\n  alias_method_chain :foo?, :feature\n\nis equivalent to\n\n  alias_method :foo_without_feature?, :foo?\n  alias_method :foo?, :foo_with_feature?\n\nso you can safely chain foo, foo?, and foo! with the same feature.",
  "alias_attribute": "Allows you to make aliases for attributes, which includes\ngetter, setter, and query methods.\n\n  class Content < ActiveRecord::Base\n    # has a title attribute\n  end\n\n  class Email < Content\n    alias_attribute :subject, :title\n  end\n\n  e = Email.find(1)\n  e.title    # => \"Superstars\"\n  e.subject  # => \"Superstars\"\n  e.subject? # => true\n  e.subject = \"Megastars\"\n  e.title    # => \"Megastars\"",
  "anonymous?": "A module may or may not have a name.\n\n  module M; end\n  M.name # => \"M\"\n\n  m = Module.new\n  m.name # => nil\n\nA module gets a name when it is first assigned to a constant. Either\nvia the +module+ or +class+ keyword or by an explicit assignment:\n\n  m = Module.new # creates an anonymous module\n  M = m          # => m gets a name here as a side-effect\n  m.name         # => \"M\"",
  "reachable?": ":nodoc:",
  "Concerning": "= Bite-sized separation of concerns\n\nWe often find ourselves with a medium-sized chunk of behavior that we'd\nlike to extract, but only mix in to a single class.\n\nExtracting a plain old Ruby object to encapsulate it and collaborate or\ndelegate to the original object is often a good choice, but when there's\nno additional state to encapsulate or we're making DSL-style declarations\nabout the parent class, introducing new collaborators can obfuscate rather\nthan simplify.\n\nThe typical route is to just dump everything in a monolithic class, perhaps\nwith a comment, as a least-bad alternative. Using modules in separate files\nmeans tedious sifting to get a big-picture view.\n\n= Dissatisfying ways to separate small concerns\n\n== Using comments:\n\n  class Todo\n    # Other todo implementation\n    # ...\n\n    ## Event tracking\n    has_many :events\n\n    before_create :track_creation\n    after_destroy :track_deletion\n\n    private\n      def track_creation\n        # ...\n      end\n  end\n\n== With an inline module:\n\nNoisy syntax.\n\n  class Todo\n    # Other todo implementation\n    # ...\n\n    module EventTracking\n      extend ActiveSupport::Concern\n\n      included do\n        has_many :events\n        before_create :track_creation\n        after_destroy :track_deletion\n      end\n\n      private\n        def track_creation\n          # ...\n        end\n    end\n    include EventTracking\n  end\n\n== Mix-in noise exiled to its own file:\n\nOnce our chunk of behavior starts pushing the scroll-to-understand it's\nboundary, we give in and move it to a separate file. At this size, the\noverhead feels in good proportion to the size of our extraction, despite\ndiluting our at-a-glance sense of how things really work.\n\n  class Todo\n    # Other todo implementation\n    # ...\n\n    include TodoEventTracking\n  end\n\n= Introducing Module#concerning\n\nBy quieting the mix-in noise, we arrive at a natural, low-ceremony way to\nseparate bite-sized concerns.\n\n  class Todo\n    # Other todo implementation\n    # ...\n\n    concerning :EventTracking do\n      included do\n        has_many :events\n        before_create :track_creation\n        after_destroy :track_deletion\n      end\n\n      private\n        def track_creation\n          # ...\n        end\n    end\n  end\n\n  Todo.ancestors\n  # => Todo, Todo::EventTracking, Object\n\nThis small step has some wonderful ripple effects. We can\n* grok the behavior of our class in one glance,\n* clean up monolithic junk-drawer classes by separating their concerns, and\n* stop leaning on protected/private for crude \"this is internal stuff\" modularity.",
  "DelegationError": "Error generated by +delegate+ when a method is called on +nil+ and +allow_nil+\noption is not used.",
  "delegate": "Provides a +delegate+ class method to easily expose contained objects'\npublic methods as your own.\n\n==== Options\n* <tt>:to</tt> - Specifies the target object\n* <tt>:prefix</tt> - Prefixes the new method with the target name or a custom prefix\n* <tt>:allow_nil</tt> - if set to true, prevents a +NoMethodError+ to be raised\n\nThe macro receives one or more method names (specified as symbols or\nstrings) and the name of the target object via the <tt>:to</tt> option\n(also a symbol or string).\n\nDelegation is particularly useful with Active Record associations:\n\n  class Greeter < ActiveRecord::Base\n    def hello\n      'hello'\n    end\n\n    def goodbye\n      'goodbye'\n    end\n  end\n\n  class Foo < ActiveRecord::Base\n    belongs_to :greeter\n    delegate :hello, to: :greeter\n  end\n\n  Foo.new.hello   # => \"hello\"\n  Foo.new.goodbye # => NoMethodError: undefined method `goodbye' for #<Foo:0x1af30c>\n\nMultiple delegates to the same target are allowed:\n\n  class Foo < ActiveRecord::Base\n    belongs_to :greeter\n    delegate :hello, :goodbye, to: :greeter\n  end\n\n  Foo.new.goodbye # => \"goodbye\"\n\nMethods can be delegated to instance variables, class variables, or constants\nby providing them as a symbols:\n\n  class Foo\n    CONSTANT_ARRAY = [0,1,2,3]\n    @@class_array  = [4,5,6,7]\n\n    def initialize\n      @instance_array = [8,9,10,11]\n    end\n    delegate :sum, to: :CONSTANT_ARRAY\n    delegate :min, to: :@@class_array\n    delegate :max, to: :@instance_array\n  end\n\n  Foo.new.sum # => 6\n  Foo.new.min # => 4\n  Foo.new.max # => 11\n\nIt's also possible to delegate a method to the class by using +:class+:\n\n  class Foo\n    def self.hello\n      \"world\"\n    end\n\n    delegate :hello, to: :class\n  end\n\n  Foo.new.hello # => \"world\"\n\nDelegates can optionally be prefixed using the <tt>:prefix</tt> option. If the value\nis <tt>true</tt>, the delegate methods are prefixed with the name of the object being\ndelegated to.\n\n  Person = Struct.new(:name, :address)\n\n  class Invoice < Struct.new(:client)\n    delegate :name, :address, to: :client, prefix: true\n  end\n\n  john_doe = Person.new('John Doe', 'Vimmersvej 13')\n  invoice = Invoice.new(john_doe)\n  invoice.client_name    # => \"John Doe\"\n  invoice.client_address # => \"Vimmersvej 13\"\n\nIt is also possible to supply a custom prefix.\n\n  class Invoice < Struct.new(:client)\n    delegate :name, :address, to: :client, prefix: :customer\n  end\n\n  invoice = Invoice.new(john_doe)\n  invoice.customer_name    # => 'John Doe'\n  invoice.customer_address # => 'Vimmersvej 13'\n\nIf the target is +nil+ and does not respond to the delegated method a\n+NoMethodError+ is raised, as with any other value. Sometimes, however, it\nmakes sense to be robust to that situation and that is the purpose of the\n<tt>:allow_nil</tt> option: If the target is not +nil+, or it is and\nresponds to the method, everything works as usual. But if it is +nil+ and\ndoes not respond to the delegated method, +nil+ is returned.\n\n  class User < ActiveRecord::Base\n    has_one :profile\n    delegate :age, to: :profile\n  end\n\n  User.new.age # raises NoMethodError: undefined method `age'\n\nBut if not having a profile yet is fine and should not be an error\ncondition:\n\n  class User < ActiveRecord::Base\n    has_one :profile\n    delegate :age, to: :profile, allow_nil: true\n  end\n\n  User.new.age # nil\n\nNote that if the target is not +nil+ then the call is attempted regardless of the\n<tt>:allow_nil</tt> option, and thus an exception is still raised if said object\ndoes not respond to the method:\n\n  class Foo\n    def initialize(bar)\n      @bar = bar\n    end\n\n    delegate :name, to: :@bar, allow_nil: true\n  end\n\n  Foo.new(\"Bar\").name # raises NoMethodError: undefined method `name'\n\nThe target method must be public, otherwise it will raise +NoMethodError+.",
  "deprecate": "deprecate :foo\n  deprecate bar: 'message'\n  deprecate :foo, :bar, baz: 'warning!', qux: 'gone!'\n\nYou can also use custom deprecator instance:\n\n  deprecate :foo, deprecator: MyLib::Deprecator.new\n  deprecate :foo, bar: \"warning!\", deprecator: MyLib::Deprecator.new\n\n\\Custom deprecators must respond to <tt>deprecation_warning(deprecated_method_name, message, caller_backtrace)</tt>\nmethod where you can implement your custom warning behavior.\n\n  class MyLib::Deprecator\n    def deprecation_warning(deprecated_method_name, message, caller_backtrace = nil)\n       message = \"#{deprecated_method_name} is deprecated and will be removed from MyLibrary | #{message}\"\n       Kernel.warn message\n    end\n  end",
  "parent_name": "Returns the name of the module containing this one.\n\n  M::N.parent_name # => \"M\"",
  "parent": "Returns the module which contains this one according to its name.\n\n  module M\n    module N\n    end\n  end\n  X = M::N\n\n  M::N.parent # => M\n  X.parent    # => M\n\nThe parent of top-level and anonymous modules is Object.\n\n  M.parent          # => Object\n  Module.new.parent # => Object",
  "parents": "Returns all the parents of this module according to its name, ordered from\nnested outwards. The receiver is not contained within the result.\n\n  module M\n    module N\n    end\n  end\n  X = M::N\n\n  M.parents    # => [Object]\n  M::N.parents # => [M, Object]\n  X.parents    # => [M, Object]",
  "local_constants": ":nodoc:",
  "attr_internal_reader": "Declares an attribute reader backed by an internally-named instance variable.",
  "attr_internal_writer": "Declares an attribute writer backed by an internally-named instance variable.",
  "attr_internal_accessor": "Declares an attribute reader and writer backed by an internally-named instance\nvariable.",
  "attr_internal": "Declares an attribute reader and writer backed by an internally-named instance\nvariable.",
  "attr_internal_naming_format": "Returns the value of attribute attr_internal_naming_format",
  "attr_internal_naming_format=": "Sets the attribute attr_internal_naming_format",
  "attr_internal_ivar_name": "",
  "attr_internal_define": "",
  "remove_possible_method": "",
  "redefine_method": "",
  "qualified_const_defined?": "",
  "qualified_const_get": "",
  "qualified_const_set": "",
  "mattr_reader": "Defines a class attribute and creates a class and instance reader methods.\nThe underlying the class variable is set to +nil+, if it is not previously\ndefined.\n\n  module HairColors\n    mattr_reader :hair_colors\n  end\n\n  HairColors.hair_colors # => nil\n  HairColors.class_variable_set(\"@@hair_colors\", [:brown, :black])\n  HairColors.hair_colors # => [:brown, :black]\n\nThe attribute name must be a valid method name in Ruby.\n\n  module Foo\n    mattr_reader :\"1_Badname \"\n  end\n  # => NameError: invalid attribute name\n\nIf you want to opt out the creation on the instance reader method, pass\n<tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.\n\n  module HairColors\n    mattr_writer :hair_colors, instance_reader: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors # => NoMethodError\n\n\nAlso, you can pass a block to set up the attribute with a default value.\n\n  module HairColors\n    cattr_reader :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.hair_colors # => [:brown, :black, :blonde, :red]",
  "cattr_reader": "Defines a class attribute and creates a class and instance reader methods.\nThe underlying the class variable is set to +nil+, if it is not previously\ndefined.\n\n  module HairColors\n    mattr_reader :hair_colors\n  end\n\n  HairColors.hair_colors # => nil\n  HairColors.class_variable_set(\"@@hair_colors\", [:brown, :black])\n  HairColors.hair_colors # => [:brown, :black]\n\nThe attribute name must be a valid method name in Ruby.\n\n  module Foo\n    mattr_reader :\"1_Badname \"\n  end\n  # => NameError: invalid attribute name\n\nIf you want to opt out the creation on the instance reader method, pass\n<tt>instance_reader: false</tt> or <tt>instance_accessor: false</tt>.\n\n  module HairColors\n    mattr_writer :hair_colors, instance_reader: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors # => NoMethodError\n\n\nAlso, you can pass a block to set up the attribute with a default value.\n\n  module HairColors\n    cattr_reader :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.hair_colors # => [:brown, :black, :blonde, :red]",
  "mattr_writer": "Defines a class attribute and creates a class and instance writer methods to\nallow assignment to the attribute.\n\n  module HairColors\n    mattr_writer :hair_colors\n  end\n\n  class Person\n    include HairColors\n  end\n\n  HairColors.hair_colors = [:brown, :black]\n  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black]\n  Person.new.hair_colors = [:blonde, :red]\n  HairColors.class_variable_get(\"@@hair_colors\") # => [:blonde, :red]\n\nIf you want to opt out the instance writer method, pass\n<tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.\n\n  module HairColors\n    mattr_writer :hair_colors, instance_writer: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:blonde, :red] # => NoMethodError\n\nAlso, you can pass a block to set up the attribute with a default value.\n\n  class HairColors\n    mattr_writer :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black, :blonde, :red]",
  "cattr_writer": "Defines a class attribute and creates a class and instance writer methods to\nallow assignment to the attribute.\n\n  module HairColors\n    mattr_writer :hair_colors\n  end\n\n  class Person\n    include HairColors\n  end\n\n  HairColors.hair_colors = [:brown, :black]\n  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black]\n  Person.new.hair_colors = [:blonde, :red]\n  HairColors.class_variable_get(\"@@hair_colors\") # => [:blonde, :red]\n\nIf you want to opt out the instance writer method, pass\n<tt>instance_writer: false</tt> or <tt>instance_accessor: false</tt>.\n\n  module HairColors\n    mattr_writer :hair_colors, instance_writer: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:blonde, :red] # => NoMethodError\n\nAlso, you can pass a block to set up the attribute with a default value.\n\n  class HairColors\n    mattr_writer :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.class_variable_get(\"@@hair_colors\") # => [:brown, :black, :blonde, :red]",
  "mattr_accessor": "Defines both class and instance accessors for class attributes.\n\n  module HairColors\n    mattr_accessor :hair_colors\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.hair_colors = [:brown, :black, :blonde, :red]\n  Person.hair_colors     # => [:brown, :black, :blonde, :red]\n  Person.new.hair_colors # => [:brown, :black, :blonde, :red]\n\nIf a subclass changes the value then that would also change the value for\nparent class. Similarly if parent class changes the value then that would\nchange the value of subclasses too.\n\n  class Male < Person\n  end\n\n  Male.hair_colors << :blue\n  Person.hair_colors # => [:brown, :black, :blonde, :red, :blue]\n\nTo opt out of the instance writer method, pass <tt>instance_writer: false</tt>.\nTo opt out of the instance reader method, pass <tt>instance_reader: false</tt>.\n\n  module HairColors\n    mattr_accessor :hair_colors, instance_writer: false, instance_reader: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:brown]  # => NoMethodError\n  Person.new.hair_colors             # => NoMethodError\n\nOr pass <tt>instance_accessor: false</tt>, to opt out both instance methods.\n\n  module HairColors\n    mattr_accessor :hair_colors, instance_accessor: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:brown]  # => NoMethodError\n  Person.new.hair_colors             # => NoMethodError\n\nAlso you can pass a block to set up the attribute with a default value.\n\n  module HairColors\n    mattr_accessor :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.class_variable_get(\"@@hair_colors\") #=> [:brown, :black, :blonde, :red]",
  "cattr_accessor": "Defines both class and instance accessors for class attributes.\n\n  module HairColors\n    mattr_accessor :hair_colors\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.hair_colors = [:brown, :black, :blonde, :red]\n  Person.hair_colors     # => [:brown, :black, :blonde, :red]\n  Person.new.hair_colors # => [:brown, :black, :blonde, :red]\n\nIf a subclass changes the value then that would also change the value for\nparent class. Similarly if parent class changes the value then that would\nchange the value of subclasses too.\n\n  class Male < Person\n  end\n\n  Male.hair_colors << :blue\n  Person.hair_colors # => [:brown, :black, :blonde, :red, :blue]\n\nTo opt out of the instance writer method, pass <tt>instance_writer: false</tt>.\nTo opt out of the instance reader method, pass <tt>instance_reader: false</tt>.\n\n  module HairColors\n    mattr_accessor :hair_colors, instance_writer: false, instance_reader: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:brown]  # => NoMethodError\n  Person.new.hair_colors             # => NoMethodError\n\nOr pass <tt>instance_accessor: false</tt>, to opt out both instance methods.\n\n  module HairColors\n    mattr_accessor :hair_colors, instance_accessor: false\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.new.hair_colors = [:brown]  # => NoMethodError\n  Person.new.hair_colors             # => NoMethodError\n\nAlso you can pass a block to set up the attribute with a default value.\n\n  module HairColors\n    mattr_accessor :hair_colors do\n      [:brown, :black, :blonde, :red]\n    end\n  end\n\n  class Person\n    include HairColors\n  end\n\n  Person.class_variable_get(\"@@hair_colors\") #=> [:brown, :black, :blonde, :red]",
  "methods_transplantable?": "TODO: remove this after 1.9 support is dropped"
}