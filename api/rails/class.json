{
  "class_attribute": "Declare a class-level attribute whose value is inheritable by subclasses.\nSubclasses can change their own value and it will not impact parent class.\n\n  class Base\n    class_attribute :setting\n  end\n\n  class Subclass < Base\n  end\n\n  Base.setting = true\n  Subclass.setting            # => true\n  Subclass.setting = false\n  Subclass.setting            # => false\n  Base.setting                # => true\n\nIn the above case as long as Subclass does not assign a value to setting\nby performing <tt>Subclass.setting = _something_ </tt>, <tt>Subclass.setting</tt>\nwould read value assigned to parent class. Once Subclass assigns a value then\nthe value assigned by Subclass would be returned.\n\nThis matches normal Ruby method inheritance: think of writing an attribute\non a subclass as overriding the reader method. However, you need to be aware\nwhen using +class_attribute+ with mutable structures as +Array+ or +Hash+.\nIn such cases, you don't want to do changes in places but use setters:\n\n  Base.setting = []\n  Base.setting                # => []\n  Subclass.setting            # => []\n\n  # Appending in child changes both parent and child because it is the same object:\n  Subclass.setting << :foo\n  Base.setting               # => [:foo]\n  Subclass.setting           # => [:foo]\n\n  # Use setters to not propagate changes:\n  Base.setting = []\n  Subclass.setting += [:foo]\n  Base.setting               # => []\n  Subclass.setting           # => [:foo]\n\nFor convenience, an instance predicate method is defined as well.\nTo skip it, pass <tt>instance_predicate: false</tt>.\n\n  Subclass.setting?       # => false\n\nInstances may overwrite the class value in the same way:\n\n  Base.setting = true\n  object = Base.new\n  object.setting          # => true\n  object.setting = false\n  object.setting          # => false\n  Base.setting            # => true\n\nTo opt out of the instance reader method, pass <tt>instance_reader: false</tt>.\n\n  object.setting          # => NoMethodError\n  object.setting?         # => NoMethodError\n\nTo opt out of the instance writer method, pass <tt>instance_writer: false</tt>.\n\n  object.setting = false  # => NoMethodError\n\nTo opt out of both instance methods, pass <tt>instance_accessor: false</tt>.",
  "singleton_class?": "",
  "subclasses": "Returns an array with the direct children of +self+.\n\n  Integer.subclasses # => [Fixnum, Bignum]\n\n  class Foo; end\n  class Bar < Foo; end\n  class Baz < Bar; end\n\n  Foo.subclasses # => [Bar]",
  "superclass_delegating_accessor": "",
  "_stash_object_in_method": "Take the object being set and store it in a method. This gives us automatic\ninheritance behavior, without having to store the object in an instance\nvariable and look up the superclass chain manually.",
  "_superclass_delegating_accessor": ""
}