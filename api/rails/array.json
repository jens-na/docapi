{
  "wrap": "Wraps its argument in an array unless it is already an array (or array-like).\n\nSpecifically:\n\n* If the argument is +nil+ an empty list is returned.\n* Otherwise, if the argument responds to +to_ary+ it is invoked, and its result returned.\n* Otherwise, returns an array with the argument as its single element.\n\n    Array.wrap(nil)       # => []\n    Array.wrap([1, 2, 3]) # => [1, 2, 3]\n    Array.wrap(0)         # => [0]\n\nThis method is similar in purpose to <tt>Kernel#Array</tt>, but there are some differences:\n\n* If the argument responds to +to_ary+ the method is invoked. <tt>Kernel#Array</tt>\n  moves on to try +to_a+ if the returned value is +nil+, but <tt>Array.wrap</tt> returns\n  +nil+ right away.\n* If the returned value from +to_ary+ is neither +nil+ nor an +Array+ object, <tt>Kernel#Array</tt>\n  raises an exception, while <tt>Array.wrap</tt> does not, it just returns the value.\n* It does not call +to_a+ on the argument, but returns an empty array if argument is +nil+.\n\nThe second point is easily explained with some enumerables:\n\n  Array(foo: :bar)      # => [[:foo, :bar]]\n  Array.wrap(foo: :bar) # => [{:foo=>:bar}]\n\nThere's also a related idiom that uses the splat operator:\n\n  [*object]\n\nwhich returns <tt>[]</tt> for +nil+, but calls to <tt>Array(object)</tt> otherwise.\n\nThe differences with <tt>Kernel#Array</tt> explained above\napply to the rest of <tt>object</tt>s.",
  "as_json": ":nodoc:",
  "from": "Returns the tail of the array from +position+.\n\n  %w( a b c d ).from(0)  # => [\"a\", \"b\", \"c\", \"d\"]\n  %w( a b c d ).from(2)  # => [\"c\", \"d\"]\n  %w( a b c d ).from(10) # => []\n  %w().from(0)           # => []",
  "to": "Returns the beginning of the array up to +position+.\n\n  %w( a b c d ).to(0)  # => [\"a\"]\n  %w( a b c d ).to(2)  # => [\"a\", \"b\", \"c\"]\n  %w( a b c d ).to(10) # => [\"a\", \"b\", \"c\", \"d\"]\n  %w().to(0)           # => []",
  "second": "Equal to <tt>self[1]</tt>.\n\n  %w( a b c d e ).second # => \"b\"",
  "third": "Equal to <tt>self[2]</tt>.\n\n  %w( a b c d e ).third # => \"c\"",
  "fourth": "Equal to <tt>self[3]</tt>.\n\n  %w( a b c d e ).fourth # => \"d\"",
  "fifth": "Equal to <tt>self[4]</tt>.\n\n  %w( a b c d e ).fifth # => \"e\"",
  "forty_two": "Equal to <tt>self[41]</tt>. Also known as accessing \"the reddit\".\n\n  (1..42).to_a.forty_two # => 42",
  "blank?": "An array is blank if it's empty:\n\n  [].blank?      # => true\n  [1,2,3].blank? # => false",
  "in_groups_of": "Splits or iterates over the array in groups of size +number+,\npadding any remaining slots with +fill_with+ unless it is +false+.\n\n  %w(1 2 3 4 5 6 7 8 9 10).in_groups_of(3) {|group| p group}\n  [\"1\", \"2\", \"3\"]\n  [\"4\", \"5\", \"6\"]\n  [\"7\", \"8\", \"9\"]\n  [\"10\", nil, nil]\n\n  %w(1 2 3 4 5).in_groups_of(2, '&nbsp;') {|group| p group}\n  [\"1\", \"2\"]\n  [\"3\", \"4\"]\n  [\"5\", \"&nbsp;\"]\n\n  %w(1 2 3 4 5).in_groups_of(2, false) {|group| p group}\n  [\"1\", \"2\"]\n  [\"3\", \"4\"]\n  [\"5\"]",
  "in_groups": "Splits or iterates over the array in +number+ of groups, padding any\nremaining slots with +fill_with+ unless it is +false+.\n\n  %w(1 2 3 4 5 6 7 8 9 10).in_groups(3) {|group| p group}\n  [\"1\", \"2\", \"3\", \"4\"]\n  [\"5\", \"6\", \"7\", nil]\n  [\"8\", \"9\", \"10\", nil]\n\n  %w(1 2 3 4 5 6 7 8 9 10).in_groups(3, '&nbsp;') {|group| p group}\n  [\"1\", \"2\", \"3\", \"4\"]\n  [\"5\", \"6\", \"7\", \"&nbsp;\"]\n  [\"8\", \"9\", \"10\", \"&nbsp;\"]\n\n  %w(1 2 3 4 5 6 7).in_groups(3, false) {|group| p group}\n  [\"1\", \"2\", \"3\"]\n  [\"4\", \"5\"]\n  [\"6\", \"7\"]",
  "split": "Divides the array into one or more subarrays based on a delimiting +value+\nor the result of an optional block.\n\n  [1, 2, 3, 4, 5].split(3)              # => [[1, 2], [4, 5]]\n  (1..10).to_a.split { |i| i % 3 == 0 } # => [[1, 2], [4, 5], [7, 8], [10]]",
  "to_query": "Converts an array into a string suitable for use as a URL query string,\nusing the given +key+ as the param name.\n\n  ['Rails', 'coding'].to_query('hobbies') # => \"hobbies%5B%5D=Rails&hobbies%5B%5D=coding\"",
  "deep_dup": "Returns a deep copy of array.\n\n  array = [1, [2, 3]]\n  dup   = array.deep_dup\n  dup[1][2] = 4\n\n  array[1][2] # => nil\n  dup[1][2]   # => 4",
  "to_param": "Calls <tt>to_param</tt> on all its elements and joins the result with\nslashes. This is used by <tt>url_for</tt> in Action Pack.",
  "to_sentence": "Converts the array to a comma-separated sentence where the last element is\njoined by the connector word.\n\nYou can pass the following options to change the default behavior. If you\npass an option key that doesn't exist in the list below, it will raise an\n<tt>ArgumentError</tt>.\n\n==== Options\n\n* <tt>:words_connector</tt> - The sign or word used to join the elements\n  in arrays with two or more elements (default: \", \").\n* <tt>:two_words_connector</tt> - The sign or word used to join the elements\n  in arrays with two elements (default: \" and \").\n* <tt>:last_word_connector</tt> - The sign or word used to join the last element\n  in arrays with three or more elements (default: \", and \").\n* <tt>:locale</tt> - If +i18n+ is available, you can set a locale and use\n  the connector options defined on the 'support.array' namespace in the\n  corresponding dictionary file.\n\n==== Examples\n\n  [].to_sentence                      # => \"\"\n  ['one'].to_sentence                 # => \"one\"\n  ['one', 'two'].to_sentence          # => \"one and two\"\n  ['one', 'two', 'three'].to_sentence # => \"one, two, and three\"\n\n  ['one', 'two'].to_sentence(passing: 'invalid option')\n  # => ArgumentError: Unknown key :passing\n\n  ['one', 'two'].to_sentence(two_words_connector: '-')\n  # => \"one-two\"\n\n  ['one', 'two', 'three'].to_sentence(words_connector: ' or ', last_word_connector: ' or at least ')\n  # => \"one or two or at least three\"\n\nUsing <tt>:locale</tt> option:\n\n  # Given this locale dictionary:\n  #\n  #   es:\n  #     support:\n  #       array:\n  #         words_connector: \" o \"\n  #         two_words_connector: \" y \"\n  #         last_word_connector: \" o al menos \"\n\n  ['uno', 'dos'].to_sentence(locale: :es)\n  # => \"uno y dos\"\n\n  ['uno', 'dos', 'tres'].to_sentence(locale: :es)\n  # => \"uno o dos o al menos tres\"",
  "to_formatted_s": "Extends <tt>Array#to_s</tt> to convert a collection of elements into a\ncomma separated id list if <tt>:db</tt> argument is given as the format.\n\n  Blog.all.to_formatted_s(:db) # => \"1,2,3\"",
  "to_default_s": "",
  "to_s": "Extends <tt>Array#to_s</tt> to convert a collection of elements into a\ncomma separated id list if <tt>:db</tt> argument is given as the format.\n\n  Blog.all.to_formatted_s(:db) # => \"1,2,3\"",
  "to_xml": "Returns a string that represents the array in XML by invoking +to_xml+\non each element. Active Record collections delegate their representation\nin XML to this method.\n\nAll elements are expected to respond to +to_xml+, if any of them does\nnot then an exception is raised.\n\nThe root node reflects the class name of the first element in plural\nif all elements belong to the same type and that's not Hash:\n\n  customer.projects.to_xml\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <projects type=\"array\">\n    <project>\n      <amount type=\"decimal\">20000.0</amount>\n      <customer-id type=\"integer\">1567</customer-id>\n      <deal-date type=\"date\">2008-04-09</deal-date>\n      ...\n    </project>\n    <project>\n      <amount type=\"decimal\">57230.0</amount>\n      <customer-id type=\"integer\">1567</customer-id>\n      <deal-date type=\"date\">2008-04-15</deal-date>\n      ...\n    </project>\n  </projects>\n\nOtherwise the root element is \"objects\":\n\n  [{ foo: 1, bar: 2}, { baz: 3}].to_xml\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <objects type=\"array\">\n    <object>\n      <bar type=\"integer\">2</bar>\n      <foo type=\"integer\">1</foo>\n    </object>\n    <object>\n      <baz type=\"integer\">3</baz>\n    </object>\n  </objects>\n\nIf the collection is empty the root element is \"nil-classes\" by default:\n\n  [].to_xml\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <nil-classes type=\"array\"/>\n\nTo ensure a meaningful root element use the <tt>:root</tt> option:\n\n  customer_with_no_projects.projects.to_xml(root: 'projects')\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <projects type=\"array\"/>\n\nBy default name of the node for the children of root is <tt>root.singularize</tt>.\nYou can change it with the <tt>:children</tt> option.\n\nThe +options+ hash is passed downwards:\n\n  Message.all.to_xml(skip_types: true)\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <messages>\n    <message>\n      <created-at>2008-03-07T09:58:18+01:00</created-at>\n      <id>1</id>\n      <name>1</name>\n      <updated-at>2008-03-07T09:58:18+01:00</updated-at>\n      <user-id>1</user-id>\n    </message>\n  </messages>",
  "extract_options!": "Extracts options from a set of arguments. Removes and returns the last\nelement in the array if it's a hash, otherwise returns a blank hash.\n\n  def options(*args)\n    args.extract_options!\n  end\n\n  options(1, 2)        # => {}\n  options(1, 2, a: :b) # => {:a=>:b}",
  "append": "The human way of thinking about adding stuff to the end of a list is with append.",
  "prepend": "The human way of thinking about adding stuff to the beginning of a list is with prepend."
}