{
  "CALLBACKS_OPTIONS": "",
  "messages": "Returns the value of attribute messages",
  "initialize": "Pass in the instance of the object that is using the errors object.\n\n  class Person\n    def initialize\n      @errors = ActiveModel::Errors.new(self)\n    end\n  end",
  "initialize_dup": ":nodoc:",
  "clear": "Clear the error messages.\n\n  person.errors.full_messages # => [\"name cannot be nil\"]\n  person.errors.clear\n  person.errors.full_messages # => []",
  "include?": "Returns +true+ if the error messages include an error for the given key\n+attribute+, +false+ otherwise.\n\n  person.errors.messages        # => {:name=>[\"cannot be nil\"]}\n  person.errors.include?(:name) # => true\n  person.errors.include?(:age)  # => false",
  "has_key?": "Returns +true+ if the error messages include an error for the given key\n+attribute+, +false+ otherwise.\n\n  person.errors.messages        # => {:name=>[\"cannot be nil\"]}\n  person.errors.include?(:name) # => true\n  person.errors.include?(:age)  # => false\naliases include?",
  "get": "Get messages for +key+.\n\n  person.errors.messages   # => {:name=>[\"cannot be nil\"]}\n  person.errors.get(:name) # => [\"cannot be nil\"]\n  person.errors.get(:age)  # => nil",
  "set": "Set messages for +key+ to +value+.\n\n  person.errors.get(:name) # => [\"cannot be nil\"]\n  person.errors.set(:name, [\"can't be nil\"])\n  person.errors.get(:name) # => [\"can't be nil\"]",
  "delete": "Delete messages for +key+. Returns the deleted messages.\n\n  person.errors.get(:name)    # => [\"cannot be nil\"]\n  person.errors.delete(:name) # => [\"cannot be nil\"]\n  person.errors.get(:name)    # => nil",
  "[]": "When passed a symbol or a name of a method, returns an array of errors\nfor the method.\n\n  person.errors[:name]  # => [\"cannot be nil\"]\n  person.errors['name'] # => [\"cannot be nil\"]",
  "[]=": "Adds to the supplied attribute the supplied error message.\n\n  person.errors[:name] = \"must be set\"\n  person.errors[:name] # => ['must be set']",
  "each": "Iterates through each error key, value pair in the error messages hash.\nYields the attribute and the error for that attribute. If the attribute\nhas more than one error message, yields once for each error message.\n\n  person.errors.add(:name, \"can't be blank\")\n  person.errors.each do |attribute, error|\n    # Will yield :name and \"can't be blank\"\n  end\n\n  person.errors.add(:name, \"must be specified\")\n  person.errors.each do |attribute, error|\n    # Will yield :name and \"can't be blank\"\n    # then yield :name and \"must be specified\"\n  end",
  "size": "Returns the number of error messages.\n\n  person.errors.add(:name, \"can't be blank\")\n  person.errors.size # => 1\n  person.errors.add(:name, \"must be specified\")\n  person.errors.size # => 2",
  "values": "Returns all message values.\n\n  person.errors.messages # => {:name=>[\"cannot be nil\", \"must be specified\"]}\n  person.errors.values   # => [[\"cannot be nil\", \"must be specified\"]]",
  "keys": "Returns all message keys.\n\n  person.errors.messages # => {:name=>[\"cannot be nil\", \"must be specified\"]}\n  person.errors.keys     # => [:name]",
  "to_a": "Returns an array of error messages, with the attribute name included.\n\n  person.errors.add(:name, \"can't be blank\")\n  person.errors.add(:name, \"must be specified\")\n  person.errors.to_a # => [\"name can't be blank\", \"name must be specified\"]",
  "count": "Returns the number of error messages.\n\n  person.errors.add(:name, \"can't be blank\")\n  person.errors.count # => 1\n  person.errors.add(:name, \"must be specified\")\n  person.errors.count # => 2",
  "empty?": "Returns +true+ if no errors are found, +false+ otherwise.\nIf the error message is a string it can be empty.\n\n  person.errors.full_messages # => [\"name cannot be nil\"]\n  person.errors.empty?        # => false",
  "blank?": "Returns +true+ if no errors are found, +false+ otherwise.\nIf the error message is a string it can be empty.\n\n  person.errors.full_messages # => [\"name cannot be nil\"]\n  person.errors.empty?        # => false\naliases empty?",
  "to_xml": "Returns an xml formatted representation of the Errors hash.\n\n  person.errors.add(:name, \"can't be blank\")\n  person.errors.add(:name, \"must be specified\")\n  person.errors.to_xml\n  # =>\n  #  <?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\n  #  <errors>\n  #    <error>name can't be blank</error>\n  #    <error>name must be specified</error>\n  #  </errors>",
  "as_json": "Returns a Hash that can be used as the JSON representation for this\nobject. You can pass the <tt>:full_messages</tt> option. This determines\nif the json object should contain full messages or not (false by default).\n\n  person.errors.as_json                      # => {:name=>[\"cannot be nil\"]}\n  person.errors.as_json(full_messages: true) # => {:name=>[\"name cannot be nil\"]}",
  "to_hash": "Returns a Hash of attributes with their error messages. If +full_messages+\nis +true+, it will contain full messages (see +full_message+).\n\n  person.errors.to_hash       # => {:name=>[\"cannot be nil\"]}\n  person.errors.to_hash(true) # => {:name=>[\"name cannot be nil\"]}",
  "add": "Adds +message+ to the error messages on +attribute+. More than one error\ncan be added to the same +attribute+. If no +message+ is supplied,\n<tt>:invalid</tt> is assumed.\n\n  person.errors.add(:name)\n  # => [\"is invalid\"]\n  person.errors.add(:name, 'must be implemented')\n  # => [\"is invalid\", \"must be implemented\"]\n\n  person.errors.messages\n  # => {:name=>[\"must be implemented\", \"is invalid\"]}\n\nIf +message+ is a symbol, it will be translated using the appropriate\nscope (see +generate_message+).\n\nIf +message+ is a proc, it will be called, allowing for things like\n<tt>Time.now</tt> to be used within an error.\n\nIf the <tt>:strict</tt> option is set to +true+, it will raise\nActiveModel::StrictValidationFailed instead of adding the error.\n<tt>:strict</tt> option can also be set to any other exception.\n\n  person.errors.add(:name, nil, strict: true)\n  # => ActiveModel::StrictValidationFailed: name is invalid\n  person.errors.add(:name, nil, strict: NameIsInvalid)\n  # => NameIsInvalid: name is invalid\n\n  person.errors.messages # => {}",
  "add_on_empty": "Will add an error message to each of the attributes in +attributes+\nthat is empty.\n\n  person.errors.add_on_empty(:name)\n  person.errors.messages\n  # => {:name=>[\"can't be empty\"]}",
  "add_on_blank": "Will add an error message to each of the attributes in +attributes+ that\nis blank (using Object#blank?).\n\n  person.errors.add_on_blank(:name)\n  person.errors.messages\n  # => {:name=>[\"can't be blank\"]}",
  "added?": "Returns +true+ if an error on the attribute with the given message is\npresent, +false+ otherwise. +message+ is treated the same as for +add+.\n\n  person.errors.add :name, :blank\n  person.errors.added? :name, :blank # => true",
  "full_messages": "Returns all the full error messages in an array.\n\n  class Person\n    validates_presence_of :name, :address, :email\n    validates_length_of :name, in: 5..30\n  end\n\n  person = Person.create(address: '123 First St.')\n  person.errors.full_messages\n  # => [\"Name is too short (minimum is 5 characters)\", \"Name can't be blank\", \"Email can't be blank\"]",
  "full_messages_for": "Returns all the full error messages for a given attribute in an array.\n\n  class Person\n    validates_presence_of :name, :email\n    validates_length_of :name, in: 5..30\n  end\n\n  person = Person.create()\n  person.errors.full_messages_for(:name)\n  # => [\"Name is too short (minimum is 5 characters)\", \"Name can't be blank\"]",
  "full_message": "Returns a full message for a given attribute.\n\n  person.errors.full_message(:name, 'is invalid') # => \"Name is invalid\"",
  "generate_message": "Translates an error message in its default scope\n(<tt>activemodel.errors.messages</tt>).\n\nError messages are first looked up in <tt>models.MODEL.attributes.ATTRIBUTE.MESSAGE</tt>,\nif it's not there, it's looked up in <tt>models.MODEL.MESSAGE</tt> and if\nthat is not there also, it returns the translation of the default message\n(e.g. <tt>activemodel.errors.messages.MESSAGE</tt>). The translated model\nname, translated attribute name and the value are available for\ninterpolation.\n\nWhen using inheritance in your models, it will check all the inherited\nmodels too, but only if the model itself hasn't been found. Say you have\n<tt>class Admin < User; end</tt> and you wanted the translation for\nthe <tt>:blank</tt> error message for the <tt>title</tt> attribute,\nit looks for these translations:\n\n* <tt>activemodel.errors.models.admin.attributes.title.blank</tt>\n* <tt>activemodel.errors.models.admin.blank</tt>\n* <tt>activemodel.errors.models.user.attributes.title.blank</tt>\n* <tt>activemodel.errors.models.user.blank</tt>\n* any default you provided through the +options+ hash (in the <tt>activemodel.errors</tt> scope)\n* <tt>activemodel.errors.messages.blank</tt>\n* <tt>errors.attributes.title.blank</tt>\n* <tt>errors.messages.blank</tt>",
  "normalize_message": ""
}